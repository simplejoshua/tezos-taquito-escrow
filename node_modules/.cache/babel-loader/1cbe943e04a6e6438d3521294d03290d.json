{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport { windowRef, Serializer, getSenderId, MessageBasedClient } from '@airgap/beacon-core';\nimport { openCryptobox } from '@airgap/beacon-utils';\nimport { ExtensionMessageTarget, Origin } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n *\n */\n\nexport class PostMessageClient extends MessageBasedClient {\n  constructor() {\n    super(...arguments);\n    this.activeListeners = new Map();\n  }\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.subscribeToMessages().catch(console.error);\n    });\n  }\n\n  listenForEncryptedMessage(senderPublicKey, messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.activeListeners.has(senderPublicKey)) {\n        return;\n      }\n\n      const callbackFunction = (message, context) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const decryptedMessage = yield this.decryptMessage(senderPublicKey, message.encryptedPayload); // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n          // TODO: Add check for correct decryption key / sender ID\n\n          messageCallback(decryptedMessage, context);\n        } catch (decryptionError) {\n          /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n        }\n      });\n\n      this.activeListeners.set(senderPublicKey, callbackFunction);\n    });\n  }\n\n  sendMessage(message, peer) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const payload = yield this.encryptMessage(peer.publicKey, message);\n      const targetId = (_a = peer) === null || _a === void 0 ? void 0 : _a.extensionId; // if no targetId, we remove peer\n\n      const msg = {\n        target: ExtensionMessageTarget.EXTENSION,\n        encryptedPayload: payload,\n        targetId\n      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      windowRef.postMessage(msg, windowRef.location.origin);\n    });\n  }\n\n  listenForChannelOpening(messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const fn = event => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n\n        if (event.source !== windowRef || event.origin !== windowRef.location.origin) {\n          // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')\n          return;\n        }\n\n        const data = (_a = event === null || event === void 0 ? void 0 : event.data) === null || _a === void 0 ? void 0 : _a.message;\n\n        if (data && data.target === ExtensionMessageTarget.PAGE && (yield this.isChannelOpenMessage(data))) {\n          const payload = Buffer.from(data.payload, 'hex');\n\n          if (payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n            try {\n              const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n              messageCallback(Object.assign(Object.assign({}, pairingResponse), {\n                senderId: yield getSenderId(pairingResponse.publicKey),\n                extensionId: (_b = event === null || event === void 0 ? void 0 : event.data) === null || _b === void 0 ? void 0 : _b.sender.id\n              }));\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      });\n\n      windowRef.addEventListener('message', fn);\n    });\n  }\n\n  sendPairingRequest(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const message = {\n        target: ExtensionMessageTarget.EXTENSION,\n        payload: yield new Serializer().serialize(yield this.getPairingRequestInfo()),\n        targetId: id\n      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      windowRef.postMessage(message, windowRef.location.origin);\n    });\n  }\n\n  isChannelOpenMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return typeof message === 'object' && message.hasOwnProperty('payload');\n    });\n  }\n\n  subscribeToMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      windowRef.addEventListener('message', message => {\n        if (message.source !== windowRef || message.origin !== windowRef.location.origin) {\n          // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')\n          return;\n        }\n\n        if (typeof message === 'object' && message) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const data = message.data;\n\n          if (data.message && data.message.target === ExtensionMessageTarget.PAGE) {\n            this.activeListeners.forEach(listener => {\n              listener(data.message, {\n                origin: Origin.EXTENSION,\n                id: data.sender.id || ''\n              });\n            });\n          }\n        }\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/PostMessageClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,2BAAT,EAAsC,yBAAtC,QAAuE,oBAAvE;AAEA,SAAS,SAAT,EAAoB,UAApB,EAAgC,WAAhC,EAA6C,kBAA7C,QAAuE,qBAAvE;AAEA,SAAS,aAAT,QAA8B,sBAA9B;AACA,SAEE,sBAFF,EAGE,MAHF,QASO,sBATP;AAWA;;;;AAIG;;AACH,OAAM,MAAO,iBAAP,SAAiC,kBAAjC,CAAmD;EAAzD,WAAA,GAAA;;IACqB,KAAA,eAAA,GAGf,IAAI,GAAJ,EAHe;EAyIpB;;EApIc,IAAI,GAAA;;MACf,KAAK,mBAAL,GAA2B,KAA3B,CAAiC,OAAO,CAAC,KAAzC;IACD,C;EAAA;;EAEY,yBAAyB,CACpC,eADoC,EAEpC,eAFoC,EAEkC;;MAEtE,IAAI,KAAK,eAAL,CAAqB,GAArB,CAAyB,eAAzB,CAAJ,EAA+C;QAC7C;MACD;;MAED,MAAM,gBAAgB,GAAG,CACvB,OADuB,EAEvB,OAFuB,KAGN,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;QACjB,IAAI;UACF,MAAM,gBAAgB,GAAG,MAAM,KAAK,cAAL,CAC7B,eAD6B,EAE7B,OAAO,CAAC,gBAFqB,CAA/B,CADE,CAKF;UACA;;UACA,eAAe,CAAC,gBAAD,EAAmB,OAAnB,CAAf;QACD,CARD,CAQE,OAAO,eAAP,EAAwB;UACxB;QACD;MACF,CAZkB,CAHnB;;MAiBA,KAAK,eAAL,CAAqB,GAArB,CAAyB,eAAzB,EAA0C,gBAA1C;IACD,C;EAAA;;EAEY,WAAW,CACtB,OADsB,EAEtB,IAFsB,EAE8C;;;;MAEpE,MAAM,OAAO,GAAG,MAAM,KAAK,cAAL,CAAoB,IAAI,CAAC,SAAzB,EAAoC,OAApC,CAAtB;MAEA,MAAM,QAAQ,GAAG,CAAA,EAAA,GAAC,IAAD,MAA4C,IAA5C,IAA4C,EAAA,KAAA,KAAA,CAA5C,GAA4C,KAAA,CAA5C,GAA4C,EAAA,CAAE,WAA/D,C,CAEA;;MACA,MAAM,GAAG,GAA8B;QACrC,MAAM,EAAE,sBAAsB,CAAC,SADM;QAErC,gBAAgB,EAAE,OAFmB;QAGrC;MAHqC,CAAvC,C,CAMA;;MACA,SAAS,CAAC,WAAV,CAAsB,GAAtB,EAAkC,SAAS,CAAC,QAAV,CAAmB,MAArD;;EACD;;EAEY,uBAAuB,CAClC,eADkC,EAC4C;;MAE9E;MACA,MAAM,EAAE,GAAU,KAAP,IAAoC,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;;;QAC7C,IAAI,KAAK,CAAC,MAAN,KAAiB,SAAjB,IAA8B,KAAK,CAAC,MAAN,KAAiB,SAAS,CAAC,QAAV,CAAmB,MAAtE,EAA8E;UAC5E;UACA;QACD;;QAED,MAAM,IAAI,GAAG,CAAA,EAAA,GAAA,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,IAAP,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,OAA1B;;QAEA,IACE,IAAI,IACJ,IAAI,CAAC,MAAL,KAAgB,sBAAsB,CAAC,IADvC,KAEC,MAAM,KAAK,oBAAL,CAA0B,IAA1B,CAFP,CADF,EAIE;UACA,MAAM,OAAO,GAAG,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,OAAjB,EAA0B,KAA1B,CAAhB;;UAEA,IAAI,OAAO,CAAC,MAAR,IAAkB,2BAA2B,GAAG,yBAApD,EAA+E;YAC7E,IAAI;cACF,MAAM,eAAe,GAA+B,IAAI,CAAC,KAAL,CAClD,MAAM,aAAa,CAAC,OAAD,EAAU,KAAK,OAAL,CAAa,SAAvB,EAAkC,KAAK,OAAL,CAAa,UAA/C,CAD+B,CAApD;cAIA,eAAe,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACV,eADU,CAAA,EACK;gBAClB,QAAQ,EAAE,MAAM,WAAW,CAAC,eAAe,CAAC,SAAjB,CADT;gBAElB,WAAW,EAAE,CAAA,EAAA,GAAA,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,IAAP,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,MAAF,CAAS;cAFf,CADL,CAAA,CAAf;YAKD,CAVD,CAUE,OAAO,eAAP,EAAwB;cACxB;YACD;UACF;QACF;MACF,CA/B8C,CAA/C;;MAiCA,SAAS,CAAC,gBAAV,CAA2B,SAA3B,EAAsC,EAAtC;IACD,C;EAAA;;EAEY,kBAAkB,CAAC,EAAD,EAAW;;MACxC,MAAM,OAAO,GAA6B;QACxC,MAAM,EAAE,sBAAsB,CAAC,SADS;QAExC,OAAO,EAAE,MAAM,IAAI,UAAJ,GAAiB,SAAjB,CAA2B,MAAM,KAAK,qBAAL,EAAjC,CAFyB;QAGxC,QAAQ,EAAE;MAH8B,CAA1C,C,CAKA;;MACA,SAAS,CAAC,WAAV,CAAsB,OAAtB,EAAsC,SAAS,CAAC,QAAV,CAAmB,MAAzD;IACD,C;EAAA;;EAEY,oBAAoB,CAAC,OAAD,EAAa;;MAC5C,OAAO,OAAO,OAAP,KAAmB,QAAnB,IAA+B,OAAO,CAAC,cAAR,CAAuB,SAAvB,CAAtC;IACD,C;EAAA;;EAEa,mBAAmB,GAAA;;MAC/B,SAAS,CAAC,gBAAV,CAA2B,SAA3B,EAAuC,OAAD,IAAY;QAChD,IACG,OAAe,CAAC,MAAhB,KAA2B,SAA3B,IACA,OAAe,CAAC,MAAhB,KAA2B,SAAS,CAAC,QAAV,CAAmB,MAFjD,EAGE;UACA;UACA;QACD;;QAED,IAAI,OAAO,OAAP,KAAmB,QAAnB,IAA+B,OAAnC,EAA4C;UAC1C;UACA,MAAM,IAAI,GAGL,OAAe,CAAC,IAHrB;;UAIA,IAAI,IAAI,CAAC,OAAL,IAAgB,IAAI,CAAC,OAAL,CAAa,MAAb,KAAwB,sBAAsB,CAAC,IAAnE,EAAyE;YACvE,KAAK,eAAL,CAAqB,OAArB,CAA8B,QAAD,IAAa;cACxC,QAAQ,CAAC,IAAI,CAAC,OAAN,EAAe;gBACrB,MAAM,EAAE,MAAM,CAAC,SADM;gBAErB,EAAE,EAAE,IAAI,CAAC,MAAL,CAAY,EAAZ,IAAkB;cAFD,CAAf,CAAR;YAID,CALD;UAMD;QACF;MACF,CAxBD;IAyBD,C;EAAA;;AAzIsD","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport { windowRef, Serializer, getSenderId, MessageBasedClient } from '@airgap/beacon-core';\nimport { openCryptobox } from '@airgap/beacon-utils';\nimport { ExtensionMessageTarget, Origin } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n *\n */\nexport class PostMessageClient extends MessageBasedClient {\n    constructor() {\n        super(...arguments);\n        this.activeListeners = new Map();\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.subscribeToMessages().catch(console.error);\n        });\n    }\n    listenForEncryptedMessage(senderPublicKey, messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.activeListeners.has(senderPublicKey)) {\n                return;\n            }\n            const callbackFunction = (message, context) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const decryptedMessage = yield this.decryptMessage(senderPublicKey, message.encryptedPayload);\n                    // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n                    // TODO: Add check for correct decryption key / sender ID\n                    messageCallback(decryptedMessage, context);\n                }\n                catch (decryptionError) {\n                    /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                }\n            });\n            this.activeListeners.set(senderPublicKey, callbackFunction);\n        });\n    }\n    sendMessage(message, peer) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const payload = yield this.encryptMessage(peer.publicKey, message);\n            const targetId = (_a = peer) === null || _a === void 0 ? void 0 : _a.extensionId;\n            // if no targetId, we remove peer\n            const msg = {\n                target: ExtensionMessageTarget.EXTENSION,\n                encryptedPayload: payload,\n                targetId\n            };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            windowRef.postMessage(msg, windowRef.location.origin);\n        });\n    }\n    listenForChannelOpening(messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const fn = (event) => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                if (event.source !== windowRef || event.origin !== windowRef.location.origin) {\n                    // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')\n                    return;\n                }\n                const data = (_a = event === null || event === void 0 ? void 0 : event.data) === null || _a === void 0 ? void 0 : _a.message;\n                if (data &&\n                    data.target === ExtensionMessageTarget.PAGE &&\n                    (yield this.isChannelOpenMessage(data))) {\n                    const payload = Buffer.from(data.payload, 'hex');\n                    if (payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n                        try {\n                            const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n                            messageCallback(Object.assign(Object.assign({}, pairingResponse), { senderId: yield getSenderId(pairingResponse.publicKey), extensionId: (_b = event === null || event === void 0 ? void 0 : event.data) === null || _b === void 0 ? void 0 : _b.sender.id }));\n                        }\n                        catch (decryptionError) {\n                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                        }\n                    }\n                }\n            });\n            windowRef.addEventListener('message', fn);\n        });\n    }\n    sendPairingRequest(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const message = {\n                target: ExtensionMessageTarget.EXTENSION,\n                payload: yield new Serializer().serialize(yield this.getPairingRequestInfo()),\n                targetId: id\n            };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            windowRef.postMessage(message, windowRef.location.origin);\n        });\n    }\n    isChannelOpenMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return typeof message === 'object' && message.hasOwnProperty('payload');\n        });\n    }\n    subscribeToMessages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            windowRef.addEventListener('message', (message) => {\n                if (message.source !== windowRef ||\n                    message.origin !== windowRef.location.origin) {\n                    // TODO: Add to error handler: console.debug('[Beacon]: Event received from untrusted origin')\n                    return;\n                }\n                if (typeof message === 'object' && message) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const data = message.data;\n                    if (data.message && data.message.target === ExtensionMessageTarget.PAGE) {\n                        this.activeListeners.forEach((listener) => {\n                            listener(data.message, {\n                                origin: Origin.EXTENSION,\n                                id: data.sender.id || ''\n                            });\n                        });\n                    }\n                }\n            });\n        });\n    }\n}\n//# sourceMappingURL=PostMessageClient.js.map"]},"metadata":{},"sourceType":"module"}