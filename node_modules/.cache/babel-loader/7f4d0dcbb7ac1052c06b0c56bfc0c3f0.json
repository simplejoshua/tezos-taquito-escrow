{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\n\nvar int_1 = require(\"@stablelib/int\"); // TODO(dchest): add asserts for correct value ranges and array offsets.\n\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\n\n\nfunction readInt16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;\n}\n\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\n\nfunction readUint16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;\n}\n\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\n\nfunction readInt16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;\n}\n\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\n\nfunction readUint16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 1] << 8 | array[offset]) >>> 0;\n}\n\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint16BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 8;\n  out[offset + 1] = value >>> 0;\n  return out;\n}\n\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint16LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  return out;\n}\n\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\n\nfunction readInt32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];\n}\n\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\n\nfunction readUint32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;\n}\n\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\n\nfunction readInt32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];\n}\n\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\n\nfunction readUint32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;\n}\n\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 24;\n  out[offset + 1] = value >>> 16;\n  out[offset + 2] = value >>> 8;\n  out[offset + 3] = value >>> 0;\n  return out;\n}\n\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  out[offset + 2] = value >>> 16;\n  out[offset + 3] = value >>> 24;\n  return out;\n}\n\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\n\nfunction readInt64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var hi = readInt32BE(array, offset);\n  var lo = readInt32BE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\n\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\n\nfunction readUint64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var hi = readUint32BE(array, offset);\n  var lo = readUint32BE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\n\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\n\nfunction readInt64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var lo = readInt32LE(array, offset);\n  var hi = readInt32LE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\n\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\n\nfunction readUint64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var lo = readUint32LE(array, offset);\n  var hi = readUint32LE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\n\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n  writeUint32BE(value >>> 0, out, offset + 4);\n  return out;\n}\n\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  writeUint32LE(value >>> 0, out, offset);\n  writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n  return out;\n}\n\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\n\nfunction readUintBE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n  }\n\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintBE: array is too short for the given bitLength\");\n  }\n\n  var result = 0;\n  var mul = 1;\n\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n\n  return result;\n}\n\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\n\nfunction readUintLE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n  }\n\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintLE: array is too short for the given bitLength\");\n  }\n\n  var result = 0;\n  var mul = 1;\n\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n\n  return result;\n}\n\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUintBE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n  }\n\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintBE value must be an integer\");\n  }\n\n  var div = 1;\n\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n\n  return out;\n}\n\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUintLE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n  }\n\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintLE value must be an integer\");\n  }\n\n  var div = 1;\n\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n\n  return out;\n}\n\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\n\nfunction readFloat32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset);\n}\n\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\n\nfunction readFloat32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset, true);\n}\n\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\n\nfunction readFloat64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset);\n}\n\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\n\nfunction readFloat64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset, true);\n}\n\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value);\n  return out;\n}\n\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value, true);\n  return out;\n}\n\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value);\n  return out;\n}\n\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value, true);\n  return out;\n}\n\nexports.writeFloat64LE = writeFloat64LE;","map":{"version":3,"sources":["../binary.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\nvar int_1 = require(\"@stablelib/int\");\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;\n}\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;\n}\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;\n}\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 1] << 8) | array[offset]) >>> 0;\n}\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 8;\n    out[offset + 1] = value >>> 0;\n    return out;\n}\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    return out;\n}\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3];\n}\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3]) >>> 0;\n}\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset];\n}\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset]) >>> 0;\n}\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 24;\n    out[offset + 1] = value >>> 16;\n    out[offset + 2] = value >>> 8;\n    out[offset + 3] = value >>> 0;\n    return out;\n}\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    out[offset + 2] = value >>> 16;\n    out[offset + 3] = value >>> 24;\n    return out;\n}\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readInt32BE(array, offset);\n    var lo = readInt32BE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readUint32BE(array, offset);\n    var lo = readUint32BE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readInt32LE(array, offset);\n    var hi = readInt32LE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readUint32LE(array, offset);\n    var hi = readUint32LE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n    writeUint32BE(value >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32LE(value >>> 0, out, offset);\n    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintBE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintBE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintLE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintLE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintBE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintBE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintLE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintLE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset);\n}\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset, true);\n}\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset);\n}\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset, true);\n}\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value);\n    return out;\n}\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value, true);\n    return out;\n}\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value);\n    return out;\n}\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value, true);\n    return out;\n}\nexports.writeFloat64LE = writeFloat64LE;\n//# sourceMappingURL=binary.js.map"]},"metadata":{},"sourceType":"script"}