{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '@airgap/beacon-core';\nimport { ExposedPromise } from '@airgap/beacon-utils';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nconst logger = new Logger('MatrixClient');\nconst IMMEDIATE_POLLING_RETRIES = 3;\nconst RETRY_INTERVAL = 5000;\n/**\n * The matrix client used to connect to the matrix network\n */\n\nexport class MatrixClient {\n  constructor(store, eventEmitter, userService, roomService, eventService, httpClient) {\n    this.store = store;\n    this.eventEmitter = eventEmitter;\n    this.userService = userService;\n    this.roomService = roomService;\n    this.eventService = eventService;\n    this.httpClient = httpClient;\n    this.isActive = true;\n    this._isReady = new ExposedPromise();\n    this.store.onStateChanged((oldState, newState, stateChange) => {\n      this.eventEmitter.onStateChanged(oldState, newState, stateChange);\n    }, 'rooms');\n  }\n  /**\n   * Create a matrix client based on the options provided\n   *\n   * @param config\n   */\n\n\n  static create(config) {\n    const store = new MatrixClientStore(config.storage);\n    const eventEmitter = new MatrixClientEventEmitter();\n    const httpClient = new MatrixHttpClient(config.baseUrl);\n    const accountService = new MatrixUserService(httpClient);\n    const roomService = new MatrixRoomService(httpClient);\n    const eventService = new MatrixEventService(httpClient);\n    return new MatrixClient(store, eventEmitter, accountService, roomService, eventService, httpClient);\n  }\n  /**\n   * Return all the rooms we are currently part of\n   */\n\n\n  get joinedRooms() {\n    return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      resolve(Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.JOINED));\n    }));\n  }\n  /**\n   * Return all the rooms to which we have received invitations\n   */\n\n\n  get invitedRooms() {\n    return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      resolve(Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.INVITED));\n    }));\n  }\n  /**\n   * Return all the rooms that we left\n   */\n\n\n  get leftRooms() {\n    return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      resolve(Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.LEFT));\n    }));\n  }\n  /**\n   * Initiate the connection to the matrix node and log in\n   *\n   * @param user\n   */\n\n\n  start(user) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this.userService.login(user.id, user.password, user.deviceId);\n      yield this.store.update({\n        accessToken: response.access_token\n      });\n      const initialPollingResult = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        yield this.poll(0, pollingResponse => __awaiter(this, void 0, void 0, function* () {\n          if (!this.store.get('isRunning')) {\n            resolve();\n          }\n\n          yield this.store.update({\n            isRunning: true,\n            syncToken: pollingResponse.next_batch,\n            pollingTimeout: 30000,\n            pollingRetries: 0,\n            rooms: MatrixRoom.fromSync(pollingResponse.rooms)\n          });\n        }), error => __awaiter(this, void 0, void 0, function* () {\n          if (!this.store.get('isRunning')) {\n            reject(error);\n          }\n\n          yield this.store.update({\n            isRunning: false,\n            pollingRetries: this.store.get('pollingRetries') + 1\n          });\n        }));\n      }));\n      initialPollingResult.then(() => {\n        this._isReady.resolve();\n      }).catch(console.error);\n      return initialPollingResult;\n    });\n  }\n\n  isConnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._isReady.promise;\n    });\n  }\n  /**\n   * Stop all running requests\n   */\n\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`MATRIX CLIENT STOPPED`);\n      this.isActive = false;\n      this._isReady = new ExposedPromise();\n      return this.httpClient.cancelAllRequests();\n    });\n  }\n  /**\n   * Subscribe to new matrix events\n   *\n   * @param event\n   * @param listener\n   */\n\n\n  subscribe(event, listener) {\n    this.eventEmitter.on(event, listener);\n  }\n  /**\n   * Unsubscribe from matrix events\n   *\n   * @param event\n   * @param listener\n   */\n\n\n  unsubscribe(event, listener) {\n    if (listener) {\n      this.eventEmitter.removeListener(event, listener);\n    }\n  }\n  /**\n   * Unsubscribe from all matrix events of this type\n   *\n   * @param event\n   * @param listener\n   */\n\n\n  unsubscribeAll(event) {\n    this.eventEmitter.removeAllListeners(event);\n  }\n\n  getRoomById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      return this.store.getRoom(id);\n    });\n  }\n  /**\n   * Create a private room with the supplied members\n   *\n   * @param members Members that will be in the room\n   */\n\n\n  createTrustedPrivateRoom() {\n    for (var _len = arguments.length, members = new Array(_len), _key = 0; _key < _len; _key++) {\n      members[_key] = arguments[_key];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      return this.requiresAuthorization('createRoom', accessToken => __awaiter(this, void 0, void 0, function* () {\n        const response = yield this.roomService.createRoom(accessToken, {\n          room_version: '5',\n          invite: members,\n          preset: 'public_chat',\n          is_direct: true\n        });\n        return response.room_id;\n      }));\n    });\n  }\n  /**\n   * Invite user to rooms\n   *\n   * @param user The user to be invited\n   * @param roomsOrIds The rooms the user will be invited to\n   */\n\n\n  inviteToRooms(user) {\n    for (var _len2 = arguments.length, roomsOrIds = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      roomsOrIds[_key2 - 1] = arguments[_key2];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      yield this.requiresAuthorization('invite', accessToken => Promise.all(roomsOrIds.map(roomOrId => {\n        const room = this.store.getRoom(roomOrId);\n        this.roomService.inviteToRoom(accessToken, user, room).catch(error => logger.warn('inviteToRooms', error));\n      })));\n    });\n  }\n  /**\n   * Join rooms\n   *\n   * @param roomsOrIds\n   */\n\n\n  joinRooms() {\n    for (var _len3 = arguments.length, roomsOrIds = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      roomsOrIds[_key3] = arguments[_key3];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      yield this.requiresAuthorization('join', accessToken => Promise.all(roomsOrIds.map(roomOrId => {\n        const room = this.store.getRoom(roomOrId);\n        return this.roomService.joinRoom(accessToken, room);\n      })));\n    });\n  }\n  /**\n   * Send a text message\n   *\n   * @param roomOrId\n   * @param message\n   */\n\n\n  sendTextMessage(roomId, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.isConnected();\n      yield this.requiresAuthorization('send', accessToken => __awaiter(this, void 0, void 0, function* () {\n        const txnId = yield this.createTxnId();\n        return this.eventService.sendMessage(accessToken, roomId, {\n          msgtype: 'm.text',\n          body: message\n        }, txnId);\n      }));\n    });\n  }\n  /**\n   * Poll the server to get the latest data and get notified of changes\n   *\n   * @param interval\n   * @param onSyncSuccess\n   * @param onSyncError\n   */\n\n\n  poll(interval, onSyncSuccess, onSyncError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const store = this.store;\n      const sync = this.sync.bind(this);\n\n      const pollSync = (resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        let syncingRetries = 0;\n\n        try {\n          const response = yield sync();\n          onSyncSuccess(response);\n        } catch (error) {\n          onSyncError(error);\n          syncingRetries = store.get('pollingRetries'); // console.warn('Could not sync:', error)\n\n          if (this.isActive) {\n            logger.log(`Retry syncing... ${syncingRetries} retries so far`);\n          }\n        } finally {\n          if (this.isActive) {\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n              yield pollSync(resolve, reject);\n            }), syncingRetries > IMMEDIATE_POLLING_RETRIES ? RETRY_INTERVAL + interval : interval);\n          } else {\n            reject(new Error(`Syncing stopped manually.`));\n          }\n        }\n      });\n\n      return new Promise(pollSync);\n    });\n  }\n  /**\n   * Get state from server\n   */\n\n\n  sync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.requiresAuthorization('sync', accessToken => __awaiter(this, void 0, void 0, function* () {\n        return this.eventService.sync(accessToken, {\n          pollingTimeout: this.store.get('pollingTimeout'),\n          syncToken: this.store.get('syncToken')\n        });\n      }));\n    });\n  }\n  /**\n   * A helper method that makes sure an access token is provided\n   *\n   * @param name\n   * @param action\n   */\n\n\n  requiresAuthorization(name, action) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const storedToken = this.store.get('accessToken');\n\n      if (!storedToken) {\n        return Promise.reject(`${name} requires authorization but no access token has been provided.`);\n      }\n\n      return action(storedToken);\n    });\n  }\n  /**\n   * Create a transaction ID\n   */\n\n\n  createTxnId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const timestamp = new Date().getTime();\n      const counter = this.store.get('txnNo');\n      yield this.store.update({\n        txnNo: counter + 1\n      });\n      return `m${timestamp}.${counter}`;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/matrix-client/MatrixClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from '@airgap/beacon-core';\nimport { ExposedPromise } from '@airgap/beacon-utils';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nconst logger = new Logger('MatrixClient');\nconst IMMEDIATE_POLLING_RETRIES = 3;\nconst RETRY_INTERVAL = 5000;\n/**\n * The matrix client used to connect to the matrix network\n */\nexport class MatrixClient {\n    constructor(store, eventEmitter, userService, roomService, eventService, httpClient) {\n        this.store = store;\n        this.eventEmitter = eventEmitter;\n        this.userService = userService;\n        this.roomService = roomService;\n        this.eventService = eventService;\n        this.httpClient = httpClient;\n        this.isActive = true;\n        this._isReady = new ExposedPromise();\n        this.store.onStateChanged((oldState, newState, stateChange) => {\n            this.eventEmitter.onStateChanged(oldState, newState, stateChange);\n        }, 'rooms');\n    }\n    /**\n     * Create a matrix client based on the options provided\n     *\n     * @param config\n     */\n    static create(config) {\n        const store = new MatrixClientStore(config.storage);\n        const eventEmitter = new MatrixClientEventEmitter();\n        const httpClient = new MatrixHttpClient(config.baseUrl);\n        const accountService = new MatrixUserService(httpClient);\n        const roomService = new MatrixRoomService(httpClient);\n        const eventService = new MatrixEventService(httpClient);\n        return new MatrixClient(store, eventEmitter, accountService, roomService, eventService, httpClient);\n    }\n    /**\n     * Return all the rooms we are currently part of\n     */\n    get joinedRooms() {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            resolve(Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.JOINED));\n        }));\n    }\n    /**\n     * Return all the rooms to which we have received invitations\n     */\n    get invitedRooms() {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            resolve(Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.INVITED));\n        }));\n    }\n    /**\n     * Return all the rooms that we left\n     */\n    get leftRooms() {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            resolve(Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.LEFT));\n        }));\n    }\n    /**\n     * Initiate the connection to the matrix node and log in\n     *\n     * @param user\n     */\n    start(user) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.userService.login(user.id, user.password, user.deviceId);\n            yield this.store.update({\n                accessToken: response.access_token\n            });\n            const initialPollingResult = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                yield this.poll(0, (pollingResponse) => __awaiter(this, void 0, void 0, function* () {\n                    if (!this.store.get('isRunning')) {\n                        resolve();\n                    }\n                    yield this.store.update({\n                        isRunning: true,\n                        syncToken: pollingResponse.next_batch,\n                        pollingTimeout: 30000,\n                        pollingRetries: 0,\n                        rooms: MatrixRoom.fromSync(pollingResponse.rooms)\n                    });\n                }), (error) => __awaiter(this, void 0, void 0, function* () {\n                    if (!this.store.get('isRunning')) {\n                        reject(error);\n                    }\n                    yield this.store.update({\n                        isRunning: false,\n                        pollingRetries: this.store.get('pollingRetries') + 1\n                    });\n                }));\n            }));\n            initialPollingResult\n                .then(() => {\n                this._isReady.resolve();\n            })\n                .catch(console.error);\n            return initialPollingResult;\n        });\n    }\n    isConnected() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._isReady.promise;\n        });\n    }\n    /**\n     * Stop all running requests\n     */\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log(`MATRIX CLIENT STOPPED`);\n            this.isActive = false;\n            this._isReady = new ExposedPromise();\n            return this.httpClient.cancelAllRequests();\n        });\n    }\n    /**\n     * Subscribe to new matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    subscribe(event, listener) {\n        this.eventEmitter.on(event, listener);\n    }\n    /**\n     * Unsubscribe from matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribe(event, listener) {\n        if (listener) {\n            this.eventEmitter.removeListener(event, listener);\n        }\n    }\n    /**\n     * Unsubscribe from all matrix events of this type\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribeAll(event) {\n        this.eventEmitter.removeAllListeners(event);\n    }\n    getRoomById(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            return this.store.getRoom(id);\n        });\n    }\n    /**\n     * Create a private room with the supplied members\n     *\n     * @param members Members that will be in the room\n     */\n    createTrustedPrivateRoom(...members) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            return this.requiresAuthorization('createRoom', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                const response = yield this.roomService.createRoom(accessToken, {\n                    room_version: '5',\n                    invite: members,\n                    preset: 'public_chat',\n                    is_direct: true\n                });\n                return response.room_id;\n            }));\n        });\n    }\n    /**\n     * Invite user to rooms\n     *\n     * @param user The user to be invited\n     * @param roomsOrIds The rooms the user will be invited to\n     */\n    inviteToRooms(user, ...roomsOrIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            yield this.requiresAuthorization('invite', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {\n                const room = this.store.getRoom(roomOrId);\n                this.roomService\n                    .inviteToRoom(accessToken, user, room)\n                    .catch((error) => logger.warn('inviteToRooms', error));\n            })));\n        });\n    }\n    /**\n     * Join rooms\n     *\n     * @param roomsOrIds\n     */\n    joinRooms(...roomsOrIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            yield this.requiresAuthorization('join', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {\n                const room = this.store.getRoom(roomOrId);\n                return this.roomService.joinRoom(accessToken, room);\n            })));\n        });\n    }\n    /**\n     * Send a text message\n     *\n     * @param roomOrId\n     * @param message\n     */\n    sendTextMessage(roomId, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.isConnected();\n            yield this.requiresAuthorization('send', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                const txnId = yield this.createTxnId();\n                return this.eventService.sendMessage(accessToken, roomId, {\n                    msgtype: 'm.text',\n                    body: message\n                }, txnId);\n            }));\n        });\n    }\n    /**\n     * Poll the server to get the latest data and get notified of changes\n     *\n     * @param interval\n     * @param onSyncSuccess\n     * @param onSyncError\n     */\n    poll(interval, onSyncSuccess, onSyncError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const store = this.store;\n            const sync = this.sync.bind(this);\n            const pollSync = (resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let syncingRetries = 0;\n                try {\n                    const response = yield sync();\n                    onSyncSuccess(response);\n                }\n                catch (error) {\n                    onSyncError(error);\n                    syncingRetries = store.get('pollingRetries');\n                    // console.warn('Could not sync:', error)\n                    if (this.isActive) {\n                        logger.log(`Retry syncing... ${syncingRetries} retries so far`);\n                    }\n                }\n                finally {\n                    if (this.isActive) {\n                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                            yield pollSync(resolve, reject);\n                        }), syncingRetries > IMMEDIATE_POLLING_RETRIES ? RETRY_INTERVAL + interval : interval);\n                    }\n                    else {\n                        reject(new Error(`Syncing stopped manually.`));\n                    }\n                }\n            });\n            return new Promise(pollSync);\n        });\n    }\n    /**\n     * Get state from server\n     */\n    sync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.requiresAuthorization('sync', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                return this.eventService.sync(accessToken, {\n                    pollingTimeout: this.store.get('pollingTimeout'),\n                    syncToken: this.store.get('syncToken')\n                });\n            }));\n        });\n    }\n    /**\n     * A helper method that makes sure an access token is provided\n     *\n     * @param name\n     * @param action\n     */\n    requiresAuthorization(name, action) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const storedToken = this.store.get('accessToken');\n            if (!storedToken) {\n                return Promise.reject(`${name} requires authorization but no access token has been provided.`);\n            }\n            return action(storedToken);\n        });\n    }\n    /**\n     * Create a transaction ID\n     */\n    createTxnId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const timestamp = new Date().getTime();\n            const counter = this.store.get('txnNo');\n            yield this.store.update({\n                txnNo: counter + 1\n            });\n            return `m${timestamp}.${counter}`;\n        });\n    }\n}\n//# sourceMappingURL=MatrixClient.js.map"]},"metadata":{},"sourceType":"module"}