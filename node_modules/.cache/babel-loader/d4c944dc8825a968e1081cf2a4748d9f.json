{"ast":null,"code":"import { EventEmitter } from 'events';\nimport { keys } from '@airgap/beacon-utils';\nimport { MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixClientEventType } from './models/MatrixClientEvent';\nexport class MatrixClientEventEmitter extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.eventEmitProviders = new Map([[MatrixClientEventType.INVITE, () => [this.isInvite, this.emitInvite.bind(this)]], [MatrixClientEventType.MESSAGE, () => [this.isMessage, this.emitMessage.bind(this)]]]);\n  }\n  /**\n   * This method is called every time the state is changed\n   *\n   * @param _oldState\n   * @param _newState\n   * @param stateChange\n   */\n\n\n  onStateChanged(_oldState, _newState, stateChange) {\n    for (const event of keys(MatrixClientEventType)) {\n      this.emitIfEvent(MatrixClientEventType[event], stateChange);\n    }\n  }\n  /**\n   * Emit the message if we have listeners registered for that type\n   *\n   * @param eventType\n   * @param object\n   */\n\n\n  emitIfEvent(eventType, object) {\n    const provider = this.eventEmitProviders.get(eventType);\n\n    if (provider) {\n      const [predicate, emitter] = provider();\n\n      if (predicate(object)) {\n        emitter(eventType, object);\n      }\n    }\n  }\n  /**\n   * Emit a client event\n   *\n   * @param eventType\n   * @param content\n   */\n\n\n  emitClientEvent(eventType, content, timestamp) {\n    this.emit(eventType, {\n      type: eventType,\n      content,\n      timestamp\n    });\n  }\n  /**\n   * Check if event is an invite\n   *\n   * @param stateChange\n   */\n\n\n  isInvite(stateChange) {\n    return stateChange.rooms ? stateChange.rooms.some(room => room.status === MatrixRoomStatus.INVITED) : false;\n  }\n  /**\n   * Emit an invite\n   *\n   * @param eventType\n   * @param stateChange\n   */\n\n\n  emitInvite(eventType, stateChange) {\n    stateChange.rooms.filter(room => room.status === MatrixRoomStatus.INVITED).map(room => [room.id, room.members]).forEach(_ref => {\n      let [id, members] = _ref;\n      this.emitClientEvent(eventType, {\n        roomId: id,\n        members: members\n      });\n    });\n  }\n  /**\n   * Check if event is a message\n   *\n   * @param stateChange\n   */\n\n\n  isMessage(stateChange) {\n    return stateChange.rooms ? stateChange.rooms.some(room => room.messages.length > 0) : false;\n  }\n  /**\n   * Emit an event to all rooms\n   *\n   * @param eventType\n   * @param stateChange\n   */\n\n\n  emitMessage(eventType, stateChange) {\n    stateChange.rooms.filter(room => room.messages.length > 0).map(room => room.messages.map(message => [room.id, message, message.timestamp])).reduce((flatten, toFlatten) => flatten.concat(toFlatten), []).forEach(_ref2 => {\n      let [roomId, message, timestamp] = _ref2;\n      this.emitClientEvent(eventType, {\n        roomId,\n        message\n      }, timestamp);\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/matrix-client/MatrixClientEventEmitter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from 'events';\nimport { keys } from '@airgap/beacon-utils';\nimport { MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixClientEventType } from './models/MatrixClientEvent';\nexport class MatrixClientEventEmitter extends EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.eventEmitProviders = new Map([\n            [MatrixClientEventType.INVITE, () => [this.isInvite, this.emitInvite.bind(this)]],\n            [MatrixClientEventType.MESSAGE, () => [this.isMessage, this.emitMessage.bind(this)]]\n        ]);\n    }\n    /**\n     * This method is called every time the state is changed\n     *\n     * @param _oldState\n     * @param _newState\n     * @param stateChange\n     */\n    onStateChanged(_oldState, _newState, stateChange) {\n        for (const event of keys(MatrixClientEventType)) {\n            this.emitIfEvent(MatrixClientEventType[event], stateChange);\n        }\n    }\n    /**\n     * Emit the message if we have listeners registered for that type\n     *\n     * @param eventType\n     * @param object\n     */\n    emitIfEvent(eventType, object) {\n        const provider = this.eventEmitProviders.get(eventType);\n        if (provider) {\n            const [predicate, emitter] = provider();\n            if (predicate(object)) {\n                emitter(eventType, object);\n            }\n        }\n    }\n    /**\n     * Emit a client event\n     *\n     * @param eventType\n     * @param content\n     */\n    emitClientEvent(eventType, content, timestamp) {\n        this.emit(eventType, {\n            type: eventType,\n            content,\n            timestamp\n        });\n    }\n    /**\n     * Check if event is an invite\n     *\n     * @param stateChange\n     */\n    isInvite(stateChange) {\n        return stateChange.rooms\n            ? stateChange.rooms.some((room) => room.status === MatrixRoomStatus.INVITED)\n            : false;\n    }\n    /**\n     * Emit an invite\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    emitInvite(eventType, stateChange) {\n        stateChange.rooms\n            .filter((room) => room.status === MatrixRoomStatus.INVITED)\n            .map((room) => [room.id, room.members])\n            .forEach(([id, members]) => {\n            this.emitClientEvent(eventType, {\n                roomId: id,\n                members: members\n            });\n        });\n    }\n    /**\n     * Check if event is a message\n     *\n     * @param stateChange\n     */\n    isMessage(stateChange) {\n        return stateChange.rooms ? stateChange.rooms.some((room) => room.messages.length > 0) : false;\n    }\n    /**\n     * Emit an event to all rooms\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    emitMessage(eventType, stateChange) {\n        stateChange.rooms\n            .filter((room) => room.messages.length > 0)\n            .map((room) => room.messages.map((message) => [room.id, message, message.timestamp]))\n            .reduce((flatten, toFlatten) => flatten.concat(toFlatten), [])\n            .forEach(([roomId, message, timestamp]) => {\n            this.emitClientEvent(eventType, {\n                roomId,\n                message\n            }, timestamp);\n        });\n    }\n}\n//# sourceMappingURL=MatrixClientEventEmitter.js.map"]},"metadata":{},"sourceType":"module"}