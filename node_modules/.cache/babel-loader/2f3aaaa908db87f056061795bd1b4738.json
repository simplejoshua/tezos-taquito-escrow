{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as bs58check from 'bs58check';\nimport { ready, crypto_generichash, crypto_sign_seed_keypair, from_string, randombytes_buf, crypto_secretbox_NONCEBYTES, crypto_secretbox_easy, crypto_secretbox_open_easy, crypto_sign_ed25519_pk_to_curve25519, crypto_sign_ed25519_sk_to_curve25519, crypto_box_seal, crypto_box_seal_open } from 'libsodium-wrappers';\n/* eslint-disable prefer-arrow/prefer-arrow-functions */\n\n/**\n * Convert a value to hex\n *\n * @param value\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function toHex(value) {\n  return Buffer.from(value).toString('hex');\n}\n/**\n * Get the hex hash of a value\n *\n * @param key\n */\n\nexport function getHexHash(key) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ready;\n    return toHex(crypto_generichash(32, key));\n  });\n}\n/**\n * Get a keypair from a seed\n *\n * @param seed\n */\n\nexport function getKeypairFromSeed(seed) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ready;\n    return crypto_sign_seed_keypair(crypto_generichash(32, from_string(seed)));\n  });\n}\n/**\n * Encrypt a message with a shared key\n *\n * @param message\n * @param sharedKey\n */\n\nexport function encryptCryptoboxPayload(message, sharedKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ready;\n    const nonce = Buffer.from(randombytes_buf(crypto_secretbox_NONCEBYTES));\n    const combinedPayload = Buffer.concat([nonce, Buffer.from(crypto_secretbox_easy(Buffer.from(message, 'utf8'), nonce, sharedKey))]);\n    return toHex(combinedPayload);\n  });\n}\n/**\n * Decrypt a message with a shared key\n *\n * @param payload\n * @param sharedKey\n */\n\nexport function decryptCryptoboxPayload(payload, sharedKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ready;\n    const nonce = payload.slice(0, crypto_secretbox_NONCEBYTES);\n    const ciphertext = payload.slice(crypto_secretbox_NONCEBYTES);\n    return Buffer.from(crypto_secretbox_open_easy(ciphertext, nonce, sharedKey)).toString('utf8');\n  });\n}\n/**\n * Encrypt a message with a public key\n *\n * @param payload\n * @param publicKey\n */\n\nexport function sealCryptobox(payload, publicKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ready;\n    const kxSelfPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n\n    const encryptedMessage = crypto_box_seal(payload, kxSelfPublicKey);\n    return toHex(encryptedMessage);\n  });\n}\n/**\n * Decrypt a message with public + private key\n *\n * @param encryptedPayload\n * @param publicKey\n * @param privateKey\n */\n\nexport function openCryptobox(encryptedPayload, publicKey, privateKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ready;\n    const kxSelfPrivateKey = crypto_sign_ed25519_sk_to_curve25519(Buffer.from(privateKey)); // Secret bytes to scalar bytes\n\n    const kxSelfPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n\n    const decryptedMessage = crypto_box_seal_open(encryptedPayload, kxSelfPublicKey, kxSelfPrivateKey);\n    return Buffer.from(decryptedMessage).toString();\n  });\n}\n/**\n * Get an address from the public key\n *\n * @param publicKey\n */\n\nexport function getAddressFromPublicKey(publicKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ready;\n    const prefixes = {\n      // tz1...\n      edpk: {\n        length: 54,\n        prefix: Buffer.from(new Uint8Array([6, 161, 159]))\n      },\n      // tz2...\n      sppk: {\n        length: 55,\n        prefix: Buffer.from(new Uint8Array([6, 161, 161]))\n      },\n      // tz3...\n      p2pk: {\n        length: 55,\n        prefix: Buffer.from(new Uint8Array([6, 161, 164]))\n      }\n    };\n    let prefix;\n    let plainPublicKey;\n\n    if (publicKey.length === 64) {\n      prefix = prefixes.edpk.prefix;\n      plainPublicKey = publicKey;\n    } else {\n      const entries = Object.entries(prefixes);\n\n      for (let index = 0; index < entries.length; index++) {\n        const [key, value] = entries[index];\n\n        if (publicKey.startsWith(key) && publicKey.length === value.length) {\n          prefix = value.prefix;\n          const decoded = bs58check.decode(publicKey);\n          plainPublicKey = decoded.slice(key.length, decoded.length).toString('hex');\n          break;\n        }\n      }\n    }\n\n    if (!prefix || !plainPublicKey) {\n      throw new Error(`invalid publicKey: ${publicKey}`);\n    }\n\n    const payload = crypto_generichash(20, Buffer.from(plainPublicKey, 'hex'));\n    return bs58check.encode(Buffer.concat([prefix, Buffer.from(payload)]));\n  });\n}\n/**\n * Get the recipient string used in the matrix message\n *\n * @param recipientHash\n * @param relayServer\n */\n\nexport function recipientString(recipientHash, relayServer) {\n  return `@${recipientHash}:${relayServer}`;\n}\n/* eslint-enable prefer-arrow/prefer-arrow-functions */","map":{"version":3,"sources":["../../../src/utils/crypto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as bs58check from 'bs58check';\nimport { ready, crypto_generichash, crypto_sign_seed_keypair, from_string, randombytes_buf, crypto_secretbox_NONCEBYTES, crypto_secretbox_easy, crypto_secretbox_open_easy, crypto_sign_ed25519_pk_to_curve25519, crypto_sign_ed25519_sk_to_curve25519, crypto_box_seal, crypto_box_seal_open } from 'libsodium-wrappers';\n/* eslint-disable prefer-arrow/prefer-arrow-functions */\n/**\n * Convert a value to hex\n *\n * @param value\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function toHex(value) {\n    return Buffer.from(value).toString('hex');\n}\n/**\n * Get the hex hash of a value\n *\n * @param key\n */\nexport function getHexHash(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ready;\n        return toHex(crypto_generichash(32, key));\n    });\n}\n/**\n * Get a keypair from a seed\n *\n * @param seed\n */\nexport function getKeypairFromSeed(seed) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ready;\n        return crypto_sign_seed_keypair(crypto_generichash(32, from_string(seed)));\n    });\n}\n/**\n * Encrypt a message with a shared key\n *\n * @param message\n * @param sharedKey\n */\nexport function encryptCryptoboxPayload(message, sharedKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ready;\n        const nonce = Buffer.from(randombytes_buf(crypto_secretbox_NONCEBYTES));\n        const combinedPayload = Buffer.concat([\n            nonce,\n            Buffer.from(crypto_secretbox_easy(Buffer.from(message, 'utf8'), nonce, sharedKey))\n        ]);\n        return toHex(combinedPayload);\n    });\n}\n/**\n * Decrypt a message with a shared key\n *\n * @param payload\n * @param sharedKey\n */\nexport function decryptCryptoboxPayload(payload, sharedKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ready;\n        const nonce = payload.slice(0, crypto_secretbox_NONCEBYTES);\n        const ciphertext = payload.slice(crypto_secretbox_NONCEBYTES);\n        return Buffer.from(crypto_secretbox_open_easy(ciphertext, nonce, sharedKey)).toString('utf8');\n    });\n}\n/**\n * Encrypt a message with a public key\n *\n * @param payload\n * @param publicKey\n */\nexport function sealCryptobox(payload, publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ready;\n        const kxSelfPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n        const encryptedMessage = crypto_box_seal(payload, kxSelfPublicKey);\n        return toHex(encryptedMessage);\n    });\n}\n/**\n * Decrypt a message with public + private key\n *\n * @param encryptedPayload\n * @param publicKey\n * @param privateKey\n */\nexport function openCryptobox(encryptedPayload, publicKey, privateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ready;\n        const kxSelfPrivateKey = crypto_sign_ed25519_sk_to_curve25519(Buffer.from(privateKey)); // Secret bytes to scalar bytes\n        const kxSelfPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n        const decryptedMessage = crypto_box_seal_open(encryptedPayload, kxSelfPublicKey, kxSelfPrivateKey);\n        return Buffer.from(decryptedMessage).toString();\n    });\n}\n/**\n * Get an address from the public key\n *\n * @param publicKey\n */\nexport function getAddressFromPublicKey(publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ready;\n        const prefixes = {\n            // tz1...\n            edpk: {\n                length: 54,\n                prefix: Buffer.from(new Uint8Array([6, 161, 159]))\n            },\n            // tz2...\n            sppk: {\n                length: 55,\n                prefix: Buffer.from(new Uint8Array([6, 161, 161]))\n            },\n            // tz3...\n            p2pk: {\n                length: 55,\n                prefix: Buffer.from(new Uint8Array([6, 161, 164]))\n            }\n        };\n        let prefix;\n        let plainPublicKey;\n        if (publicKey.length === 64) {\n            prefix = prefixes.edpk.prefix;\n            plainPublicKey = publicKey;\n        }\n        else {\n            const entries = Object.entries(prefixes);\n            for (let index = 0; index < entries.length; index++) {\n                const [key, value] = entries[index];\n                if (publicKey.startsWith(key) && publicKey.length === value.length) {\n                    prefix = value.prefix;\n                    const decoded = bs58check.decode(publicKey);\n                    plainPublicKey = decoded.slice(key.length, decoded.length).toString('hex');\n                    break;\n                }\n            }\n        }\n        if (!prefix || !plainPublicKey) {\n            throw new Error(`invalid publicKey: ${publicKey}`);\n        }\n        const payload = crypto_generichash(20, Buffer.from(plainPublicKey, 'hex'));\n        return bs58check.encode(Buffer.concat([prefix, Buffer.from(payload)]));\n    });\n}\n/**\n * Get the recipient string used in the matrix message\n *\n * @param recipientHash\n * @param relayServer\n */\nexport function recipientString(recipientHash, relayServer) {\n    return `@${recipientHash}:${relayServer}`;\n}\n/* eslint-enable prefer-arrow/prefer-arrow-functions */\n//# sourceMappingURL=crypto.js.map"]},"metadata":{},"sourceType":"module"}