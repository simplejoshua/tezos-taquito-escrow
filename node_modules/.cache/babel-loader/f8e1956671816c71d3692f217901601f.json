{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar utils = require('@motionone/utils');\n\nvar inset = require('./inset.cjs.js');\n\nvar presets = require('./presets.cjs.js');\n\nvar offset = require('./offset.cjs.js');\n\nconst point = {\n  x: 0,\n  y: 0\n};\n\nfunction resolveOffsets(container, info, options) {\n  let {\n    offset: offsetDefinition = presets.ScrollOffset.All\n  } = options;\n  const {\n    target = container,\n    axis = \"y\"\n  } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset$1 = target !== container ? inset.calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n\n  const targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n\n  for (let i = 0; i < numOffsets; i++) {\n    const offset$1 = offset.resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset$1[axis]);\n\n    if (!hasChanged && offset$1 !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n\n    info[axis].offset[i] = offset$1;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n\n\n  if (hasChanged) {\n    info[axis].interpolate = utils.interpolate(utils.defaultOffset(numOffsets), info[axis].offset);\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexports.resolveOffsets = resolveOffsets;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils","require","inset","presets","offset","point","x","y","resolveOffsets","container","info","options","offsetDefinition","ScrollOffset","All","target","axis","lengthLabel","inset$1","calcInset","targetSize","width","scrollWidth","height","scrollHeight","clientWidth","clientHeight","containerSize","length","hasChanged","interpolate","numOffsets","i","offset$1","resolveOffset","interpolatorOffsets","defaultOffset","progress","current"],"sources":["C:/Users/Joshua Doros/node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('@motionone/utils');\nvar inset = require('./inset.cjs.js');\nvar presets = require('./presets.cjs.js');\nvar offset = require('./offset.cjs.js');\n\nconst point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = presets.ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset$1 = target !== container ? inset.calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : { width: target.clientWidth, height: target.clientHeight };\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset$1 = offset.resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset$1[axis]);\n        if (!hasChanged && offset$1 !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset$1;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = utils.interpolate(utils.defaultOffset(numOffsets), info[axis].offset);\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexports.resolveOffsets = resolveOffsets;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}