{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ready, crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport { BEACON_VERSION } from '../../constants';\nimport { decryptCryptoboxPayload, encryptCryptoboxPayload, generateGUID } from '@airgap/beacon-utils';\nimport { CommunicationClient } from './CommunicationClient';\n/**\n * @internalapi\n *\n *\n */\n\nexport class MessageBasedClient extends CommunicationClient {\n  constructor(name, keyPair) {\n    super(keyPair);\n    this.name = name;\n    this.init().catch(console.error);\n  }\n  /**\n   * start the client and make sure all dependencies are ready\n   */\n\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield ready;\n    });\n  }\n  /**\n   * Get the pairing request information. This will be shared with the peer during the connection setup\n   */\n\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: yield generateGUID(),\n        type: 'postmessage-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey()\n      };\n    });\n  }\n  /**\n   * Get the pairing response information. This will be shared with the peer during the connection setup\n   */\n\n\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: request.id,\n        type: 'postmessage-pairing-response',\n        name: this.name,\n        version: request.version,\n        publicKey: yield this.getPublicKey()\n      };\n    });\n  }\n  /**\n   * Unsubscribe from encrypted messages from a specific peer\n   *\n   * @param senderPublicKey\n   */\n\n\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n\n      if (!listener) {\n        return;\n      }\n\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n  /**\n   * Unsubscribe from all encrypted messages\n   */\n\n\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.activeListeners.clear();\n    });\n  }\n  /**\n   * Decrypt a message from a specific peer\n   *\n   * @param senderPublicKey\n   * @param payload\n   */\n\n\n  decryptMessage(senderPublicKey, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n      const hexPayload = Buffer.from(payload, 'hex');\n\n      if (hexPayload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n        try {\n          return yield decryptCryptoboxPayload(hexPayload, sharedRx);\n        } catch (decryptionError) {\n          /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n        }\n      }\n\n      throw new Error('Could not decrypt message');\n    });\n  }\n  /**\n   * Encrypt a message for a specific publicKey (receiver)\n   *\n   * @param recipientPublicKey\n   * @param message\n   */\n\n\n  encryptMessage(recipientPublicKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n      return encryptCryptoboxPayload(message, sharedTx);\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/transports/clients/MessageBasedClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SACE,KADF,EAGE,2BAHF,EAIE,yBAJF,QAKO,oBALP;AAMA,SAAS,cAAT,QAA+B,iBAA/B;AACA,SACE,uBADF,EAEE,uBAFF,EAGE,YAHF,QAIO,sBAJP;AAKA,SAAS,mBAAT,QAAoC,uBAApC;AAGA;;;;AAIG;;AACH,OAAM,MAAgB,kBAAhB,SAA2C,mBAA3C,CAA8D;EAMlE,WAAA,CAA+B,IAA/B,EAA6C,OAA7C,EAA6D;IAC3D,MAAM,OAAN;IAD6B,KAAA,IAAA,GAAA,IAAA;IAE7B,KAAK,IAAL,GAAY,KAAZ,CAAkB,OAAO,CAAC,KAA1B;EACD;EAED;;AAEG;;;EACU,KAAK,GAAA;;MAChB,MAAM,KAAN;IACD,C;EAAA;EAED;;AAEG;;;EACU,qBAAqB,GAAA;;MAChC,OAAO;QACL,EAAE,EAAE,MAAM,YAAY,EADjB;QAEL,IAAI,EAAE,6BAFD;QAGL,IAAI,EAAE,KAAK,IAHN;QAIL,OAAO,EAAE,cAJJ;QAKL,SAAS,EAAE,MAAM,KAAK,YAAL;MALZ,CAAP;IAOD,C;EAAA;EAED;;AAEG;;;EACU,sBAAsB,CACjC,OADiC,EACC;;MAElC,OAAO;QACL,EAAE,EAAE,OAAO,CAAC,EADP;QAEL,IAAI,EAAE,8BAFD;QAGL,IAAI,EAAE,KAAK,IAHN;QAIL,OAAO,EAAE,OAAO,CAAC,OAJZ;QAKL,SAAS,EAAE,MAAM,KAAK,YAAL;MALZ,CAAP;IAOD,C;EAAA;EAED;;;;AAIG;;;EACU,+BAA+B,CAAC,eAAD,EAAwB;;MAClE,MAAM,QAAQ,GAAG,KAAK,eAAL,CAAqB,GAArB,CAAyB,eAAzB,CAAjB;;MACA,IAAI,CAAC,QAAL,EAAe;QACb;MACD;;MAED,KAAK,eAAL,CAAqB,MAArB,CAA4B,eAA5B;IACD,C;EAAA;EAED;;AAEG;;;EACU,gCAAgC,GAAA;;MAC3C,KAAK,eAAL,CAAqB,KAArB;IACD,C;EAAA;EAED;;;;;AAKG;;;EACa,cAAc,CAAC,eAAD,EAA0B,OAA1B,EAAyC;;MACrE,MAAM;QAAE;MAAF,IAAe,MAAM,KAAK,qBAAL,CAA2B,eAA3B,EAA4C,KAAK,OAAL,CAAa,UAAzD,CAA3B;MAEA,MAAM,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,KAArB,CAAnB;;MAEA,IAAI,UAAU,CAAC,MAAX,IAAqB,2BAA2B,GAAG,yBAAvD,EAAkF;QAChF,IAAI;UACF,OAAO,MAAM,uBAAuB,CAAC,UAAD,EAAa,QAAb,CAApC;QACD,CAFD,CAEE,OAAO,eAAP,EAAwB;UACxB;QACD;MACF;;MAED,MAAM,IAAI,KAAJ,CAAU,2BAAV,CAAN;IACD,C;EAAA;EAED;;;;;AAKG;;;EACa,cAAc,CAAC,kBAAD,EAA6B,OAA7B,EAA4C;;MACxE,MAAM;QAAE;MAAF,IAAe,MAAM,KAAK,qBAAL,CACzB,kBADyB,EAEzB,KAAK,OAAL,CAAa,UAFY,CAA3B;MAKA,OAAO,uBAAuB,CAAC,OAAD,EAAU,QAAV,CAA9B;IACD,C;EAAA;;AAtGiE","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ready, crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport { BEACON_VERSION } from '../../constants';\nimport { decryptCryptoboxPayload, encryptCryptoboxPayload, generateGUID } from '@airgap/beacon-utils';\nimport { CommunicationClient } from './CommunicationClient';\n/**\n * @internalapi\n *\n *\n */\nexport class MessageBasedClient extends CommunicationClient {\n    constructor(name, keyPair) {\n        super(keyPair);\n        this.name = name;\n        this.init().catch(console.error);\n    }\n    /**\n     * start the client and make sure all dependencies are ready\n     */\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield ready;\n        });\n    }\n    /**\n     * Get the pairing request information. This will be shared with the peer during the connection setup\n     */\n    getPairingRequestInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                id: yield generateGUID(),\n                type: 'postmessage-pairing-request',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey()\n            };\n        });\n    }\n    /**\n     * Get the pairing response information. This will be shared with the peer during the connection setup\n     */\n    getPairingResponseInfo(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                id: request.id,\n                type: 'postmessage-pairing-response',\n                name: this.name,\n                version: request.version,\n                publicKey: yield this.getPublicKey()\n            };\n        });\n    }\n    /**\n     * Unsubscribe from encrypted messages from a specific peer\n     *\n     * @param senderPublicKey\n     */\n    unsubscribeFromEncryptedMessage(senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listener = this.activeListeners.get(senderPublicKey);\n            if (!listener) {\n                return;\n            }\n            this.activeListeners.delete(senderPublicKey);\n        });\n    }\n    /**\n     * Unsubscribe from all encrypted messages\n     */\n    unsubscribeFromEncryptedMessages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.activeListeners.clear();\n        });\n    }\n    /**\n     * Decrypt a message from a specific peer\n     *\n     * @param senderPublicKey\n     * @param payload\n     */\n    decryptMessage(senderPublicKey, payload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n            const hexPayload = Buffer.from(payload, 'hex');\n            if (hexPayload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n                try {\n                    return yield decryptCryptoboxPayload(hexPayload, sharedRx);\n                }\n                catch (decryptionError) {\n                    /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                }\n            }\n            throw new Error('Could not decrypt message');\n        });\n    }\n    /**\n     * Encrypt a message for a specific publicKey (receiver)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    encryptMessage(recipientPublicKey, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { sharedTx } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n            return encryptCryptoboxPayload(message, sharedTx);\n        });\n    }\n}\n//# sourceMappingURL=MessageBasedClient.js.map"]},"metadata":{},"sourceType":"module"}