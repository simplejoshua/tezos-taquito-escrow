{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { crypto_sign_ed25519_sk_to_curve25519, crypto_sign_ed25519_pk_to_curve25519, crypto_kx_server_session_keys, crypto_kx_client_session_keys } from 'libsodium-wrappers';\nimport { toHex, getHexHash, sealCryptobox } from '@airgap/beacon-utils';\n/**\n * @internalapi\n *\n *\n */\n\nexport class CommunicationClient {\n  constructor(keyPair) {\n    this.keyPair = keyPair;\n  }\n  /**\n   * Get the public key\n   */\n\n\n  getPublicKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return toHex(this.keyPair.publicKey);\n    });\n  }\n  /**\n   * get the public key hash\n   */\n\n\n  getPublicKeyHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return getHexHash(this.keyPair.publicKey);\n    });\n  }\n  /**\n   * Create a cryptobox shared key\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n\n\n  createCryptoBox(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: Don't calculate it every time?\n      const kxSelfPrivateKey = crypto_sign_ed25519_sk_to_curve25519(Buffer.from(selfPrivateKey)); // Secret bytes to scalar bytes\n\n      const kxSelfPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(selfPrivateKey).slice(32, 64)); // Secret bytes to scalar bytes\n\n      const kxOtherPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(otherPublicKey, 'hex')); // Secret bytes to scalar bytes\n\n      return [Buffer.from(kxSelfPublicKey), Buffer.from(kxSelfPrivateKey), Buffer.from(kxOtherPublicKey)];\n    });\n  }\n  /**\n   * Create a cryptobox server\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n\n\n  createCryptoBoxServer(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return crypto_kx_server_session_keys(...keys);\n    });\n  }\n  /**\n   * Create a cryptobox client\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n\n\n  createCryptoBoxClient(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return crypto_kx_client_session_keys(...keys);\n    });\n  }\n  /**\n   * Encrypt a message for a specific publicKey (receiver, asymmetric)\n   *\n   * @param recipientPublicKey\n   * @param message\n   */\n\n\n  encryptMessageAsymmetric(recipientPublicKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return sealCryptobox(message, Buffer.from(recipientPublicKey, 'hex'));\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/transports/clients/CommunicationClient.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAGE,oCAHF,EAIE,oCAJF,EAKE,6BALF,EAME,6BANF,QAOO,oBAPP;AAcA,SAAS,KAAT,EAAgB,UAAhB,EAA4B,aAA5B,QAAiD,sBAAjD;AAEA;;;;AAIG;;AACH,OAAM,MAAgB,mBAAhB,CAAmC;EACvC,WAAA,CAA+B,OAA/B,EAA+C;IAAhB,KAAA,OAAA,GAAA,OAAA;EAAoB;EAEnD;;AAEG;;;EACU,YAAY,GAAA;;MACvB,OAAO,KAAK,CAAC,KAAK,OAAL,CAAa,SAAd,CAAZ;IACD,C;EAAA;EAED;;AAEG;;;EACU,gBAAgB,GAAA;;MAC3B,OAAO,UAAU,CAAC,KAAK,OAAL,CAAa,SAAd,CAAjB;IACD,C;EAAA;EAED;;;;;AAKG;;;EACa,eAAe,CAC7B,cAD6B,EAE7B,cAF6B,EAEH;;MAE1B;MACA,MAAM,gBAAgB,GAAG,oCAAoC,CAAC,MAAM,CAAC,IAAP,CAAY,cAAZ,CAAD,CAA7D,C,CAA2F;;MAC3F,MAAM,eAAe,GAAG,oCAAoC,CAC1D,MAAM,CAAC,IAAP,CAAY,cAAZ,EAA4B,KAA5B,CAAkC,EAAlC,EAAsC,EAAtC,CAD0D,CAA5D,C,CAEE;;MACF,MAAM,gBAAgB,GAAG,oCAAoC,CAC3D,MAAM,CAAC,IAAP,CAAY,cAAZ,EAA4B,KAA5B,CAD2D,CAA7D,C,CAEE;;MAEF,OAAO,CACL,MAAM,CAAC,IAAP,CAAY,eAAZ,CADK,EAEL,MAAM,CAAC,IAAP,CAAY,gBAAZ,CAFK,EAGL,MAAM,CAAC,IAAP,CAAY,gBAAZ,CAHK,CAAP;IAKD,C;EAAA;EAED;;;;;AAKG;;;EACa,qBAAqB,CACnC,cADmC,EAEnC,cAFmC,EAET;;MAE1B,MAAM,IAAI,GAAG,MAAM,KAAK,eAAL,CAAqB,cAArB,EAAqC,cAArC,CAAnB;MAEA,OAAO,6BAA6B,CAAC,GAAG,IAAJ,CAApC;IACD,C;EAAA;EAED;;;;;AAKG;;;EACa,qBAAqB,CACnC,cADmC,EAEnC,cAFmC,EAET;;MAE1B,MAAM,IAAI,GAAG,MAAM,KAAK,eAAL,CAAqB,cAArB,EAAqC,cAArC,CAAnB;MAEA,OAAO,6BAA6B,CAAC,GAAG,IAAJ,CAApC;IACD,C;EAAA;EAED;;;;;AAKG;;;EACa,wBAAwB,CACtC,kBADsC,EAEtC,OAFsC,EAEvB;;MAEf,OAAO,aAAa,CAAC,OAAD,EAAU,MAAM,CAAC,IAAP,CAAY,kBAAZ,EAAgC,KAAhC,CAAV,CAApB;IACD,C;EAAA;;AApFsC","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { crypto_sign_ed25519_sk_to_curve25519, crypto_sign_ed25519_pk_to_curve25519, crypto_kx_server_session_keys, crypto_kx_client_session_keys } from 'libsodium-wrappers';\nimport { toHex, getHexHash, sealCryptobox } from '@airgap/beacon-utils';\n/**\n * @internalapi\n *\n *\n */\nexport class CommunicationClient {\n    constructor(keyPair) {\n        this.keyPair = keyPair;\n    }\n    /**\n     * Get the public key\n     */\n    getPublicKey() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return toHex(this.keyPair.publicKey);\n        });\n    }\n    /**\n     * get the public key hash\n     */\n    getPublicKeyHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getHexHash(this.keyPair.publicKey);\n        });\n    }\n    /**\n     * Create a cryptobox shared key\n     *\n     * @param otherPublicKey\n     * @param selfPrivateKey\n     */\n    createCryptoBox(otherPublicKey, selfPrivateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Don't calculate it every time?\n            const kxSelfPrivateKey = crypto_sign_ed25519_sk_to_curve25519(Buffer.from(selfPrivateKey)); // Secret bytes to scalar bytes\n            const kxSelfPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(selfPrivateKey).slice(32, 64)); // Secret bytes to scalar bytes\n            const kxOtherPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(otherPublicKey, 'hex')); // Secret bytes to scalar bytes\n            return [\n                Buffer.from(kxSelfPublicKey),\n                Buffer.from(kxSelfPrivateKey),\n                Buffer.from(kxOtherPublicKey)\n            ];\n        });\n    }\n    /**\n     * Create a cryptobox server\n     *\n     * @param otherPublicKey\n     * @param selfPrivateKey\n     */\n    createCryptoBoxServer(otherPublicKey, selfPrivateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n            return crypto_kx_server_session_keys(...keys);\n        });\n    }\n    /**\n     * Create a cryptobox client\n     *\n     * @param otherPublicKey\n     * @param selfPrivateKey\n     */\n    createCryptoBoxClient(otherPublicKey, selfPrivateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n            return crypto_kx_client_session_keys(...keys);\n        });\n    }\n    /**\n     * Encrypt a message for a specific publicKey (receiver, asymmetric)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    encryptMessageAsymmetric(recipientPublicKey, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return sealCryptobox(message, Buffer.from(recipientPublicKey, 'hex'));\n        });\n    }\n}\n//# sourceMappingURL=CommunicationClient.js.map"]},"metadata":{},"sourceType":"module"}