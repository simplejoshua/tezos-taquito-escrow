{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async;\n\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nvar BufferTimeOperator = /*@__PURE__*/function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n\n  BufferTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  };\n\n  return BufferTimeOperator;\n}();\n\nvar Context = /*@__PURE__*/function () {\n  function Context() {\n    this.buffer = [];\n  }\n\n  return Context;\n}();\n\nvar BufferTimeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(BufferTimeSubscriber, _super);\n\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.bufferTimeSpan = bufferTimeSpan;\n    _this.bufferCreationInterval = bufferCreationInterval;\n    _this.maxBufferSize = maxBufferSize;\n    _this.scheduler = scheduler;\n    _this.contexts = [];\n\n    var context = _this.openContext();\n\n    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (_this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: _this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: _this,\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: _this,\n        scheduler: scheduler\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n\n      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n\n    return _this;\n  }\n\n  BufferTimeSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n    var filledBufferContext;\n\n    for (var i = 0; i < len; i++) {\n      var context_1 = contexts[i];\n      var buffer = context_1.buffer;\n      buffer.push(value);\n\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context_1;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  };\n\n  BufferTimeSubscriber.prototype._error = function (err) {\n    this.contexts.length = 0;\n\n    _super.prototype._error.call(this, err);\n  };\n\n  BufferTimeSubscriber.prototype._complete = function () {\n    var _a = this,\n        contexts = _a.contexts,\n        destination = _a.destination;\n\n    while (contexts.length > 0) {\n      var context_2 = contexts.shift();\n      destination.next(context_2.buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n\n  BufferTimeSubscriber.prototype._unsubscribe = function () {\n    this.contexts = null;\n  };\n\n  BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n    this.closeContext(context);\n    var closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      var bufferTimeSpan = this.bufferTimeSpan;\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  };\n\n  BufferTimeSubscriber.prototype.openContext = function () {\n    var context = new Context();\n    this.contexts.push(context);\n    return context;\n  };\n\n  BufferTimeSubscriber.prototype.closeContext = function (context) {\n    this.destination.next(context.buffer);\n    var contexts = this.contexts;\n    var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  };\n\n  return BufferTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n      bufferTimeSpan = state.bufferTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n      context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"sources":["../../../src/internal/operators/bufferTime.ts"],"names":[],"mappings":"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","sourcesContent":["/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async;\n    if (isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nvar BufferTimeOperator = /*@__PURE__*/ (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = /*@__PURE__*/ (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\nvar BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.bufferTimeSpan = bufferTimeSpan;\n        _this.bufferCreationInterval = bufferCreationInterval;\n        _this.maxBufferSize = maxBufferSize;\n        _this.scheduler = scheduler;\n        _this.contexts = [];\n        var context = _this.openContext();\n        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (_this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: _this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n        return _this;\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context_1 = contexts[i];\n            var buffer = context_1.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context_1;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context_2 = contexts.shift();\n            destination.next(context_2.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n"]},"metadata":{},"sourceType":"module"}