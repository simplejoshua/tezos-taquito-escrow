{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar heyListen = require('hey-listen');\n\nvar utils = require('@motionone/utils');\n\nvar animateStyle = require('../animate/animate-style.cjs.js');\n\nvar style = require('../animate/style.cjs.js');\n\nvar options = require('../animate/utils/options.cjs.js');\n\nvar hasChanged = require('./utils/has-changed.cjs.js');\n\nvar resolveVariant = require('./utils/resolve-variant.cjs.js');\n\nvar schedule = require('./utils/schedule.cjs.js');\n\nvar inView = require('./gestures/in-view.cjs.js');\n\nvar hover = require('./gestures/hover.cjs.js');\n\nvar press = require('./gestures/press.cjs.js');\n\nvar events = require('./utils/events.cjs.js');\n\nconst gestures = {\n  inView: inView.inView,\n  hover: hover.hover,\n  press: press.press\n};\n/**\n * A list of state types, in priority order. If a value is defined in\n * a righter-most type, it will override any definition in a lefter-most.\n */\n\nconst stateTypes = [\"initial\", \"animate\", ...Object.keys(gestures), \"exit\"];\n/**\n * A global store of all generated motion states. This can be used to lookup\n * a motion state for a given Element.\n */\n\nconst mountedStates = new WeakMap();\n\nfunction createMotionState() {\n  let options$1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let parent = arguments.length > 1 ? arguments[1] : undefined;\n\n  /**\n   * The element represented by the motion state. This is an empty reference\n   * when we create the state to support SSR and allow for later mounting\n   * in view libraries.\n   *\n   * @ts-ignore\n   */\n  let element;\n  /**\n   * Calculate a depth that we can use to order motion states by tree depth.\n   */\n\n  let depth = parent ? parent.getDepth() + 1 : 0;\n  /**\n   * Track which states are currently active.\n   */\n\n  const activeStates = {\n    initial: true,\n    animate: true\n  };\n  /**\n   * A map of functions that, when called, will remove event listeners for\n   * a given gesture.\n   */\n\n  const gestureSubscriptions = {};\n  /**\n   * Initialise a context to share through motion states. This\n   * will be populated by variant names (if any).\n   */\n\n  const context = {};\n\n  for (const name of stateTypes) {\n    context[name] = typeof options$1[name] === \"string\" ? options$1[name] : parent === null || parent === void 0 ? void 0 : parent.getContext()[name];\n  }\n  /**\n   * If initial is set to false we use the animate prop as the initial\n   * animation state.\n   */\n\n\n  const initialVariantSource = options$1.initial === false ? \"animate\" : \"initial\";\n  /**\n   * Destructure an initial target out from the resolved initial variant.\n   */\n\n  let _a = resolveVariant.resolveVariant(options$1[initialVariantSource] || context[initialVariantSource], options$1.variants) || {},\n      target = tslib.__rest(_a, [\"transition\"]);\n  /**\n   * The base target is a cached map of values that we'll use to animate\n   * back to if a value is removed from all active state types. This\n   * is usually the initial value as read from the DOM, for instance if\n   * it hasn't been defined in initial.\n   */\n\n\n  const baseTarget = Object.assign({}, target);\n  /**\n   * A generator that will be processed by the global animation scheduler.\n   * This yeilds when it switches from reading the DOM to writing to it\n   * to prevent layout thrashing.\n   */\n\n  function* animateUpdates() {\n    var _a, _b;\n\n    const prevTarget = target;\n    target = {};\n    const animationOptions = {};\n\n    for (const name of stateTypes) {\n      if (!activeStates[name]) continue;\n      const variant = resolveVariant.resolveVariant(options$1[name]);\n      if (!variant) continue;\n\n      for (const key in variant) {\n        if (key === \"transition\") continue;\n        target[key] = variant[key];\n        animationOptions[key] = options.getOptions((_b = (_a = variant.transition) !== null && _a !== void 0 ? _a : options$1.transition) !== null && _b !== void 0 ? _b : {}, key);\n      }\n    }\n\n    const allTargetKeys = new Set([...Object.keys(target), ...Object.keys(prevTarget)]);\n    const animationFactories = [];\n    allTargetKeys.forEach(key => {\n      var _a;\n\n      if (target[key] === undefined) {\n        target[key] = baseTarget[key];\n      }\n\n      if (hasChanged.hasChanged(prevTarget[key], target[key])) {\n        (_a = baseTarget[key]) !== null && _a !== void 0 ? _a : baseTarget[key] = style.style.get(element, key);\n        animationFactories.push(animateStyle.animateStyle(element, key, target[key], animationOptions[key]));\n      }\n    }); // Wait for all animation states to read from the DOM\n\n    yield;\n    const animations = animationFactories.map(factory => factory()).filter(Boolean);\n    if (!animations.length) return;\n    const animationTarget = target;\n    element.dispatchEvent(events.motionEvent(\"motionstart\", animationTarget));\n    Promise.all(animations.map(animation => animation.finished)).then(() => {\n      element.dispatchEvent(events.motionEvent(\"motioncomplete\", animationTarget));\n    }).catch(utils.noop);\n  }\n\n  const setGesture = (name, isActive) => () => {\n    activeStates[name] = isActive;\n    schedule.scheduleAnimation(state);\n  };\n\n  const updateGestureSubscriptions = () => {\n    for (const name in gestures) {\n      const isGestureActive = gestures[name].isActive(options$1);\n      const remove = gestureSubscriptions[name];\n\n      if (isGestureActive && !remove) {\n        gestureSubscriptions[name] = gestures[name].subscribe(element, {\n          enable: setGesture(name, true),\n          disable: setGesture(name, false)\n        }, options$1);\n      } else if (!isGestureActive && remove) {\n        remove();\n        delete gestureSubscriptions[name];\n      }\n    }\n  };\n\n  const state = {\n    update: newOptions => {\n      if (!element) return;\n      options$1 = newOptions;\n      updateGestureSubscriptions();\n      schedule.scheduleAnimation(state);\n    },\n    setActive: (name, isActive) => {\n      if (!element) return;\n      activeStates[name] = isActive;\n      schedule.scheduleAnimation(state);\n    },\n    animateUpdates,\n    getDepth: () => depth,\n    getTarget: () => target,\n    getOptions: () => options$1,\n    getContext: () => context,\n    mount: newElement => {\n      heyListen.invariant(Boolean(newElement), \"Animation state must be mounted with valid Element\");\n      element = newElement;\n      mountedStates.set(element, state);\n      updateGestureSubscriptions();\n      return () => {\n        mountedStates.delete(element);\n        schedule.unscheduleAnimation(state);\n\n        for (const key in gestureSubscriptions) {\n          gestureSubscriptions[key]();\n        }\n      };\n    },\n    isMounted: () => Boolean(element)\n  };\n  return state;\n}\n\nexports.createMotionState = createMotionState;\nexports.mountedStates = mountedStates;","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib","require","heyListen","utils","animateStyle","style","options","hasChanged","resolveVariant","schedule","inView","hover","press","events","gestures","stateTypes","keys","mountedStates","WeakMap","createMotionState","options$1","parent","element","depth","getDepth","activeStates","initial","animate","gestureSubscriptions","context","name","getContext","initialVariantSource","_a","variants","target","__rest","baseTarget","assign","animateUpdates","_b","prevTarget","animationOptions","variant","key","getOptions","transition","allTargetKeys","Set","animationFactories","forEach","undefined","get","push","animations","map","factory","filter","Boolean","length","animationTarget","dispatchEvent","motionEvent","Promise","all","animation","finished","then","catch","noop","setGesture","isActive","scheduleAnimation","state","updateGestureSubscriptions","isGestureActive","remove","subscribe","enable","disable","update","newOptions","setActive","getTarget","mount","newElement","invariant","set","delete","unscheduleAnimation","isMounted"],"sources":["C:/Users/Joshua Doros/node_modules/@motionone/dom/dist/state/index.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar heyListen = require('hey-listen');\nvar utils = require('@motionone/utils');\nvar animateStyle = require('../animate/animate-style.cjs.js');\nvar style = require('../animate/style.cjs.js');\nvar options = require('../animate/utils/options.cjs.js');\nvar hasChanged = require('./utils/has-changed.cjs.js');\nvar resolveVariant = require('./utils/resolve-variant.cjs.js');\nvar schedule = require('./utils/schedule.cjs.js');\nvar inView = require('./gestures/in-view.cjs.js');\nvar hover = require('./gestures/hover.cjs.js');\nvar press = require('./gestures/press.cjs.js');\nvar events = require('./utils/events.cjs.js');\n\nconst gestures = { inView: inView.inView, hover: hover.hover, press: press.press };\n/**\n * A list of state types, in priority order. If a value is defined in\n * a righter-most type, it will override any definition in a lefter-most.\n */\nconst stateTypes = [\"initial\", \"animate\", ...Object.keys(gestures), \"exit\"];\n/**\n * A global store of all generated motion states. This can be used to lookup\n * a motion state for a given Element.\n */\nconst mountedStates = new WeakMap();\nfunction createMotionState(options$1 = {}, parent) {\n    /**\n     * The element represented by the motion state. This is an empty reference\n     * when we create the state to support SSR and allow for later mounting\n     * in view libraries.\n     *\n     * @ts-ignore\n     */\n    let element;\n    /**\n     * Calculate a depth that we can use to order motion states by tree depth.\n     */\n    let depth = parent ? parent.getDepth() + 1 : 0;\n    /**\n     * Track which states are currently active.\n     */\n    const activeStates = { initial: true, animate: true };\n    /**\n     * A map of functions that, when called, will remove event listeners for\n     * a given gesture.\n     */\n    const gestureSubscriptions = {};\n    /**\n     * Initialise a context to share through motion states. This\n     * will be populated by variant names (if any).\n     */\n    const context = {};\n    for (const name of stateTypes) {\n        context[name] =\n            typeof options$1[name] === \"string\"\n                ? options$1[name]\n                : parent === null || parent === void 0 ? void 0 : parent.getContext()[name];\n    }\n    /**\n     * If initial is set to false we use the animate prop as the initial\n     * animation state.\n     */\n    const initialVariantSource = options$1.initial === false ? \"animate\" : \"initial\";\n    /**\n     * Destructure an initial target out from the resolved initial variant.\n     */\n    let _a = resolveVariant.resolveVariant(options$1[initialVariantSource] || context[initialVariantSource], options$1.variants) || {}, target = tslib.__rest(_a, [\"transition\"]);\n    /**\n     * The base target is a cached map of values that we'll use to animate\n     * back to if a value is removed from all active state types. This\n     * is usually the initial value as read from the DOM, for instance if\n     * it hasn't been defined in initial.\n     */\n    const baseTarget = Object.assign({}, target);\n    /**\n     * A generator that will be processed by the global animation scheduler.\n     * This yeilds when it switches from reading the DOM to writing to it\n     * to prevent layout thrashing.\n     */\n    function* animateUpdates() {\n        var _a, _b;\n        const prevTarget = target;\n        target = {};\n        const animationOptions = {};\n        for (const name of stateTypes) {\n            if (!activeStates[name])\n                continue;\n            const variant = resolveVariant.resolveVariant(options$1[name]);\n            if (!variant)\n                continue;\n            for (const key in variant) {\n                if (key === \"transition\")\n                    continue;\n                target[key] = variant[key];\n                animationOptions[key] = options.getOptions((_b = (_a = variant.transition) !== null && _a !== void 0 ? _a : options$1.transition) !== null && _b !== void 0 ? _b : {}, key);\n            }\n        }\n        const allTargetKeys = new Set([\n            ...Object.keys(target),\n            ...Object.keys(prevTarget),\n        ]);\n        const animationFactories = [];\n        allTargetKeys.forEach((key) => {\n            var _a;\n            if (target[key] === undefined) {\n                target[key] = baseTarget[key];\n            }\n            if (hasChanged.hasChanged(prevTarget[key], target[key])) {\n                (_a = baseTarget[key]) !== null && _a !== void 0 ? _a : (baseTarget[key] = style.style.get(element, key));\n                animationFactories.push(animateStyle.animateStyle(element, key, target[key], animationOptions[key]));\n            }\n        });\n        // Wait for all animation states to read from the DOM\n        yield;\n        const animations = animationFactories\n            .map((factory) => factory())\n            .filter(Boolean);\n        if (!animations.length)\n            return;\n        const animationTarget = target;\n        element.dispatchEvent(events.motionEvent(\"motionstart\", animationTarget));\n        Promise.all(animations.map((animation) => animation.finished))\n            .then(() => {\n            element.dispatchEvent(events.motionEvent(\"motioncomplete\", animationTarget));\n        })\n            .catch(utils.noop);\n    }\n    const setGesture = (name, isActive) => () => {\n        activeStates[name] = isActive;\n        schedule.scheduleAnimation(state);\n    };\n    const updateGestureSubscriptions = () => {\n        for (const name in gestures) {\n            const isGestureActive = gestures[name].isActive(options$1);\n            const remove = gestureSubscriptions[name];\n            if (isGestureActive && !remove) {\n                gestureSubscriptions[name] = gestures[name].subscribe(element, {\n                    enable: setGesture(name, true),\n                    disable: setGesture(name, false),\n                }, options$1);\n            }\n            else if (!isGestureActive && remove) {\n                remove();\n                delete gestureSubscriptions[name];\n            }\n        }\n    };\n    const state = {\n        update: (newOptions) => {\n            if (!element)\n                return;\n            options$1 = newOptions;\n            updateGestureSubscriptions();\n            schedule.scheduleAnimation(state);\n        },\n        setActive: (name, isActive) => {\n            if (!element)\n                return;\n            activeStates[name] = isActive;\n            schedule.scheduleAnimation(state);\n        },\n        animateUpdates,\n        getDepth: () => depth,\n        getTarget: () => target,\n        getOptions: () => options$1,\n        getContext: () => context,\n        mount: (newElement) => {\n            heyListen.invariant(Boolean(newElement), \"Animation state must be mounted with valid Element\");\n            element = newElement;\n            mountedStates.set(element, state);\n            updateGestureSubscriptions();\n            return () => {\n                mountedStates.delete(element);\n                schedule.unscheduleAnimation(state);\n                for (const key in gestureSubscriptions) {\n                    gestureSubscriptions[key]();\n                }\n            };\n        },\n        isMounted: () => Boolean(element),\n    };\n    return state;\n}\n\nexports.createMotionState = createMotionState;\nexports.mountedStates = mountedStates;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}