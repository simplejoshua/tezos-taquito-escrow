{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { keys } from '@airgap/beacon-utils';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { StorageKey } from '@airgap/beacon-types';\nconst PRESERVED_FIELDS = ['syncToken', 'rooms'];\n/**\n * The class managing the local state of matrix\n */\n\nexport class MatrixClientStore {\n  constructor(storage) {\n    this.storage = storage;\n    /**\n     * The state of the matrix client\n     */\n\n    this.state = {\n      isRunning: false,\n      userId: undefined,\n      deviceId: undefined,\n      txnNo: 0,\n      accessToken: undefined,\n      syncToken: undefined,\n      pollingTimeout: undefined,\n      pollingRetries: 0,\n      rooms: {}\n    };\n    /**\n     * Listeners that will be called when the state changes\n     */\n\n    this.onStateChangedListeners = new Map();\n    /**\n     * A promise that resolves once the client is ready\n     */\n\n    this.waitReadyPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.initFromStorage();\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    }));\n  }\n  /**\n   * Get an item from the state\n   *\n   * @param key\n   */\n\n\n  get(key) {\n    return this.state[key];\n  }\n  /**\n   * Get the room from an ID or room instance\n   *\n   * @param roomOrId\n   */\n\n\n  getRoom(roomOrId) {\n    const room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);\n    return this.state.rooms[room.id] || room;\n  }\n  /**\n   * Update the state with a partial state\n   *\n   * @param stateUpdate\n   */\n\n\n  update(stateUpdate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.waitReady();\n      const oldState = Object.assign({}, this.state);\n      this.setState(stateUpdate);\n      this.updateStorage(stateUpdate);\n      this.notifyListeners(oldState, this.state, stateUpdate);\n    });\n  }\n  /**\n   * Register listeners that are called once the state has changed\n   *\n   * @param listener\n   * @param subscribed\n   */\n\n\n  onStateChanged(listener) {\n    for (var _len = arguments.length, subscribed = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      subscribed[_key - 1] = arguments[_key];\n    }\n\n    if (subscribed.length > 0) {\n      subscribed.forEach(key => {\n        this.onStateChangedListeners.set(key, listener);\n      });\n    } else {\n      this.onStateChangedListeners.set('all', listener);\n    }\n  }\n  /**\n   * A promise that resolves once the client is ready\n   */\n\n\n  waitReady() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.waitReadyPromise;\n    });\n  }\n  /**\n   * Read state from storage\n   */\n\n\n  initFromStorage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const preserved = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n      this.setState(preserved);\n    });\n  }\n  /**\n   * Prepare data before persisting it in storage\n   *\n   * @param toStore\n   */\n\n\n  prepareData(toStore) {\n    const requiresPreparation = ['rooms'];\n    const toStoreCopy = requiresPreparation.some(key => toStore[key] !== undefined) ? JSON.parse(JSON.stringify(toStore)) : toStore; // there is no need for saving messages in a persistent storage\n\n    Object.values(toStoreCopy.rooms || {}).forEach(room => {\n      room.messages = [];\n    });\n    return toStoreCopy;\n  }\n  /**\n   * Persist state in storage\n   *\n   * @param stateUpdate\n   */\n\n\n  updateStorage(stateUpdate) {\n    const updatedCachedFields = Object.entries(stateUpdate).filter(_ref => {\n      let [key, value] = _ref;\n      return PRESERVED_FIELDS.includes(key) && Boolean(value);\n    });\n\n    if (updatedCachedFields.length > 0) {\n      const filteredState = {};\n      PRESERVED_FIELDS.forEach(key => {\n        filteredState[key] = this.state[key];\n      });\n      this.storage.set(StorageKey.MATRIX_PRESERVED_STATE, this.prepareData(filteredState));\n    }\n  }\n  /**\n   * Set the state\n   *\n   * @param partialState\n   */\n\n\n  setState(partialState) {\n    this.state = {\n      isRunning: partialState.isRunning || this.state.isRunning,\n      userId: partialState.userId || this.state.userId,\n      deviceId: partialState.deviceId || this.state.deviceId,\n      txnNo: partialState.txnNo || this.state.txnNo,\n      accessToken: partialState.accessToken || this.state.accessToken,\n      syncToken: partialState.syncToken || this.state.syncToken,\n      pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,\n      pollingRetries: partialState.pollingRetries || this.state.pollingRetries,\n      rooms: this.mergeRooms(this.state.rooms, partialState.rooms)\n    };\n  }\n  /**\n   * Merge room records and eliminate duplicates\n   *\n   * @param oldRooms\n   * @param _newRooms\n   */\n\n\n  mergeRooms(oldRooms, _newRooms) {\n    if (!_newRooms) {\n      return oldRooms;\n    }\n\n    const newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);\n    const merged = Object.assign({}, oldRooms);\n    newRooms.forEach(newRoom => {\n      merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);\n    });\n    return merged;\n  }\n  /**\n   * Notify listeners of state changes\n   *\n   * @param oldState\n   * @param newState\n   * @param stateChange\n   */\n\n\n  notifyListeners(oldState, newState, stateChange) {\n    const listenForAll = this.onStateChangedListeners.get('all');\n\n    if (listenForAll) {\n      listenForAll(oldState, newState, stateChange);\n    }\n\n    keys(stateChange).filter(key => stateChange[key] !== undefined).forEach(key => {\n      const listener = this.onStateChangedListeners.get(key);\n\n      if (listener) {\n        listener(oldState, newState, stateChange);\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/matrix-client/MatrixClientStore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { keys } from '@airgap/beacon-utils';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { StorageKey } from '@airgap/beacon-types';\nconst PRESERVED_FIELDS = ['syncToken', 'rooms'];\n/**\n * The class managing the local state of matrix\n */\nexport class MatrixClientStore {\n    constructor(storage) {\n        this.storage = storage;\n        /**\n         * The state of the matrix client\n         */\n        this.state = {\n            isRunning: false,\n            userId: undefined,\n            deviceId: undefined,\n            txnNo: 0,\n            accessToken: undefined,\n            syncToken: undefined,\n            pollingTimeout: undefined,\n            pollingRetries: 0,\n            rooms: {}\n        };\n        /**\n         * Listeners that will be called when the state changes\n         */\n        this.onStateChangedListeners = new Map();\n        /**\n         * A promise that resolves once the client is ready\n         */\n        this.waitReadyPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.initFromStorage();\n                resolve();\n            }\n            catch (error) {\n                reject(error);\n            }\n        }));\n    }\n    /**\n     * Get an item from the state\n     *\n     * @param key\n     */\n    get(key) {\n        return this.state[key];\n    }\n    /**\n     * Get the room from an ID or room instance\n     *\n     * @param roomOrId\n     */\n    getRoom(roomOrId) {\n        const room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);\n        return this.state.rooms[room.id] || room;\n    }\n    /**\n     * Update the state with a partial state\n     *\n     * @param stateUpdate\n     */\n    update(stateUpdate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.waitReady();\n            const oldState = Object.assign({}, this.state);\n            this.setState(stateUpdate);\n            this.updateStorage(stateUpdate);\n            this.notifyListeners(oldState, this.state, stateUpdate);\n        });\n    }\n    /**\n     * Register listeners that are called once the state has changed\n     *\n     * @param listener\n     * @param subscribed\n     */\n    onStateChanged(listener, ...subscribed) {\n        if (subscribed.length > 0) {\n            subscribed.forEach((key) => {\n                this.onStateChangedListeners.set(key, listener);\n            });\n        }\n        else {\n            this.onStateChangedListeners.set('all', listener);\n        }\n    }\n    /**\n     * A promise that resolves once the client is ready\n     */\n    waitReady() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.waitReadyPromise;\n        });\n    }\n    /**\n     * Read state from storage\n     */\n    initFromStorage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const preserved = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n            this.setState(preserved);\n        });\n    }\n    /**\n     * Prepare data before persisting it in storage\n     *\n     * @param toStore\n     */\n    prepareData(toStore) {\n        const requiresPreparation = ['rooms'];\n        const toStoreCopy = requiresPreparation.some((key) => toStore[key] !== undefined)\n            ? JSON.parse(JSON.stringify(toStore))\n            : toStore;\n        // there is no need for saving messages in a persistent storage\n        Object.values(toStoreCopy.rooms || {}).forEach((room) => {\n            room.messages = [];\n        });\n        return toStoreCopy;\n    }\n    /**\n     * Persist state in storage\n     *\n     * @param stateUpdate\n     */\n    updateStorage(stateUpdate) {\n        const updatedCachedFields = Object.entries(stateUpdate).filter(([key, value]) => PRESERVED_FIELDS.includes(key) && Boolean(value));\n        if (updatedCachedFields.length > 0) {\n            const filteredState = {};\n            PRESERVED_FIELDS.forEach((key) => {\n                filteredState[key] = this.state[key];\n            });\n            this.storage.set(StorageKey.MATRIX_PRESERVED_STATE, this.prepareData(filteredState));\n        }\n    }\n    /**\n     * Set the state\n     *\n     * @param partialState\n     */\n    setState(partialState) {\n        this.state = {\n            isRunning: partialState.isRunning || this.state.isRunning,\n            userId: partialState.userId || this.state.userId,\n            deviceId: partialState.deviceId || this.state.deviceId,\n            txnNo: partialState.txnNo || this.state.txnNo,\n            accessToken: partialState.accessToken || this.state.accessToken,\n            syncToken: partialState.syncToken || this.state.syncToken,\n            pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,\n            pollingRetries: partialState.pollingRetries || this.state.pollingRetries,\n            rooms: this.mergeRooms(this.state.rooms, partialState.rooms)\n        };\n    }\n    /**\n     * Merge room records and eliminate duplicates\n     *\n     * @param oldRooms\n     * @param _newRooms\n     */\n    mergeRooms(oldRooms, _newRooms) {\n        if (!_newRooms) {\n            return oldRooms;\n        }\n        const newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);\n        const merged = Object.assign({}, oldRooms);\n        newRooms.forEach((newRoom) => {\n            merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);\n        });\n        return merged;\n    }\n    /**\n     * Notify listeners of state changes\n     *\n     * @param oldState\n     * @param newState\n     * @param stateChange\n     */\n    notifyListeners(oldState, newState, stateChange) {\n        const listenForAll = this.onStateChangedListeners.get('all');\n        if (listenForAll) {\n            listenForAll(oldState, newState, stateChange);\n        }\n        keys(stateChange)\n            .filter((key) => stateChange[key] !== undefined)\n            .forEach((key) => {\n            const listener = this.onStateChangedListeners.get(key);\n            if (listener) {\n                listener(oldState, newState, stateChange);\n            }\n        });\n    }\n}\n//# sourceMappingURL=MatrixClientStore.js.map"]},"metadata":{},"sourceType":"module"}