{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { verify } from '@stablelib/ed25519';\nimport { hash } from '@stablelib/blake2b';\nimport blake from 'blakejs';\nimport bs58check from 'bs58check';\nimport elliptic from 'elliptic';\nimport toBuffer from 'typedarray-to-buffer';\nvar Prefix;\n\n(function (Prefix) {\n  Prefix[\"TZ1\"] = \"tz1\";\n  Prefix[\"TZ2\"] = \"tz2\";\n  Prefix[\"TZ3\"] = \"tz3\";\n  Prefix[\"TZ4\"] = \"tz4\";\n  Prefix[\"KT\"] = \"KT\";\n  Prefix[\"KT1\"] = \"KT1\";\n  Prefix[\"EDSK2\"] = \"edsk2\";\n  Prefix[\"SPSK\"] = \"spsk\";\n  Prefix[\"P2SK\"] = \"p2sk\";\n  Prefix[\"EDPK\"] = \"edpk\";\n  Prefix[\"SPPK\"] = \"sppk\";\n  Prefix[\"P2PK\"] = \"p2pk\";\n  Prefix[\"EDESK\"] = \"edesk\";\n  Prefix[\"SPESK\"] = \"spesk\";\n  Prefix[\"P2ESK\"] = \"p2esk\";\n  Prefix[\"EDSK\"] = \"edsk\";\n  Prefix[\"EDSIG\"] = \"edsig\";\n  Prefix[\"SPSIG\"] = \"spsig\";\n  Prefix[\"P2SIG\"] = \"p2sig\";\n  Prefix[\"SIG\"] = \"sig\";\n  Prefix[\"NET\"] = \"Net\";\n  Prefix[\"NCE\"] = \"nce\";\n  Prefix[\"B\"] = \"B\";\n  Prefix[\"O\"] = \"o\";\n  Prefix[\"LO\"] = \"Lo\";\n  Prefix[\"LLO\"] = \"LLo\";\n  Prefix[\"P\"] = \"P\";\n  Prefix[\"CO\"] = \"Co\";\n  Prefix[\"ID\"] = \"id\";\n  Prefix[\"EXPR\"] = \"expr\";\n  Prefix[\"TZ\"] = \"TZ\";\n  Prefix[\"VH\"] = \"vh\"; //rollups\n\n  Prefix[\"TXR1\"] = \"txr1\";\n  Prefix[\"TXI\"] = \"txi\";\n  Prefix[\"TXM\"] = \"txm\";\n  Prefix[\"TXC\"] = \"txc\";\n  Prefix[\"TXMR\"] = \"txmr\";\n  Prefix[\"TXRL\"] = \"txM\";\n  Prefix[\"TXW\"] = \"txw\";\n})(Prefix || (Prefix = {}));\n\nconst prefix = {\n  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),\n  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),\n  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),\n  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),\n  [Prefix.KT]: new Uint8Array([2, 90, 121]),\n  [Prefix.KT1]: new Uint8Array([2, 90, 121]),\n  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),\n  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),\n  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),\n  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),\n  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),\n  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),\n  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),\n  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),\n  [Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),\n  [Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),\n  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),\n  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),\n  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),\n  [Prefix.SIG]: new Uint8Array([4, 130, 43]),\n  [Prefix.NET]: new Uint8Array([87, 82, 0]),\n  [Prefix.NCE]: new Uint8Array([69, 220, 169]),\n  [Prefix.B]: new Uint8Array([1, 52]),\n  [Prefix.O]: new Uint8Array([5, 116]),\n  [Prefix.LO]: new Uint8Array([133, 233]),\n  [Prefix.LLO]: new Uint8Array([29, 159, 109]),\n  [Prefix.P]: new Uint8Array([2, 170]),\n  [Prefix.CO]: new Uint8Array([79, 179]),\n  [Prefix.ID]: new Uint8Array([153, 103]),\n  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),\n  // Legacy prefix\n  [Prefix.TZ]: new Uint8Array([2, 90, 121]),\n  [Prefix.VH]: new Uint8Array([1, 106, 242]),\n  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),\n  [Prefix.TXI]: new Uint8Array([79, 148, 196]),\n  [Prefix.TXM]: new Uint8Array([79, 149, 30]),\n  [Prefix.TXC]: new Uint8Array([79, 148, 17]),\n  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),\n  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),\n  [Prefix.TXW]: new Uint8Array([79, 150, 72])\n};\nconst prefixLength = {\n  [Prefix.TZ1]: 20,\n  [Prefix.TZ2]: 20,\n  [Prefix.TZ3]: 20,\n  [Prefix.TZ4]: 20,\n  [Prefix.KT]: 20,\n  [Prefix.KT1]: 20,\n  [Prefix.EDPK]: 32,\n  [Prefix.SPPK]: 33,\n  [Prefix.P2PK]: 33,\n  [Prefix.EDSIG]: 64,\n  [Prefix.SPSIG]: 64,\n  [Prefix.P2SIG]: 64,\n  [Prefix.SIG]: 64,\n  [Prefix.NET]: 4,\n  [Prefix.B]: 32,\n  [Prefix.P]: 32,\n  [Prefix.O]: 32,\n  [Prefix.VH]: 32,\n  [Prefix.TXR1]: 20,\n  [Prefix.TXI]: 32,\n  [Prefix.TXM]: 32,\n  [Prefix.TXC]: 32,\n  [Prefix.TXMR]: 32,\n  [Prefix.TXRL]: 32,\n  [Prefix.TXW]: 32\n};\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid key being passed or used\r\n */\n\nclass InvalidKeyError extends Error {\n  constructor(key, errorDetail) {\n    super(`The key ${key} is invalid. ${errorDetail}`);\n    this.key = key;\n    this.errorDetail = errorDetail;\n    this.name = 'InvalidKeyError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an Invalid Public Key being passed or used\r\n */\n\n\nclass InvalidPublicKeyError extends Error {\n  constructor(publicKey, errorDetail) {\n    super(`The public key '${publicKey}' is invalid. ${errorDetail}`);\n    this.publicKey = publicKey;\n    this.name = 'InvalidPublicKeyError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid signature being passed or used\r\n */\n\n\nclass InvalidSignatureError extends Error {\n  constructor(signature, errorDetail) {\n    super(`The signature '${signature}' is invalid (${errorDetail})`);\n    this.signature = signature;\n    this.name = 'InvalidSignatureError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid message being passed or used\r\n */\n\n\nclass InvalidMessageError extends Error {\n  constructor(msg, errorDetail) {\n    super(`The message '${msg}' is invalid. ${errorDetail}`);\n    this.msg = msg;\n    this.errorDetail = errorDetail;\n    this.name = 'InvalidMessageError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid contract address being passed or used\r\n */\n\n\nclass InvalidContractAddressError extends Error {\n  constructor(contractAddress) {\n    super(`The contract address '${contractAddress}' is invalid`);\n    this.contractAddress = contractAddress;\n    this.name = 'InvalidContractAddressError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid address being passed or used (both contract and implicit)\r\n */\n\n\nclass InvalidAddressError extends Error {\n  constructor(address) {\n    super(`The address '${address}' is invalid`);\n    this.address = address;\n    this.name = 'InvalidAddressError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid chain id being passed or used\r\n */\n\n\nclass InvalidChainIdError extends Error {\n  constructor(chainId) {\n    super(`The chain id '${chainId}' is invalid`);\n    this.chainId = chainId;\n    this.name = 'InvalidChainIdError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid key hash being passed or used\r\n */\n\n\nclass InvalidKeyHashError extends Error {\n  constructor(keyHash) {\n    super(`The public key hash '${keyHash}' is invalid`);\n    this.keyHash = keyHash;\n    this.name = 'InvalidKeyHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid block hash being passed or used\r\n */\n\n\nclass InvalidBlockHashError extends Error {\n  constructor(blockHash) {\n    super(`The block hash '${blockHash}' is invalid`);\n    this.blockHash = blockHash;\n    this.name = 'InvalidBlockHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid protocol hash being passed or used\r\n */\n\n\nclass InvalidProtocolHashError extends Error {\n  constructor(protocolHash) {\n    super(`The protocol hash '${protocolHash}' is invalid`);\n    this.protocolHash = protocolHash;\n    this.name = 'InvalidProtocolHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid operation hash being passed or used\r\n */\n\n\nclass InvalidOperationHashError extends Error {\n  constructor(operationHash) {\n    super(`The operation hash '${operationHash}' is invalid`);\n    this.operationHash = operationHash;\n    this.name = 'InvalidOperationHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid operation kind being passed or used\r\n */\n\n\nclass InvalidOperationKindError extends Error {\n  constructor(operationKind) {\n    super(`The operation kind '${operationKind}' is unsupported`);\n    this.operationKind = operationKind;\n    this.name = 'InvalidOperationKindError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates something is no longer supported and/or deprecated\r\n */\n\n\nclass DeprecationError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'DeprecationError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates an action is prohibited or not allowed\r\n */\n\n\nclass ProhibitedActionError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'ProhibitedActionError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates a failure when trying to convert data from one type to another\r\n */\n\n\nclass ValueConversionError extends Error {\n  constructor(value, desiredType) {\n    super(`Unable to convert ${value} to a ${desiredType}`);\n    this.value = value;\n    this.desiredType = desiredType;\n    this.name = 'ValueConversionError';\n  }\n\n}\n/**\r\n * @description Verify signature of a payload\r\n *\r\n * @param messageBytes The forged message including the magic byte (11 for block,\r\n *        12 for preendorsement, 13 for endorsement, 3 for generic, 5 for the PACK format of michelson)\r\n * @param publicKey The public key to verify the signature against\r\n * @param signature The signature to verify\r\n * @returns A boolean indicating if the signature matches\r\n *\r\n * @example\r\n * ```\r\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\r\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\r\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\r\n *\r\n * const response = verifySignature(message, pk, sig);\r\n * ```\r\n *\r\n */\n\n\nfunction verifySignature(messageBytes, publicKey, signature) {\n  const pkPrefix = validatePkAndExtractPrefix(publicKey);\n  const sigPrefix = validateSigAndExtractPrefix(signature);\n  const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);\n  const decodedSig = b58cdecode(signature, prefix[sigPrefix]);\n  const bytesHash = hash(hex2buf(validateMessageNotEmpty(messageBytes)), 32);\n\n  if (pkPrefix === Prefix.EDPK) {\n    return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.SPPK) {\n    return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.P2PK) {\n    return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);\n  } else {\n    return false;\n  }\n}\n\nfunction validateMessageNotEmpty(message) {\n  if (message === '') {\n    throw new InvalidMessageError(message, 'The message provided for verifying signature cannot be empty.');\n  }\n\n  return message;\n}\n\nfunction validatePkAndExtractPrefix(publicKey) {\n  if (publicKey === '') {\n    throw new InvalidPublicKeyError(publicKey, 'Public key cannot be empty');\n  }\n\n  const pkPrefix = publicKey.substring(0, 4);\n  const validation = validatePublicKey(publicKey);\n\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid checksum');\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidPublicKeyError(publicKey, `The public key provided has an unsupported prefix: ${pkPrefix}`);\n    }\n  }\n\n  return pkPrefix;\n}\n\nfunction validateSigAndExtractPrefix(signature) {\n  const signaturePrefix = signature.startsWith('sig') ? signature.substr(0, 3) : signature.substr(0, 5);\n  const validation = validateSignature(signature);\n\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidSignatureError(signature, `invalid checksum`);\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidSignatureError(signature, 'invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidSignatureError(signaturePrefix, 'unsupported prefix');\n    }\n  }\n\n  return signaturePrefix;\n}\n\nfunction verifyEdSignature(decodedSig, bytesHash, decodedPublicKey) {\n  try {\n    return verify(decodedPublicKey, bytesHash, decodedSig);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction verifySpSignature(decodedSig, bytesHash, decodedPublicKey) {\n  const key = new elliptic.ec('secp256k1').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifyP2Signature(decodedSig, bytesHash, decodedPublicKey) {\n  const key = new elliptic.ec('p256').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifySpOrP2Sig(decodedSig, bytesHash, key) {\n  const hexSig = buf2hex(toBuffer(decodedSig));\n  const match = hexSig.match(/([a-f\\d]{64})/gi);\n\n  if (match) {\n    try {\n      const [r, s] = match;\n      return key.verify(bytesHash, {\n        r,\n        s\n      });\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nvar ValidationResult;\n\n(function (ValidationResult) {\n  ValidationResult[ValidationResult[\"NO_PREFIX_MATCHED\"] = 0] = \"NO_PREFIX_MATCHED\";\n  ValidationResult[ValidationResult[\"INVALID_CHECKSUM\"] = 1] = \"INVALID_CHECKSUM\";\n  ValidationResult[ValidationResult[\"INVALID_LENGTH\"] = 2] = \"INVALID_LENGTH\";\n  ValidationResult[ValidationResult[\"VALID\"] = 3] = \"VALID\";\n})(ValidationResult || (ValidationResult = {}));\n\nfunction isValidPrefix(value) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  return value in prefix;\n}\n/**\r\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\r\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\r\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\r\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\r\n * If all checks pass, return `VALID`.\r\n *\r\n * @param value Value to validate\r\n * @param prefixes prefix the value should have\r\n */\n\n\nfunction validatePrefixedValue(value, prefixes) {\n  const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);\n\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  const prefixKey = match[0];\n\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  } // Remove annotation from contract address before doing the validation\n\n\n  const contractAddress = /^(KT1\\w{33})(%(.*))?/.exec(value);\n\n  if (contractAddress) {\n    value = contractAddress[1];\n  } // decodeUnsafe return undefined if decoding fail\n\n\n  let decoded = bs58check.decodeUnsafe(value);\n\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n\n  decoded = decoded.slice(prefix[prefixKey].length);\n\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n\n  return ValidationResult.VALID;\n}\n\nconst implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3, Prefix.TZ4];\nconst contractPrefix = [Prefix.KT1, Prefix.TXR1];\nconst signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nconst pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK];\nconst operationPrefix = [Prefix.O];\nconst protocolPrefix = [Prefix.P];\nconst blockPrefix = [Prefix.B];\n/**\r\n * @description Used to check if an address or a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateAddress } from '@taquito/utils';\r\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateAddress(pkh)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\nfunction validateAddress(value) {\n  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);\n}\n/**\r\n * @description Used to check if a chain id is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateChain } from '@taquito/utils';\r\n * const chainId = 'NetXdQprcVkpaWU'\r\n * const validation = validateChain(chainId)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateChain(value) {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n/**\r\n * @description Used to check if a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateContractAddress } from '@taquito/utils';\r\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\r\n * const validation = validateContractAddress(contractAddress)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateContractAddress(value) {\n  return validatePrefixedValue(value, contractPrefix);\n}\n/**\r\n * @description Used to check if a key hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateKeyHash } from '@taquito/utils';\r\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateKeyHash(keyHashWithoutPrefix)\r\n * console.log(validation)\r\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\r\n * ```\r\n */\n\n\nfunction validateKeyHash(value) {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n/**\r\n * @description Used to check if a signature is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateSignature } from '@taquito/utils';\r\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\r\n * const validation = validateSignature(signature)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateSignature(value) {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n/**\r\n * @description Used to check if a public key is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validatePublicKey } from '@taquito/utils';\r\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\r\n * const validation = validatePublicKey(publicKey)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validatePublicKey(value) {\n  return validatePrefixedValue(value, pkPrefix);\n}\n/**\r\n * @description Used to check if an operation hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateOperation } from '@taquito/utils';\r\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\r\n * const validation = validateOperation(operationHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateOperation(value) {\n  return validatePrefixedValue(value, operationPrefix);\n}\n/**\r\n * @description Used to check if a protocol hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateProtocol } from '@taquito/utils';\r\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\r\n * const validation = validateProtocol(protocolHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateProtocol(value) {\n  return validatePrefixedValue(value, protocolPrefix);\n}\n/**\r\n * @description Used to check if a block hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateBlock } from '@taquito/utils';\r\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\r\n * const validation = validateBlock(blockHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateBlock(value) {\n  return validatePrefixedValue(value, blockPrefix);\n} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n\nconst VERSION = {\n  \"commitHash\": \"38da814ec2bb4e81c7ad5a45b6b183a4d0b8dc25\",\n  \"version\": \"12.1.1\"\n};\n/**\r\n * @packageDocumentation\r\n * @module @taquito/utils\r\n */\n\n/**\r\n *\r\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\r\n *\r\n * @param value Value in hex\r\n */\n\nfunction encodeExpr(value) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n/**\r\n *\r\n * @description Return the operation hash of a signed operation\r\n * @param value Value in hex of a signed operation\r\n */\n\n\nfunction encodeOpHash(value) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n/**\r\n *\r\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\r\n *\r\n * @param value Value to base58 encode\r\n * @param prefix prefix to append to the encoded string\r\n */\n\n\nfunction b58cencode(value, prefix) {\n  const payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n  const n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n/**\r\n *\r\n * @description Base58 decode a string and remove the prefix from it\r\n *\r\n * @param value Value to base58 decode\r\n * @param prefix prefix to remove from the decoded string\r\n */\n\n\nconst b58cdecode = (enc, prefixArg) => bs58check.decode(enc).slice(prefixArg.length);\n/**\r\n *\r\n * @description Base58 decode a string with predefined prefix\r\n *\r\n * @param value Value to base58 decode\r\n */\n\n\nfunction b58decode(payload) {\n  const buf = bs58check.decode(payload);\n  const prefixMap = {\n    [prefix.tz1.toString()]: '0000',\n    [prefix.tz2.toString()]: '0001',\n    [prefix.tz3.toString()]: '0002'\n  };\n  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n\n  if (pref) {\n    // tz addresses\n    const hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n/**\r\n *\r\n * @description Base58 encode an address using predefined prefix\r\n *\r\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\r\n */\n\n\nfunction encodePubKey(value) {\n  if (value.substring(0, 2) === '00') {\n    const pref = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3\n    };\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  }\n\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n/**\r\n *\r\n * @description Base58 encode a key according to its prefix\r\n *\r\n * @param value Key to base58 encode\r\n */\n\n\nfunction encodeKey(value) {\n  if (value[0] === '0') {\n    const pref = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Base58 encode a key hash according to its prefix\r\n *\r\n * @param value Key hash to base58 encode\r\n */\n\n\nfunction encodeKeyHash(value) {\n  if (value[0] === '0') {\n    const pref = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Convert an hex string to a Uint8Array\r\n *\r\n * @param hex Hex string to convert\r\n */\n\n\nconst hex2buf = hex => {\n  const match = hex.match(/[\\da-f]{2}/gi);\n\n  if (match) {\n    return new Uint8Array(match.map(h => parseInt(h, 16)));\n  } else {\n    throw new ValueConversionError(hex, 'Uint8Array');\n  }\n};\n/**\r\n *\r\n * @description Merge 2 buffers together\r\n *\r\n * @param b1 First buffer\r\n * @param b2 Second buffer\r\n */\n\n\nconst mergebuf = (b1, b2) => {\n  const r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n/**\r\n *\r\n * @description Flatten a michelson json representation to an array\r\n *\r\n * @param s michelson json\r\n */\n// TODO Zainen check use\n\n\nconst mic2arr = function me2(s) {\n  let ret = [];\n\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1])\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    const sc = s.length;\n\n    for (let i = 0; i < sc; i++) {\n      const n = me2(s[i]);\n\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: []\n          };\n        }\n\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n\n  return ret;\n};\n/**\r\n *\r\n * @description Convert a buffer to an hex string\r\n *\r\n * @param buffer Buffer to convert\r\n */\n\n\nconst buf2hex = buffer => {\n  const byteArray = new Uint8Array(buffer);\n  const hexParts = [];\n  byteArray.forEach(byte => {\n    const hex = byte.toString(16);\n    const paddedHex = `00${hex}`.slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n/**\r\n *\r\n *  @description Gets Tezos address (PKH) from Public Key\r\n *\r\n *  @param publicKey Public Key\r\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\r\n */\n\n\nconst getPkhfromPk = publicKey => {\n  let encodingPrefix;\n  let prefixLen;\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decoded = b58cdecode(publicKey, prefix[keyPrefix]);\n\n  switch (keyPrefix) {\n    case Prefix.EDPK:\n      encodingPrefix = prefix[Prefix.TZ1];\n      prefixLen = prefixLength[Prefix.TZ1];\n      break;\n\n    case Prefix.SPPK:\n      encodingPrefix = prefix[Prefix.TZ2];\n      prefixLen = prefixLength[Prefix.TZ2];\n      break;\n\n    case Prefix.P2PK:\n      encodingPrefix = prefix[Prefix.TZ3];\n      prefixLen = prefixLength[Prefix.TZ3];\n      break;\n  }\n\n  const hashed = hash(decoded, prefixLen);\n  const result = b58cencode(hashed, encodingPrefix);\n  return result;\n};\n/**\r\n *\r\n * @description Convert a string to bytes\r\n *\r\n * @param str String to convert\r\n */\n\n\nfunction char2Bytes(str) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n/**\r\n *\r\n * @description Convert bytes to a string\r\n *\r\n * @param str Bytes to convert\r\n */\n\n\nfunction bytes2Char(hex) {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\n\nexport { DeprecationError, InvalidAddressError, InvalidBlockHashError, InvalidChainIdError, InvalidContractAddressError, InvalidKeyError, InvalidKeyHashError, InvalidMessageError, InvalidOperationHashError, InvalidOperationKindError, InvalidProtocolHashError, InvalidPublicKeyError, InvalidSignatureError, Prefix, ProhibitedActionError, VERSION, ValidationResult, ValueConversionError, b58cdecode, b58cencode, b58decode, buf2hex, bytes2Char, char2Bytes, encodeExpr, encodeKey, encodeKeyHash, encodeOpHash, encodePubKey, getPkhfromPk, hex2buf, isValidPrefix, mergebuf, mic2arr, prefix, prefixLength, validateAddress, validateBlock, validateChain, validateContractAddress, validateKeyHash, validateOperation, validatePkAndExtractPrefix, validateProtocol, validatePublicKey, validateSignature, verifySignature };","map":{"version":3,"sources":["../src/constants.ts","../src/errors.ts","../src/verify-signature.ts","../src/validators.ts","../src/version.ts","../src/taquito-utils.ts"],"names":[],"mappings":";;;;;;;IAAY,M;;AAAZ,CAAA,UAAY,MAAZ,EAAkB;EAChB,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,IAAA,CAAA,GAAA,IAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EAEA,MAAA,CAAA,OAAA,CAAA,GAAA,OAAA;EACA,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;EACA,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;EAEA,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;EACA,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;EACA,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;EAEA,MAAA,CAAA,OAAA,CAAA,GAAA,OAAA;EACA,MAAA,CAAA,OAAA,CAAA,GAAA,OAAA;EACA,MAAA,CAAA,OAAA,CAAA,GAAA,OAAA;EAEA,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;EACA,MAAA,CAAA,OAAA,CAAA,GAAA,OAAA;EACA,MAAA,CAAA,OAAA,CAAA,GAAA,OAAA;EACA,MAAA,CAAA,OAAA,CAAA,GAAA,OAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EAEA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,GAAA,CAAA,GAAA,GAAA;EACA,MAAA,CAAA,GAAA,CAAA,GAAA,GAAA;EACA,MAAA,CAAA,IAAA,CAAA,GAAA,IAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,GAAA,CAAA,GAAA,GAAA;EACA,MAAA,CAAA,IAAA,CAAA,GAAA,IAAA;EACA,MAAA,CAAA,IAAA,CAAA,GAAA,IAAA;EAEA,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;EACA,MAAA,CAAA,IAAA,CAAA,GAAA,IAAA;EAEA,MAAA,CAAA,IAAA,CAAA,GAAA,IAAA,CAvCgB,C;;EA0ChB,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;EACA,MAAA,CAAA,MAAA,CAAA,GAAA,KAAA;EACA,MAAA,CAAA,KAAA,CAAA,GAAA,KAAA;AAED,CAlDD,EAAY,MAAM,KAAN,MAAM,GAAA,EAAA,CAAlB;;MAoDa,MAAM,GAAG;EACpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,CAAf,CADM;EAEpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,CAAf,CAFM;EAGpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,CAAf,CAHM;EAIpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,CAAf,CAJM;EAKpB,CAAC,MAAM,CAAC,EAAR,GAAa,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,EAAJ,EAAQ,GAAR,CAAf,CALO;EAMpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,EAAJ,EAAQ,GAAR,CAAf,CANM;EAQpB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,EAAV,EAAc,CAAd,CAAf,CARK;EASpB,CAAC,MAAM,CAAC,KAAR,GAAgB,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,CAAb,CAAf,CATI;EAUpB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,EAAe,GAAf,CAAf,CAVK;EAWpB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,EAAL,EAAS,GAAT,EAAc,GAAd,CAAf,CAXK;EAapB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,GAAb,CAAf,CAbK;EAcpB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,EAAd,CAAf,CAdK;EAepB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,GAAd,CAAf,CAfK;EAiBpB,CAAC,MAAM,CAAC,KAAR,GAAgB,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,EAAJ,EAAQ,EAAR,EAAY,GAAZ,EAAiB,EAAjB,CAAf,CAjBI;EAkBpB,CAAC,MAAM,CAAC,KAAR,GAAgB,IAAI,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,CAAf,CAlBI;EAmBpB,CAAC,MAAM,CAAC,KAAR,GAAgB,IAAI,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,CAAf,CAnBI;EAqBpB,CAAC,MAAM,CAAC,KAAR,GAAgB,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,GAAd,EAAmB,EAAnB,CAAf,CArBI;EAsBpB,CAAC,MAAM,CAAC,KAAR,GAAgB,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,EAAe,EAAf,EAAmB,EAAnB,CAAf,CAtBI;EAuBpB,CAAC,MAAM,CAAC,KAAR,GAAgB,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,EAAV,EAAc,EAAd,CAAf,CAvBI;EAwBpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,EAAT,CAAf,CAxBM;EA0BpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,EAAL,EAAS,CAAT,CAAf,CA1BM;EA2BpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,CAAf,CA3BM;EA4BpB,CAAC,MAAM,CAAC,CAAR,GAAY,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,EAAJ,CAAf,CA5BQ;EA6BpB,CAAC,MAAM,CAAC,CAAR,GAAY,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,CAAf,CA7BQ;EA8BpB,CAAC,MAAM,CAAC,EAAR,GAAa,IAAI,UAAJ,CAAe,CAAC,GAAD,EAAM,GAAN,CAAf,CA9BO;EA+BpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,CAAf,CA/BM;EAgCpB,CAAC,MAAM,CAAC,CAAR,GAAY,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,CAAf,CAhCQ;EAiCpB,CAAC,MAAM,CAAC,EAAR,GAAa,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,CAAf,CAjCO;EAkCpB,CAAC,MAAM,CAAC,EAAR,GAAa,IAAI,UAAJ,CAAe,CAAC,GAAD,EAAM,GAAN,CAAf,CAlCO;EAoCpB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,CAAf,CApCK;;EAsCpB,CAAC,MAAM,CAAC,EAAR,GAAa,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,EAAJ,EAAQ,GAAR,CAAf,CAtCO;EAwCpB,CAAC,MAAM,CAAC,EAAR,GAAa,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,CAAf,CAxCO;EA0CpB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,EAAd,CAAf,CA1CK;EA2CpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,CAAf,CA3CM;EA4CpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,EAAV,CAAf,CA5CM;EA6CpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,EAAV,CAAf,CA7CM;EA8CpB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,CAAL,EAAQ,GAAR,EAAa,EAAb,CAAf,CA9CK;EA+CpB,CAAC,MAAM,CAAC,IAAR,GAAe,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,EAAV,CAAf,CA/CK;EAgDpB,CAAC,MAAM,CAAC,GAAR,GAAc,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,EAAV,CAAf;AAhDM,C;MAoDT,YAAY,GAA8B;EACrD,CAAC,MAAM,CAAC,GAAR,GAAc,EADuC;EAErD,CAAC,MAAM,CAAC,GAAR,GAAc,EAFuC;EAGrD,CAAC,MAAM,CAAC,GAAR,GAAc,EAHuC;EAIrD,CAAC,MAAM,CAAC,GAAR,GAAc,EAJuC;EAKrD,CAAC,MAAM,CAAC,EAAR,GAAa,EALwC;EAMrD,CAAC,MAAM,CAAC,GAAR,GAAc,EANuC;EAQrD,CAAC,MAAM,CAAC,IAAR,GAAe,EARsC;EASrD,CAAC,MAAM,CAAC,IAAR,GAAe,EATsC;EAUrD,CAAC,MAAM,CAAC,IAAR,GAAe,EAVsC;EAWrD,CAAC,MAAM,CAAC,KAAR,GAAgB,EAXqC;EAYrD,CAAC,MAAM,CAAC,KAAR,GAAgB,EAZqC;EAarD,CAAC,MAAM,CAAC,KAAR,GAAgB,EAbqC;EAcrD,CAAC,MAAM,CAAC,GAAR,GAAc,EAduC;EAerD,CAAC,MAAM,CAAC,GAAR,GAAc,CAfuC;EAgBrD,CAAC,MAAM,CAAC,CAAR,GAAY,EAhByC;EAiBrD,CAAC,MAAM,CAAC,CAAR,GAAY,EAjByC;EAkBrD,CAAC,MAAM,CAAC,CAAR,GAAY,EAlByC;EAmBrD,CAAC,MAAM,CAAC,EAAR,GAAa,EAnBwC;EAoBrD,CAAC,MAAM,CAAC,IAAR,GAAe,EApBsC;EAqBrD,CAAC,MAAM,CAAC,GAAR,GAAc,EArBuC;EAsBrD,CAAC,MAAM,CAAC,GAAR,GAAc,EAtBuC;EAuBrD,CAAC,MAAM,CAAC,GAAR,GAAc,EAvBuC;EAwBrD,CAAC,MAAM,CAAC,IAAR,GAAe,EAxBsC;EAyBrD,CAAC,MAAM,CAAC,IAAR,GAAe,EAzBsC;EA0BrD,CAAC,MAAM,CAAC,GAAR,GAAc;AA1BuC,C;ACxGvD;;;;;MAIa,e,SAAwB,K,CAAK;EAExC,WAAA,CAAmB,GAAnB,EAAuC,WAAvC,EAA2D;IACzD,MAAM,WAAW,GAAG,gBAAgB,WAAW,EAA/C;IADiB,KAAA,GAAA,GAAA,GAAA;IAAoB,KAAA,WAAA,GAAA,WAAA;IADhC,KAAA,IAAA,GAAO,iBAAP;EAGN;;AAJuC;AAO1C;;;;;;MAIa,qB,SAA8B,K,CAAK;EAE9C,WAAA,CAAmB,SAAnB,EAAsC,WAAtC,EAA0D;IACxD,MAAM,mBAAmB,SAAS,iBAAiB,WAAW,EAA9D;IADiB,KAAA,SAAA,GAAA,SAAA;IADZ,KAAA,IAAA,GAAO,uBAAP;EAGN;;AAJ6C;AAOhD;;;;;;MAIa,qB,SAA8B,K,CAAK;EAE9C,WAAA,CAAmB,SAAnB,EAAsC,WAAtC,EAA0D;IACxD,MAAM,kBAAkB,SAAS,iBAAiB,WAAW,GAA7D;IADiB,KAAA,SAAA,GAAA,SAAA;IADZ,KAAA,IAAA,GAAO,uBAAP;EAGN;;AAJ6C;AAOhD;;;;;;MAIa,mB,SAA4B,K,CAAK;EAE5C,WAAA,CAAmB,GAAnB,EAAuC,WAAvC,EAA2D;IACzD,MAAM,gBAAgB,GAAG,iBAAiB,WAAW,EAArD;IADiB,KAAA,GAAA,GAAA,GAAA;IAAoB,KAAA,WAAA,GAAA,WAAA;IADhC,KAAA,IAAA,GAAO,qBAAP;EAGN;;AAJ2C;AAO9C;;;;;;MAIa,2B,SAAoC,K,CAAK;EAEpD,WAAA,CAAmB,eAAnB,EAA0C;IACxC,MAAM,yBAAyB,eAAe,cAA9C;IADiB,KAAA,eAAA,GAAA,eAAA;IADZ,KAAA,IAAA,GAAO,6BAAP;EAGN;;AAJmD;AAOtD;;;;;;MAIa,mB,SAA4B,K,CAAK;EAE5C,WAAA,CAAmB,OAAnB,EAAkC;IAChC,MAAM,gBAAgB,OAAO,cAA7B;IADiB,KAAA,OAAA,GAAA,OAAA;IADZ,KAAA,IAAA,GAAO,qBAAP;EAGN;;AAJ2C;AAO9C;;;;;;MAIa,mB,SAA4B,K,CAAK;EAE5C,WAAA,CAAmB,OAAnB,EAAkC;IAChC,MAAM,iBAAiB,OAAO,cAA9B;IADiB,KAAA,OAAA,GAAA,OAAA;IADZ,KAAA,IAAA,GAAO,qBAAP;EAGN;;AAJ2C;AAO9C;;;;;;MAIa,mB,SAA4B,K,CAAK;EAE5C,WAAA,CAAmB,OAAnB,EAAkC;IAChC,MAAM,wBAAwB,OAAO,cAArC;IADiB,KAAA,OAAA,GAAA,OAAA;IADZ,KAAA,IAAA,GAAO,qBAAP;EAGN;;AAJ2C;AAO9C;;;;;;MAGiB,qB,SAA8B,K,CAAK;EAElD,WAAA,CAAmB,SAAnB,EAAoC;IAClC,MAAM,mBAAmB,SAAS,cAAlC;IADiB,KAAA,SAAA,GAAA,SAAA;IADZ,KAAA,IAAA,GAAO,uBAAP;EAGN;;AAJiD;AAOpD;;;;;;MAIa,wB,SAAiC,K,CAAK;EAEjD,WAAA,CAAmB,YAAnB,EAAuC;IACrC,MAAM,sBAAsB,YAAY,cAAxC;IADiB,KAAA,YAAA,GAAA,YAAA;IADZ,KAAA,IAAA,GAAO,0BAAP;EAGN;;AAJgD;AAOnD;;;;;;MAGiB,yB,SAAkC,K,CAAK;EAEtD,WAAA,CAAmB,aAAnB,EAAwC;IACtC,MAAM,uBAAuB,aAAa,cAA1C;IADiB,KAAA,aAAA,GAAA,aAAA;IADZ,KAAA,IAAA,GAAO,2BAAP;EAGN;;AAJqD;AAOxD;;;;;;MAIa,yB,SAAkC,K,CAAK;EAElD,WAAA,CAAmB,aAAnB,EAAwC;IACtC,MAAM,uBAAuB,aAAa,kBAA1C;IADiB,KAAA,aAAA,GAAA,aAAA;IADZ,KAAA,IAAA,GAAO,2BAAP;EAGN;;AAJiD;AAOpD;;;;;;MAIa,gB,SAAyB,K,CAAK;EAEzC,WAAA,CAAmB,OAAnB,EAAkC;IAChC,MAAM,OAAN;IADiB,KAAA,OAAA,GAAA,OAAA;IADZ,KAAA,IAAA,GAAO,kBAAP;EAGN;;AAJwC;AAO3C;;;;;;MAIa,qB,SAA8B,K,CAAK;EAE9C,WAAA,CAAmB,OAAnB,EAAkC;IAChC,MAAM,OAAN;IADiB,KAAA,OAAA,GAAA,OAAA;IADZ,KAAA,IAAA,GAAO,uBAAP;EAGN;;AAJ6C;AAOhD;;;;;;MAIa,oB,SAA6B,K,CAAK;EAE7C,WAAA,CAAmB,KAAnB,EAAyC,WAAzC,EAA4D;IAC1D,MAAM,qBAAqB,KAAK,SAAS,WAAW,EAApD;IADiB,KAAA,KAAA,GAAA,KAAA;IAAsB,KAAA,WAAA,GAAA,WAAA;IADlC,KAAA,IAAA,GAAO,sBAAP;EAGN;;AAJ4C;ACzI/C;;;;;;;;;;;;;;;;;;;;;SAmBgB,e,CACd,Y,EACA,S,EACA,S,EAAiB;EAEjB,MAAM,QAAQ,GAAG,0BAA0B,CAAC,SAAD,CAA3C;EACA,MAAM,SAAS,GAAG,2BAA2B,CAAC,SAAD,CAA7C;EAEA,MAAM,gBAAgB,GAAG,UAAU,CAAC,SAAD,EAAY,MAAM,CAAC,QAAD,CAAlB,CAAnC;EACA,MAAM,UAAU,GAAG,UAAU,CAAC,SAAD,EAAY,MAAM,CAAC,SAAD,CAAlB,CAA7B;EACA,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,YAAD,CAAxB,CAAR,EAAiD,EAAjD,CAAtB;;EAEA,IAAI,QAAQ,KAAK,MAAM,CAAC,IAAxB,EAA8B;IAC5B,OAAO,iBAAiB,CAAC,UAAD,EAAa,SAAb,EAAwB,gBAAxB,CAAxB;EACD,CAFD,MAEO,IAAI,QAAQ,KAAK,MAAM,CAAC,IAAxB,EAA8B;IACnC,OAAO,iBAAiB,CAAC,UAAD,EAAa,SAAb,EAAwB,gBAAxB,CAAxB;EACD,CAFM,MAEA,IAAI,QAAQ,KAAK,MAAM,CAAC,IAAxB,EAA8B;IACnC,OAAO,iBAAiB,CAAC,UAAD,EAAa,SAAb,EAAwB,gBAAxB,CAAxB;EACD,CAFM,MAEA;IACL,OAAO,KAAP;EACD;AACF;;AAED,SAAS,uBAAT,CAAiC,OAAjC,EAAgD;EAC9C,IAAI,OAAO,KAAK,EAAhB,EAAoB;IAClB,MAAM,IAAI,mBAAJ,CACJ,OADI,EAEJ,+DAFI,CAAN;EAID;;EACD,OAAO,OAAP;AACD;;SAEe,0B,CAA2B,S,EAAiB;EAC1D,IAAI,SAAS,KAAK,EAAlB,EAAsB;IACpB,MAAM,IAAI,qBAAJ,CAA0B,SAA1B,EAAqC,4BAArC,CAAN;EACD;;EACD,MAAM,QAAQ,GAAG,SAAS,CAAC,SAAV,CAAoB,CAApB,EAAuB,CAAvB,CAAjB;EACA,MAAM,UAAU,GAAG,iBAAiB,CAAC,SAAD,CAApC;;EACA,IAAI,UAAU,KAAK,gBAAgB,CAAC,KAApC,EAA2C;IACzC,IAAI,UAAU,KAAK,gBAAgB,CAAC,gBAApC,EAAsD;MACpD,MAAM,IAAI,qBAAJ,CAA0B,SAA1B,EAAqC,iDAArC,CAAN;IACD,CAFD,MAEO,IAAI,UAAU,KAAK,gBAAgB,CAAC,cAApC,EAAoD;MACzD,MAAM,IAAI,qBAAJ,CAA0B,SAA1B,EAAqC,+CAArC,CAAN;IACD,CAFM,MAEA,IAAI,UAAU,KAAK,gBAAgB,CAAC,iBAApC,EAAuD;MAC5D,MAAM,IAAI,qBAAJ,CACJ,SADI,EAEJ,sDAAsD,QAAQ,EAF1D,CAAN;IAID;EACF;;EACD,OAAO,QAAP;AACD;;AAED,SAAS,2BAAT,CAAqC,SAArC,EAAsD;EACpD,MAAM,eAAe,GAAG,SAAS,CAAC,UAAV,CAAqB,KAArB,IACpB,SAAS,CAAC,MAAV,CAAiB,CAAjB,EAAoB,CAApB,CADoB,GAEpB,SAAS,CAAC,MAAV,CAAiB,CAAjB,EAAoB,CAApB,CAFJ;EAGA,MAAM,UAAU,GAAG,iBAAiB,CAAC,SAAD,CAApC;;EACA,IAAI,UAAU,KAAK,gBAAgB,CAAC,KAApC,EAA2C;IACzC,IAAI,UAAU,KAAK,gBAAgB,CAAC,gBAApC,EAAsD;MACpD,MAAM,IAAI,qBAAJ,CAA0B,SAA1B,EAAqC,kBAArC,CAAN;IACD,CAFD,MAEO,IAAI,UAAU,KAAK,gBAAgB,CAAC,cAApC,EAAoD;MACzD,MAAM,IAAI,qBAAJ,CAA0B,SAA1B,EAAqC,gBAArC,CAAN;IACD,CAFM,MAEA,IAAI,UAAU,KAAK,gBAAgB,CAAC,iBAApC,EAAuD;MAC5D,MAAM,IAAI,qBAAJ,CAA0B,eAA1B,EAA2C,oBAA3C,CAAN;IACD;EACF;;EACD,OAAO,eAAP;AACD;;AAED,SAAS,iBAAT,CACE,UADF,EAEE,SAFF,EAGE,gBAHF,EAG8B;EAE5B,IAAI;IACF,OAAO,MAAM,CAAC,gBAAD,EAAmB,SAAnB,EAA8B,UAA9B,CAAb;EACD,CAFD,CAEE,OAAO,CAAP,EAAU;IACV,OAAO,KAAP;EACD;AACF;;AAED,SAAS,iBAAT,CACE,UADF,EAEE,SAFF,EAGE,gBAHF,EAG8B;EAE5B,MAAM,GAAG,GAAG,IAAI,QAAQ,CAAC,EAAb,CAAgB,WAAhB,EAA6B,aAA7B,CAA2C,gBAA3C,CAAZ;EACA,OAAO,eAAe,CAAC,UAAD,EAAa,SAAb,EAAwB,GAAxB,CAAtB;AACD;;AAED,SAAS,iBAAT,CACE,UADF,EAEE,SAFF,EAGE,gBAHF,EAG8B;EAE5B,MAAM,GAAG,GAAG,IAAI,QAAQ,CAAC,EAAb,CAAgB,MAAhB,EAAwB,aAAxB,CAAsC,gBAAtC,CAAZ;EACA,OAAO,eAAe,CAAC,UAAD,EAAa,SAAb,EAAwB,GAAxB,CAAtB;AACD;;AAED,SAAS,eAAT,CAAyB,UAAzB,EAAiD,SAAjD,EAAwE,GAAxE,EAAgG;EAC9F,MAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,UAAD,CAAT,CAAtB;EACA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAP,CAAa,iBAAb,CAAd;;EACA,IAAI,KAAJ,EAAW;IACT,IAAI;MACF,MAAM,CAAC,CAAD,EAAI,CAAJ,IAAS,KAAf;MACA,OAAO,GAAG,CAAC,MAAJ,CAAW,SAAX,EAAsB;QAAE,CAAF;QAAK;MAAL,CAAtB,CAAP;IACD,CAHD,CAGE,OAAO,CAAP,EAAU;MACV,OAAO,KAAP;IACD;EACF;;EACD,OAAO,KAAP;AACF;;ICnJY,gB;;AAAZ,CAAA,UAAY,gBAAZ,EAA4B;EAC1B,gBAAA,CAAA,gBAAA,CAAA,mBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,mBAAA;EACA,gBAAA,CAAA,gBAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAA;EACA,gBAAA,CAAA,gBAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,gBAAA;EACA,gBAAA,CAAA,gBAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACD,CALD,EAAY,gBAAgB,KAAhB,gBAAgB,GAAA,EAAA,CAA5B;;SAOgB,a,CAAc,K,EAAc;EAC1C,IAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;IAC7B,OAAO,KAAP;EACD;;EAED,OAAO,KAAK,IAAI,MAAhB;AACD;AACD;;;;;;;;;;;;AAUA,SAAS,qBAAT,CAA+B,KAA/B,EAA8C,QAA9C,EAAgE;EAE9D,MAAM,KAAK,GAAG,IAAI,MAAJ,CAAW,KAAK,QAAQ,CAAC,IAAT,CAAc,GAAd,CAAkB,GAAlC,EAAuC,IAAvC,CAA4C,KAA5C,CAAd;;EACA,IAAI,CAAC,KAAD,IAAU,KAAK,CAAC,MAAN,KAAiB,CAA/B,EAAkC;IAChC,OAAO,gBAAgB,CAAC,iBAAxB;EACD;;EAED,MAAM,SAAS,GAAG,KAAK,CAAC,CAAD,CAAvB;;EAEA,IAAI,CAAC,aAAa,CAAC,SAAD,CAAlB,EAA+B;IAC7B,OAAO,gBAAgB,CAAC,iBAAxB;EACD,CAX6D,C;;;EAc9D,MAAM,eAAe,GAAG,uBAAuB,IAAvB,CAA4B,KAA5B,CAAxB;;EACA,IAAI,eAAJ,EAAqB;IACnB,KAAK,GAAG,eAAe,CAAC,CAAD,CAAvB;EACD,CAjB6D,C;;;EAoB9D,IAAI,OAAO,GAAG,SAAS,CAAC,YAAV,CAAuB,KAAvB,CAAd;;EACA,IAAI,CAAC,OAAL,EAAc;IACZ,OAAO,gBAAgB,CAAC,gBAAxB;EACD;;EAED,OAAO,GAAG,OAAO,CAAC,KAAR,CAAc,MAAM,CAAC,SAAD,CAAN,CAAkB,MAAhC,CAAV;;EACA,IAAI,OAAO,CAAC,MAAR,KAAmB,YAAY,CAAC,SAAD,CAAnC,EAAgD;IAC9C,OAAO,gBAAgB,CAAC,cAAxB;EACD;;EAED,OAAO,gBAAgB,CAAC,KAAxB;AACD;;AAED,MAAM,cAAc,GAAG,CAAC,MAAM,CAAC,GAAR,EAAa,MAAM,CAAC,GAApB,EAAyB,MAAM,CAAC,GAAhC,EAAoC,MAAM,CAAC,GAA3C,CAAvB;AACA,MAAM,cAAc,GAAG,CAAC,MAAM,CAAC,GAAR,EAAY,MAAM,CAAC,IAAnB,CAAvB;AACA,MAAM,eAAe,GAAG,CAAC,MAAM,CAAC,KAAR,EAAe,MAAM,CAAC,KAAtB,EAA6B,MAAM,CAAC,KAApC,EAA2C,MAAM,CAAC,GAAlD,CAAxB;AACA,MAAM,QAAQ,GAAG,CAAC,MAAM,CAAC,IAAR,EAAc,MAAM,CAAC,IAArB,EAA2B,MAAM,CAAC,IAAlC,CAAjB;AACA,MAAM,eAAe,GAAG,CAAC,MAAM,CAAC,CAAR,CAAxB;AACA,MAAM,cAAc,GAAG,CAAC,MAAM,CAAC,CAAR,CAAvB;AACA,MAAM,WAAW,GAAG,CAAC,MAAM,CAAC,CAAR,CAApB;AAEA;;;;;;;;;;;;;;;;SAegB,e,CAAgB,K,EAAa;EAC3C,OAAO,qBAAqB,CAAC,KAAD,EAAQ,CAAC,GAAG,cAAJ,EAAoB,GAAG,cAAvB,CAAR,CAA5B;AACD;AAED;;;;;;;;;;;;;;;;;SAegB,a,CAAc,K,EAAa;EACzC,OAAO,qBAAqB,CAAC,KAAD,EAAQ,CAAC,MAAM,CAAC,GAAR,CAAR,CAA5B;AACD;AAED;;;;;;;;;;;;;;;;;SAegB,uB,CAAwB,K,EAAa;EACnD,OAAO,qBAAqB,CAAC,KAAD,EAAQ,cAAR,CAA5B;AACD;AAED;;;;;;;;;;;;;;;;;SAegB,e,CAAgB,K,EAAa;EAC3C,OAAO,qBAAqB,CAAC,KAAD,EAAQ,cAAR,CAA5B;AACD;AAED;;;;;;;;;;;;;;;;;SAegB,iB,CAAkB,K,EAAa;EAC7C,OAAO,qBAAqB,CAAC,KAAD,EAAQ,eAAR,CAA5B;AACD;AAED;;;;;;;;;;;;;;;;;SAegB,iB,CAAkB,K,EAAa;EAC7C,OAAO,qBAAqB,CAAC,KAAD,EAAQ,QAAR,CAA5B;AACD;AAED;;;;;;;;;;;;;;;;;SAegB,iB,CAAkB,K,EAAa;EAC7C,OAAO,qBAAqB,CAAC,KAAD,EAAQ,eAAR,CAA5B;AACD;AAED;;;;;;;;;;;;;;;;;SAegB,gB,CAAiB,K,EAAa;EAC5C,OAAO,qBAAqB,CAAC,KAAD,EAAQ,cAAR,CAA5B;AACD;AAED;;;;;;;;;;;;;;;;;SAegB,a,CAAc,K,EAAa;EACzC,OAAO,qBAAqB,CAAC,KAAD,EAAQ,WAAR,CAA5B;AACF,C,CC7OA;;;MACa,OAAO,GAAG;EACnB,cAAc,0CADK;EAEnB,WAAW;AAFQ,C;ACFvB;;;;;AA2BA;;;;;;;SAMgB,U,CAAW,K,EAAa;EACtC,MAAM,SAAS,GAAG,KAAK,CAAC,OAAN,CAAc,OAAO,CAAC,KAAD,CAArB,EAA8B,SAA9B,EAAyC,EAAzC,CAAlB;EACA,OAAO,UAAU,CAAC,SAAD,EAAY,MAAM,CAAC,MAAD,CAAlB,CAAjB;AACD;AAED;;;;;;;SAKgB,Y,CAAa,K,EAAa;EACxC,MAAM,SAAS,GAAG,KAAK,CAAC,OAAN,CAAc,OAAO,CAAC,KAAD,CAArB,EAA8B,SAA9B,EAAyC,EAAzC,CAAlB;EACA,OAAO,UAAU,CAAC,SAAD,EAAY,MAAM,CAAC,CAAnB,CAAjB;AACD;AAED;;;;;;;;;SAOgB,U,CAAW,K,EAA4B,M,EAAkB;EACvE,MAAM,SAAS,GAAG,OAAO,KAAP,KAAiB,QAAjB,GAA4B,UAAU,CAAC,IAAX,CAAgB,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,KAAnB,CAAhB,CAA5B,GAAyE,KAA3F;EAEA,MAAM,CAAC,GAAG,IAAI,UAAJ,CAAe,MAAM,CAAC,MAAP,GAAgB,SAAS,CAAC,MAAzC,CAAV;EACA,CAAC,CAAC,GAAF,CAAM,MAAN;EACA,CAAC,CAAC,GAAF,CAAM,SAAN,EAAiB,MAAM,CAAC,MAAxB;EAEA,OAAO,SAAS,CAAC,MAAV,CAAiB,MAAM,CAAC,IAAP,CAAY,CAAC,CAAC,MAAd,CAAjB,CAAP;AACD;AAED;;;;;;;;;MAOa,UAAU,GAAG,CAAC,GAAD,EAAc,SAAd,KACxB,SAAS,CAAC,MAAV,CAAiB,GAAjB,EAAsB,KAAtB,CAA4B,SAAS,CAAC,MAAtC,C;AAEF;;;;;;;;SAMgB,S,CAAU,O,EAAe;EACvC,MAAM,GAAG,GAAW,SAAS,CAAC,MAAV,CAAiB,OAAjB,CAApB;EAEA,MAAM,SAAS,GAAG;IAChB,CAAC,MAAM,CAAC,GAAP,CAAW,QAAX,EAAD,GAAyB,MADT;IAEhB,CAAC,MAAM,CAAC,GAAP,CAAW,QAAX,EAAD,GAAyB,MAFT;IAGhB,CAAC,MAAM,CAAC,GAAP,CAAW,QAAX,EAAD,GAAyB;EAHT,CAAlB;EAMA,MAAM,IAAI,GAAG,SAAS,CAAC,IAAI,UAAJ,CAAe,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAf,EAAgC,QAAhC,EAAD,CAAtB;;EACA,IAAI,IAAJ,EAAU;;IAER,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,KAAJ,CAAU,CAAV,CAAD,CAAnB;IACA,OAAO,IAAI,GAAG,GAAd;EACD,CAJD,MAIO;;IAEL,OAAO,OAAO,OAAO,CAAC,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAa,EAAb,CAAD,CAAd,GAAmC,IAA1C;EACD;AACF;AAED;;;;;;;;SAMgB,Y,CAAa,K,EAAa;EACxC,IAAI,KAAK,CAAC,SAAN,CAAgB,CAAhB,EAAmB,CAAnB,MAA0B,IAA9B,EAAoC;IAClC,MAAM,IAAI,GAAkC;MAC1C,QAAQ,MAAM,CAAC,GAD2B;MAE1C,QAAQ,MAAM,CAAC,GAF2B;MAG1C,QAAQ,MAAM,CAAC;IAH2B,CAA5C;IAMA,OAAO,UAAU,CAAC,KAAK,CAAC,SAAN,CAAgB,CAAhB,CAAD,EAAqB,IAAI,CAAC,KAAK,CAAC,SAAN,CAAgB,CAAhB,EAAmB,CAAnB,CAAD,CAAzB,CAAjB;EACD;;EAED,OAAO,UAAU,CAAC,KAAK,CAAC,SAAN,CAAgB,CAAhB,EAAmB,EAAnB,CAAD,EAAyB,MAAM,CAAC,EAAhC,CAAjB;AACD;AAED;;;;;;;;SAMgB,S,CAAU,K,EAAa;EACrC,IAAI,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsB;IACpB,MAAM,IAAI,GAAkC;MAC1C,MAAM,IAAI,UAAJ,CAAe,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,GAAb,CAAf,CADoC;MAE1C,MAAM,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,EAAd,CAAf,CAFoC;MAG1C,MAAM,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,GAAd,CAAf;IAHoC,CAA5C;IAMA,OAAO,UAAU,CAAC,KAAK,CAAC,SAAN,CAAgB,CAAhB,CAAD,EAAqB,IAAI,CAAC,KAAK,CAAC,SAAN,CAAgB,CAAhB,EAAmB,CAAnB,CAAD,CAAzB,CAAjB;EACD;AACF;AAED;;;;;;;;SAMgB,a,CAAc,K,EAAa;EACzC,IAAI,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsB;IACpB,MAAM,IAAI,GAAkC;MAC1C,MAAM,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,CAAf,CADoC;MAE1C,MAAM,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,CAAf,CAFoC;MAG1C,MAAM,IAAI,UAAJ,CAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,CAAf;IAHoC,CAA5C;IAMA,OAAO,UAAU,CAAC,KAAK,CAAC,SAAN,CAAgB,CAAhB,CAAD,EAAqB,IAAI,CAAC,KAAK,CAAC,SAAN,CAAgB,CAAhB,EAAmB,CAAnB,CAAD,CAAzB,CAAjB;EACD;AACF;AAED;;;;;;;;MAMa,OAAO,GAAI,GAAD,IAAY;EACjC,MAAM,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,cAAV,CAAd;;EACA,IAAI,KAAJ,EAAW;IACT,OAAO,IAAI,UAAJ,CAAe,KAAK,CAAC,GAAN,CAAW,CAAD,IAAO,QAAQ,CAAC,CAAD,EAAI,EAAJ,CAAzB,CAAf,CAAP;EACD,CAFD,MAEO;IACL,MAAM,IAAI,oBAAJ,CAAyB,GAAzB,EAA8B,YAA9B,CAAN;EACD;AACH,C;AAEA;;;;;;;;;MAOa,QAAQ,GAAG,CAAC,EAAD,EAAiB,EAAjB,KAA+B;EACrD,MAAM,CAAC,GAAG,IAAI,UAAJ,CAAe,EAAE,CAAC,MAAH,GAAY,EAAE,CAAC,MAA9B,CAAV;EACA,CAAC,CAAC,GAAF,CAAM,EAAN;EACA,CAAC,CAAC,GAAF,CAAM,EAAN,EAAU,EAAE,CAAC,MAAb;EACA,OAAO,CAAP;AACF,C;AAEA;;;;;;AAOA;;;MACa,OAAO,GAAG,SAAS,GAAT,CAAa,CAAb,EAAmB;EACxC,IAAI,GAAG,GAAQ,EAAf;;EACA,IAAI,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,CAArC,EAAwC,MAAxC,CAAJ,EAAqD;IACnD,IAAI,CAAC,CAAC,IAAF,KAAW,MAAf,EAAuB;MACrB,GAAG,CAAC,IAAJ,CAAS,GAAG,CAAC,CAAC,CAAC,IAAF,CAAO,CAAP,CAAD,CAAZ;MACA,GAAG,GAAG,GAAG,CAAC,MAAJ,CAAW,GAAG,CAAC,CAAC,CAAC,IAAF,CAAO,CAAP,CAAD,CAAd,CAAN;IACD,CAHD,MAGO,IAAI,CAAC,CAAC,IAAF,KAAW,KAAf,EAAsB;MAC3B,GAAG,GAAG;QACJ,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,IAAF,CAAO,CAAP,CAAD,CADJ;QAEJ,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,IAAF,CAAO,CAAP,CAAD;MAFJ,CAAN;IAID,CALM,MAKA,IAAI,CAAC,CAAC,IAAF,KAAW,MAAf,EAAuB;MAC5B,GAAG,GAAG,IAAN;IACD,CAFM,MAEA,IAAI,CAAC,CAAC,IAAF,KAAW,OAAf,EAAwB;MAC7B,GAAG,GAAG,KAAN;IACD;EACF,CAdD,MAcO,IAAI,KAAK,CAAC,OAAN,CAAc,CAAd,CAAJ,EAAsB;IAC3B,MAAM,EAAE,GAAG,CAAC,CAAC,MAAb;;IACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,EAApB,EAAwB,CAAC,EAAzB,EAA6B;MAC3B,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAD,CAAF,CAAb;;MACA,IAAI,OAAO,CAAC,CAAC,GAAT,KAAiB,WAArB,EAAkC;QAChC,IAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB;UACtB,GAAG,GAAG;YACJ,IAAI,EAAE,EADF;YAEJ,IAAI,EAAE;UAFF,CAAN;QAID;;QACD,GAAG,CAAC,IAAJ,CAAS,IAAT,CAAc,CAAC,CAAC,GAAhB;QACA,GAAG,CAAC,IAAJ,CAAS,IAAT,CAAc,CAAC,CAAC,GAAhB;MACD,CATD,MASO;QACL,GAAG,CAAC,IAAJ,CAAS,CAAT;MACD;IACF;EACF,CAjBM,MAiBA,IAAI,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,CAArC,EAAwC,QAAxC,CAAJ,EAAuD;IAC5D,GAAG,GAAG,CAAC,CAAC,MAAR;EACD,CAFM,MAEA,IAAI,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,CAArC,EAAwC,KAAxC,CAAJ,EAAoD;IACzD,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAH,EAAQ,EAAR,CAAd;EACD,CAFM,MAEA;IACL,GAAG,GAAG,CAAN;EACD;;EACD,OAAO,GAAP;AACF,C;AAEA;;;;;;;;MAMa,OAAO,GAAI,MAAD,IAAe;EACpC,MAAM,SAAS,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAlB;EACA,MAAM,QAAQ,GAAa,EAA3B;EACA,SAAS,CAAC,OAAV,CAAmB,IAAD,IAAK;IACrB,MAAM,GAAG,GAAG,IAAI,CAAC,QAAL,CAAc,EAAd,CAAZ;IACA,MAAM,SAAS,GAAG,KAAK,GAAG,EAAR,CAAW,KAAX,CAAiB,CAAC,CAAlB,CAAlB;IACA,QAAQ,CAAC,IAAT,CAAc,SAAd;EACD,CAJD;EAKA,OAAO,QAAQ,CAAC,IAAT,CAAc,EAAd,CAAP;AACF,C;AAEA;;;;;;;;;MAOa,YAAY,GAAI,SAAD,IAAkB;EAC5C,IAAI,cAAJ;EACA,IAAI,SAAJ;EAEA,MAAM,SAAS,GAAG,0BAA0B,CAAC,SAAD,CAA5C;EACA,MAAM,OAAO,GAAG,UAAU,CAAC,SAAD,EAAY,MAAM,CAAC,SAAD,CAAlB,CAA1B;;EAEA,QAAQ,SAAR;IACE,KAAK,MAAM,CAAC,IAAZ;MACE,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,GAAR,CAAvB;MACA,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC,GAAR,CAAxB;MACA;;IACF,KAAK,MAAM,CAAC,IAAZ;MACE,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,GAAR,CAAvB;MACA,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC,GAAR,CAAxB;MACA;;IACF,KAAK,MAAM,CAAC,IAAZ;MACE,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,GAAR,CAAvB;MACA,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC,GAAR,CAAxB;MACA;EAZJ;;EAeA,MAAM,MAAM,GAAG,IAAI,CAAC,OAAD,EAAU,SAAV,CAAnB;EACA,MAAM,MAAM,GAAG,UAAU,CAAC,MAAD,EAAS,cAAT,CAAzB;EAEA,OAAO,MAAP;AACF,C;AAEA;;;;;;;;SAMgB,U,CAAW,G,EAAW;EACpC,OAAO,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,MAAjB,EAAyB,QAAzB,CAAkC,KAAlC,CAAP;AACD;AAED;;;;;;;;SAMgB,U,CAAW,G,EAAW;EACpC,OAAO,MAAM,CAAC,IAAP,CAAY,OAAO,CAAC,GAAD,CAAnB,EAA0B,QAA1B,CAAmC,MAAnC,CAAP;AACF","sourcesContent":["export enum Prefix {\n  TZ1 = 'tz1',\n  TZ2 = 'tz2',\n  TZ3 = 'tz3',\n  TZ4 = 'tz4',\n  KT = 'KT',\n  KT1 = 'KT1',\n\n  EDSK2 = 'edsk2',\n  SPSK = 'spsk',\n  P2SK = 'p2sk',\n\n  EDPK = 'edpk',\n  SPPK = 'sppk',\n  P2PK = 'p2pk',\n\n  EDESK = 'edesk',\n  SPESK = 'spesk',\n  P2ESK = 'p2esk',\n\n  EDSK = 'edsk',\n  EDSIG = 'edsig',\n  SPSIG = 'spsig',\n  P2SIG = 'p2sig',\n  SIG = 'sig',\n\n  NET = 'Net',\n  NCE = 'nce',\n  B = 'B',\n  O = 'o',\n  LO = 'Lo',\n  LLO = 'LLo',\n  P = 'P',\n  CO = 'Co',\n  ID = 'id',\n\n  EXPR = 'expr',\n  TZ = 'TZ',\n\n  VH = 'vh', // block_payload_hash\n\n  //rollups\n  TXR1 = 'txr1',\n  TXI = 'txi',\n  TXM = 'txm',\n  TXC = 'txc',\n  TXMR = 'txmr',\n  TXRL = 'txM',\n  TXW = 'txw',\n\n}\n\nexport const prefix = {\n  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),\n  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),\n  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),\n  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),\n  [Prefix.KT]: new Uint8Array([2, 90, 121]),\n  [Prefix.KT1]: new Uint8Array([2, 90, 121]),\n\n  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),\n  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),\n  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),\n  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),\n\n  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),\n  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),\n  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),\n\n  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),\n  [Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),\n  [Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),\n\n  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),\n  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),\n  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),\n  [Prefix.SIG]: new Uint8Array([4, 130, 43]),\n\n  [Prefix.NET]: new Uint8Array([87, 82, 0]),\n  [Prefix.NCE]: new Uint8Array([69, 220, 169]),\n  [Prefix.B]: new Uint8Array([1, 52]),\n  [Prefix.O]: new Uint8Array([5, 116]),\n  [Prefix.LO]: new Uint8Array([133, 233]),\n  [Prefix.LLO]: new Uint8Array([29, 159, 109]),\n  [Prefix.P]: new Uint8Array([2, 170]),\n  [Prefix.CO]: new Uint8Array([79, 179]),\n  [Prefix.ID]: new Uint8Array([153, 103]),\n\n  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),\n  // Legacy prefix\n  [Prefix.TZ]: new Uint8Array([2, 90, 121]),\n\n  [Prefix.VH]: new Uint8Array([1, 106, 242]),\n\n  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),\n  [Prefix.TXI]: new Uint8Array([79, 148, 196]),\n  [Prefix.TXM]: new Uint8Array([79, 149, 30]),\n  [Prefix.TXC]: new Uint8Array([79, 148, 17]),\n  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),\n  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),\n  [Prefix.TXW]: new Uint8Array([79, 150, 72]),\n   \n};\n\nexport const prefixLength: { [key: string]: number } = {\n  [Prefix.TZ1]: 20,\n  [Prefix.TZ2]: 20,\n  [Prefix.TZ3]: 20,\n  [Prefix.TZ4]: 20,\n  [Prefix.KT]: 20,\n  [Prefix.KT1]: 20,\n\n  [Prefix.EDPK]: 32,\n  [Prefix.SPPK]: 33,\n  [Prefix.P2PK]: 33,\n  [Prefix.EDSIG]: 64,\n  [Prefix.SPSIG]: 64,\n  [Prefix.P2SIG]: 64,\n  [Prefix.SIG]: 64,\n  [Prefix.NET]: 4,\n  [Prefix.B]: 32,\n  [Prefix.P]: 32,\n  [Prefix.O]: 32,\n  [Prefix.VH]: 32,\n  [Prefix.TXR1]: 20,\n  [Prefix.TXI]: 32,\n  [Prefix.TXM]: 32,\n  [Prefix.TXC]: 32,\n  [Prefix.TXMR]: 32,\n  [Prefix.TXRL]: 32,\n  [Prefix.TXW]: 32,\n\n};\n","/**\n *  @category Error\n *  @description Error that indicates an invalid key being passed or used\n */\nexport class InvalidKeyError extends Error {\n  public name = 'InvalidKeyError';\n  constructor(public key: string, public errorDetail?: string) {\n    super(`The key ${key} is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an Invalid Public Key being passed or used\n */\nexport class InvalidPublicKeyError extends Error {\n  public name = 'InvalidPublicKeyError';\n  constructor(public publicKey: string, errorDetail?: string) {\n    super(`The public key '${publicKey}' is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid signature being passed or used\n */\nexport class InvalidSignatureError extends Error {\n  public name = 'InvalidSignatureError';\n  constructor(public signature: string, errorDetail?: string) {\n    super(`The signature '${signature}' is invalid (${errorDetail})`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid message being passed or used\n */\nexport class InvalidMessageError extends Error {\n  public name = 'InvalidMessageError';\n  constructor(public msg: string, public errorDetail?: string) {\n    super(`The message '${msg}' is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid contract address being passed or used\n */\nexport class InvalidContractAddressError extends Error {\n  public name = 'InvalidContractAddressError';\n  constructor(public contractAddress: string) {\n    super(`The contract address '${contractAddress}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid address being passed or used (both contract and implicit)\n */\nexport class InvalidAddressError extends Error {\n  public name = 'InvalidAddressError';\n  constructor(public address: string) {\n    super(`The address '${address}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid chain id being passed or used\n */\nexport class InvalidChainIdError extends Error {\n  public name = 'InvalidChainIdError';\n  constructor(public chainId: string) {\n    super(`The chain id '${chainId}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid key hash being passed or used\n */\nexport class InvalidKeyHashError extends Error {\n  public name = 'InvalidKeyHashError';\n  constructor(public keyHash: string) {\n    super(`The public key hash '${keyHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid block hash being passed or used\n */ export class InvalidBlockHashError extends Error {\n  public name = 'InvalidBlockHashError';\n  constructor(public blockHash: string) {\n    super(`The block hash '${blockHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates invalid protocol hash being passed or used\n */\nexport class InvalidProtocolHashError extends Error {\n  public name = 'InvalidProtocolHashError';\n  constructor(public protocolHash: string) {\n    super(`The protocol hash '${protocolHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation hash being passed or used\n */ export class InvalidOperationHashError extends Error {\n  public name = 'InvalidOperationHashError';\n  constructor(public operationHash: string) {\n    super(`The operation hash '${operationHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation kind being passed or used\n */\nexport class InvalidOperationKindError extends Error {\n  public name = 'InvalidOperationKindError';\n  constructor(public operationKind: string) {\n    super(`The operation kind '${operationKind}' is unsupported`);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates something is no longer supported and/or deprecated\n */\nexport class DeprecationError extends Error {\n  public name = 'DeprecationError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates an action is prohibited or not allowed\n */\nexport class ProhibitedActionError extends Error {\n  public name = 'ProhibitedActionError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates a failure when trying to convert data from one type to another\n */\nexport class ValueConversionError extends Error {\n  public name = 'ValueConversionError';\n  constructor(public value: string, public desiredType: string) {\n    super(`Unable to convert ${value} to a ${desiredType}`);\n  }\n}\n","import { verify } from '@stablelib/ed25519';\nimport { hash } from '@stablelib/blake2b';\nimport {\n  b58cdecode,\n  buf2hex,\n  hex2buf,\n  Prefix,\n  prefix,\n  validatePublicKey,\n  validateSignature,\n  ValidationResult,\n} from './taquito-utils';\nimport elliptic from 'elliptic';\nimport toBuffer from 'typedarray-to-buffer';\nimport { InvalidMessageError, InvalidPublicKeyError, InvalidSignatureError } from './errors';\n\ntype PkPrefix = Prefix.EDPK | Prefix.SPPK | Prefix.P2PK;\ntype SigPrefix = Prefix.EDSIG | Prefix.SPSIG | Prefix.P2SIG | Prefix.SIG;\n\n/**\n * @description Verify signature of a payload\n *\n * @param messageBytes The forged message including the magic byte (11 for block,\n *        12 for preendorsement, 13 for endorsement, 3 for generic, 5 for the PACK format of michelson)\n * @param publicKey The public key to verify the signature against\n * @param signature The signature to verify\n * @returns A boolean indicating if the signature matches\n *\n * @example\n * ```\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\n *\n * const response = verifySignature(message, pk, sig);\n * ```\n *\n */\nexport function verifySignature(\n  messageBytes: string,\n  publicKey: string,\n  signature: string\n): boolean {\n  const pkPrefix = validatePkAndExtractPrefix(publicKey);\n  const sigPrefix = validateSigAndExtractPrefix(signature);\n\n  const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);\n  const decodedSig = b58cdecode(signature, prefix[sigPrefix]);\n  const bytesHash = hash(hex2buf(validateMessageNotEmpty(messageBytes)), 32);\n\n  if (pkPrefix === Prefix.EDPK) {\n    return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.SPPK) {\n    return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.P2PK) {\n    return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);\n  } else {\n    return false;\n  }\n}\n\nfunction validateMessageNotEmpty(message: string) {\n  if (message === '') {\n    throw new InvalidMessageError(\n      message,\n      'The message provided for verifying signature cannot be empty.'\n    );\n  }\n  return message;\n}\n\nexport function validatePkAndExtractPrefix(publicKey: string): PkPrefix {\n  if (publicKey === '') {\n    throw new InvalidPublicKeyError(publicKey, 'Public key cannot be empty');\n  }\n  const pkPrefix = publicKey.substring(0, 4);\n  const validation = validatePublicKey(publicKey);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid checksum');\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidPublicKeyError(\n        publicKey,\n        `The public key provided has an unsupported prefix: ${pkPrefix}`\n      );\n    }\n  }\n  return pkPrefix as PkPrefix;\n}\n\nfunction validateSigAndExtractPrefix(signature: string): SigPrefix {\n  const signaturePrefix = signature.startsWith('sig')\n    ? signature.substr(0, 3)\n    : signature.substr(0, 5);\n  const validation = validateSignature(signature);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidSignatureError(signature, `invalid checksum`);\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidSignatureError(signature, 'invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidSignatureError(signaturePrefix, 'unsupported prefix');\n    }\n  }\n  return signaturePrefix as SigPrefix;\n}\n\nfunction verifyEdSignature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  try {\n    return verify(decodedPublicKey, bytesHash, decodedSig);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction verifySpSignature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  const key = new elliptic.ec('secp256k1').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifyP2Signature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  const key = new elliptic.ec('p256').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifySpOrP2Sig(decodedSig: Uint8Array, bytesHash: Uint8Array, key: elliptic.ec.KeyPair) {\n  const hexSig = buf2hex(toBuffer(decodedSig));\n  const match = hexSig.match(/([a-f\\d]{64})/gi);\n  if (match) {\n    try {\n      const [r, s] = match;\n      return key.verify(bytesHash, { r, s });\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n","import { prefix, prefixLength, Prefix } from './constants';\n\nimport bs58check from 'bs58check';\n\nexport enum ValidationResult {\n  NO_PREFIX_MATCHED,\n  INVALID_CHECKSUM,\n  INVALID_LENGTH,\n  VALID,\n}\n\nexport function isValidPrefix(value: unknown): value is Prefix {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  return value in prefix;\n}\n/**\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\n * If all checks pass, return `VALID`.\n *\n * @param value Value to validate\n * @param prefixes prefix the value should have\n */\nfunction validatePrefixedValue(value: string, prefixes: Prefix[]) {\n\n  const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  const prefixKey = match[0];\n\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  // Remove annotation from contract address before doing the validation\n  const contractAddress = /^(KT1\\w{33})(%(.*))?/.exec(value);\n  if (contractAddress) {\n    value = contractAddress[1];\n  }\n\n  // decodeUnsafe return undefined if decoding fail\n  let decoded = bs58check.decodeUnsafe(value);\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n\n  decoded = decoded.slice(prefix[prefixKey].length);\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n\n  return ValidationResult.VALID;\n}\n\nconst implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3,Prefix.TZ4];\nconst contractPrefix = [Prefix.KT1,Prefix.TXR1];\nconst signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nconst pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK];\nconst operationPrefix = [Prefix.O];\nconst protocolPrefix = [Prefix.P];\nconst blockPrefix = [Prefix.B]\n\n/**\n * @description Used to check if an address or a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateAddress } from '@taquito/utils';\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateAddress(pkh)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateAddress(value: string): ValidationResult {\n  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);\n}\n\n/**\n * @description Used to check if a chain id is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateChain } from '@taquito/utils';\n * const chainId = 'NetXdQprcVkpaWU'\n * const validation = validateChain(chainId)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateChain(value: string): ValidationResult {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n\n/**\n * @description Used to check if a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateContractAddress } from '@taquito/utils';\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\n * const validation = validateContractAddress(contractAddress)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateContractAddress(value: string): ValidationResult {\n  return validatePrefixedValue(value, contractPrefix);\n}\n\n/**\n * @description Used to check if a key hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateKeyHash } from '@taquito/utils';\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateKeyHash(keyHashWithoutPrefix)\n * console.log(validation)\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\n * ```\n */\nexport function validateKeyHash(value: string): ValidationResult {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateSignature } from '@taquito/utils';\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validateSignature(signature)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateSignature(value: string): ValidationResult {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n\n/**\n * @description Used to check if a public key is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validatePublicKey } from '@taquito/utils';\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\n * const validation = validatePublicKey(publicKey)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validatePublicKey(value: string): ValidationResult {\n  return validatePrefixedValue(value, pkPrefix);\n}\n\n/**\n * @description Used to check if an operation hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateOperation } from '@taquito/utils';\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\n * const validation = validateOperation(operationHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateOperation(value: string): ValidationResult {\n  return validatePrefixedValue(value, operationPrefix);\n}\n\n/**\n * @description Used to check if a protocol hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateProtocol } from '@taquito/utils';\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateProtocol(protocolHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateProtocol(value: string): ValidationResult {\n  return validatePrefixedValue(value, protocolPrefix);\n}\n\n/**\n * @description Used to check if a block hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateBlock } from '@taquito/utils';\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateBlock(blockHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateBlock(value: string): ValidationResult {\n  return validatePrefixedValue(value, blockPrefix);\n}\n","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nexport const VERSION = {\n    \"commitHash\": \"38da814ec2bb4e81c7ad5a45b6b183a4d0b8dc25\",\n    \"version\": \"12.1.1\"\n};\n","/**\n * @packageDocumentation\n * @module @taquito/utils\n */\n\n/*\n * Some code in this file is originally from sotez and eztz\n * Copyright (c) 2018 Andrew Kishino\n * Copyright (c) 2017 Stephen Andrews\n */\n\nimport { Buffer } from 'buffer';\nimport { Prefix, prefix, prefixLength } from './constants';\nimport { validatePkAndExtractPrefix } from './verify-signature';\nimport { hash } from '@stablelib/blake2b';\nimport blake from 'blakejs';\nimport bs58check from 'bs58check';\nimport { ValueConversionError } from './errors';\n\nexport * from './validators';\nexport { VERSION } from './version';\n\nexport { prefix, Prefix, prefixLength } from './constants';\n\nexport { verifySignature, validatePkAndExtractPrefix } from './verify-signature';\nexport * from './errors';\n\n/**\n *\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\n *\n * @param value Value in hex\n */\nexport function encodeExpr(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n\n/**\n *\n * @description Return the operation hash of a signed operation\n * @param value Value in hex of a signed operation\n */\nexport function encodeOpHash(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n\n/**\n *\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\n *\n * @param value Value to base58 encode\n * @param prefix prefix to append to the encoded string\n */\nexport function b58cencode(value: string | Uint8Array, prefix: Uint8Array) {\n  const payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n\n  const n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n\n/**\n *\n * @description Base58 decode a string and remove the prefix from it\n *\n * @param value Value to base58 decode\n * @param prefix prefix to remove from the decoded string\n */\nexport const b58cdecode = (enc: string, prefixArg: Uint8Array): Uint8Array =>\n  bs58check.decode(enc).slice(prefixArg.length);\n\n/**\n *\n * @description Base58 decode a string with predefined prefix\n *\n * @param value Value to base58 decode\n */\nexport function b58decode(payload: string) {\n  const buf: Buffer = bs58check.decode(payload);\n\n  const prefixMap = {\n    [prefix.tz1.toString()]: '0000',\n    [prefix.tz2.toString()]: '0001',\n    [prefix.tz3.toString()]: '0002',\n  };\n\n  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n  if (pref) {\n    // tz addresses\n    const hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n\n/**\n *\n * @description Base58 encode an address using predefined prefix\n *\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\n */\nexport function encodePubKey(value: string) {\n  if (value.substring(0, 2) === '00') {\n    const pref: { [key: string]: Uint8Array } = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3,\n    };\n\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  }\n\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n\n/**\n *\n * @description Base58 encode a key according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport function encodeKey(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Base58 encode a key hash according to its prefix\n *\n * @param value Key hash to base58 encode\n */\nexport function encodeKeyHash(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Convert an hex string to a Uint8Array\n *\n * @param hex Hex string to convert\n */\nexport const hex2buf = (hex: string): Uint8Array => {\n  const match = hex.match(/[\\da-f]{2}/gi);\n  if (match) {\n    return new Uint8Array(match.map((h) => parseInt(h, 16)));\n  } else {\n    throw new ValueConversionError(hex, 'Uint8Array');\n  }\n};\n\n/**\n *\n * @description Merge 2 buffers together\n *\n * @param b1 First buffer\n * @param b2 Second buffer\n */\nexport const mergebuf = (b1: Uint8Array, b2: Uint8Array): Uint8Array => {\n  const r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n\n/**\n *\n * @description Flatten a michelson json representation to an array\n *\n * @param s michelson json\n */\n\n// TODO Zainen check use\nexport const mic2arr = function me2(s: any): any {\n  let ret: any = [];\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1]),\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    const sc = s.length;\n    for (let i = 0; i < sc; i++) {\n      const n = me2(s[i]);\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: [],\n          };\n        }\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n  return ret;\n};\n\n/**\n *\n * @description Convert a buffer to an hex string\n *\n * @param buffer Buffer to convert\n */\nexport const buf2hex = (buffer: Buffer): string => {\n  const byteArray = new Uint8Array(buffer);\n  const hexParts: string[] = [];\n  byteArray.forEach((byte) => {\n    const hex = byte.toString(16);\n    const paddedHex = `00${hex}`.slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n\n/**\n *\n *  @description Gets Tezos address (PKH) from Public Key\n *\n *  @param publicKey Public Key\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\n */\nexport const getPkhfromPk = (publicKey: string): string => {\n  let encodingPrefix;\n  let prefixLen;\n\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decoded = b58cdecode(publicKey, prefix[keyPrefix]);\n\n  switch (keyPrefix) {\n    case Prefix.EDPK:\n      encodingPrefix = prefix[Prefix.TZ1];\n      prefixLen = prefixLength[Prefix.TZ1];\n      break;\n    case Prefix.SPPK:\n      encodingPrefix = prefix[Prefix.TZ2];\n      prefixLen = prefixLength[Prefix.TZ2];\n      break;\n    case Prefix.P2PK:\n      encodingPrefix = prefix[Prefix.TZ3];\n      prefixLen = prefixLength[Prefix.TZ3];\n      break;\n  }\n\n  const hashed = hash(decoded, prefixLen);\n  const result = b58cencode(hashed, encodingPrefix);\n\n  return result;\n};\n\n/**\n *\n * @description Convert a string to bytes\n *\n * @param str String to convert\n */\nexport function char2Bytes(str: string) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n\n/**\n *\n * @description Convert bytes to a string\n *\n * @param str Bytes to convert\n */\nexport function bytes2Char(hex: string): string {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\n"]},"metadata":{},"sourceType":"module"}