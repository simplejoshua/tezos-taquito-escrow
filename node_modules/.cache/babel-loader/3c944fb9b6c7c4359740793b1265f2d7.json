{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger, Transport, PeerManager } from '@airgap/beacon-core';\nimport { TransportStatus, TransportType, Origin } from '@airgap/beacon-types';\nimport { P2PCommunicationClient } from '@airgap/beacon-transport-matrix';\nconst logger = new Logger('P2PTransport');\n/**\n * @internalapi\n *\n *\n */\n\nexport class P2PTransport extends Transport {\n  constructor(name, keyPair, storage, matrixNodes, storageKey, iconUrl, appUrl) {\n    super(name, new P2PCommunicationClient(name, keyPair, 1, storage, matrixNodes, iconUrl, appUrl), new PeerManager(storage, storageKey));\n    this.type = TransportType.P2P;\n  }\n\n  static isAvailable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.resolve(true);\n    });\n  }\n\n  connect() {\n    const _super = Object.create(null, {\n      connect: {\n        get: () => super.connect\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._isConnected !== TransportStatus.NOT_CONNECTED) {\n        return;\n      }\n\n      logger.log('connect');\n      this._isConnected = TransportStatus.CONNECTING;\n      yield this.client.start();\n      const knownPeers = yield this.getPeers();\n\n      if (knownPeers.length > 0) {\n        logger.log('connect', `connecting to ${knownPeers.length} peers`);\n        const connectionPromises = knownPeers.map(peer => __awaiter(this, void 0, void 0, function* () {\n          return this.listen(peer.publicKey);\n        }));\n        Promise.all(connectionPromises).catch(error => logger.error('connect', error));\n      }\n\n      yield this.startOpenChannelListener();\n      return _super.connect.call(this);\n    });\n  }\n\n  disconnect() {\n    const _super = Object.create(null, {\n      disconnect: {\n        get: () => super.disconnect\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.client.stop();\n      return _super.disconnect.call(this);\n    });\n  }\n\n  startOpenChannelListener() {\n    return __awaiter(this, void 0, void 0, function* () {//\n    });\n  }\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.client.getPairingRequestInfo();\n    });\n  }\n\n  listen(publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.client.listenForEncryptedMessage(publicKey, message => {\n        const connectionContext = {\n          origin: Origin.P2P,\n          id: publicKey\n        };\n        this.notifyListeners(message, connectionContext).catch(error => {\n          throw error;\n        });\n      }).catch(error => {\n        throw error;\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/P2PTransport.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAS,MAAT,EAAiB,SAAjB,EAA4B,WAA5B,QAA+C,qBAA/C;AACA,SAKE,eALF,EAME,aANF,EAOE,MAPF,QASO,sBATP;AAUA,SAAS,sBAAT,QAAuC,iCAAvC;AAEA,MAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,cAAX,CAAf;AAEA;;;;AAIG;;AACH,OAAM,MAAO,YAAP,SAGI,SAHJ,CAG2C;EAG/C,WAAA,CACE,IADF,EAEE,OAFF,EAGE,OAHF,EAIE,WAJF,EAKE,UALF,EAME,OANF,EAOE,MAPF,EAOiB;IAEf,MACE,IADF,EAEE,IAAI,sBAAJ,CAA2B,IAA3B,EAAiC,OAAjC,EAA0C,CAA1C,EAA6C,OAA7C,EAAsD,WAAtD,EAAmE,OAAnE,EAA4E,MAA5E,CAFF,EAGE,IAAI,WAAJ,CAAmB,OAAnB,EAA4B,UAA5B,CAHF;IAXc,KAAA,IAAA,GAAsB,aAAa,CAAC,GAApC;EAgBf;;EAE8B,OAAX,WAAW,GAAA;;MAC7B,OAAO,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAP;IACD,C;EAAA;;EAEY,OAAO,GAAA;;;;;;;;MAClB,IAAI,KAAK,YAAL,KAAsB,eAAe,CAAC,aAA1C,EAAyD;QACvD;MACD;;MAED,MAAM,CAAC,GAAP,CAAW,SAAX;MACA,KAAK,YAAL,GAAoB,eAAe,CAAC,UAApC;MAEA,MAAM,KAAK,MAAL,CAAY,KAAZ,EAAN;MAEA,MAAM,UAAU,GAAG,MAAM,KAAK,QAAL,EAAzB;;MAEA,IAAI,UAAU,CAAC,MAAX,GAAoB,CAAxB,EAA2B;QACzB,MAAM,CAAC,GAAP,CAAW,SAAX,EAAsB,iBAAiB,UAAU,CAAC,MAAM,QAAxD;QACA,MAAM,kBAAkB,GAAG,UAAU,CAAC,GAAX,CAAsB,IAAP,IAAe,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;UAAC,OAAA,KAAK,MAAL,CAAY,IAAI,CAAC,SAAjB,CAAA;QAA2B,CAA5B,CAA9B,CAA3B;QACA,OAAO,CAAC,GAAR,CAAY,kBAAZ,EAAgC,KAAhC,CAAuC,KAAD,IAAW,MAAM,CAAC,KAAP,CAAa,SAAb,EAAwB,KAAxB,CAAjD;MACD;;MAED,MAAM,KAAK,wBAAL,EAAN;MAEA,OAAO,MAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb,CAAP;IACD,C;EAAA;;EAEY,UAAU,GAAA;;;;;;;;MACrB,MAAM,KAAK,MAAL,CAAY,IAAZ,EAAN;MAEA,OAAO,MAAA,CAAM,UAAN,CAAgB,IAAhB,CAAgB,IAAhB,CAAP;IACD,C;EAAA;;EAEY,wBAAwB,GAAA;yDACnC;IACD,C;EAAA;;EAEY,qBAAqB,GAAA;;MAChC,OAAO,KAAK,MAAL,CAAY,qBAAZ,EAAP;IACD,C;EAAA;;EAEY,MAAM,CAAC,SAAD,EAAkB;;MACnC,MAAM,KAAK,MAAL,CACH,yBADG,CACuB,SADvB,EACmC,OAAD,IAAY;QAChD,MAAM,iBAAiB,GAAsB;UAC3C,MAAM,EAAE,MAAM,CAAC,GAD4B;UAE3C,EAAE,EAAE;QAFuC,CAA7C;QAKA,KAAK,eAAL,CAAqB,OAArB,EAA8B,iBAA9B,EAAiD,KAAjD,CAAwD,KAAD,IAAU;UAC/D,MAAM,KAAN;QACD,CAFD;MAGD,CAVG,EAWH,KAXG,CAWI,KAAD,IAAU;QACf,MAAM,KAAN;MACD,CAbG,CAAN;IAcD,C;EAAA;;AA3E8C","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger, Transport, PeerManager } from '@airgap/beacon-core';\nimport { TransportStatus, TransportType, Origin } from '@airgap/beacon-types';\nimport { P2PCommunicationClient } from '@airgap/beacon-transport-matrix';\nconst logger = new Logger('P2PTransport');\n/**\n * @internalapi\n *\n *\n */\nexport class P2PTransport extends Transport {\n    constructor(name, keyPair, storage, matrixNodes, storageKey, iconUrl, appUrl) {\n        super(name, new P2PCommunicationClient(name, keyPair, 1, storage, matrixNodes, iconUrl, appUrl), new PeerManager(storage, storageKey));\n        this.type = TransportType.P2P;\n    }\n    static isAvailable() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve(true);\n        });\n    }\n    connect() {\n        const _super = Object.create(null, {\n            connect: { get: () => super.connect }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._isConnected !== TransportStatus.NOT_CONNECTED) {\n                return;\n            }\n            logger.log('connect');\n            this._isConnected = TransportStatus.CONNECTING;\n            yield this.client.start();\n            const knownPeers = yield this.getPeers();\n            if (knownPeers.length > 0) {\n                logger.log('connect', `connecting to ${knownPeers.length} peers`);\n                const connectionPromises = knownPeers.map((peer) => __awaiter(this, void 0, void 0, function* () { return this.listen(peer.publicKey); }));\n                Promise.all(connectionPromises).catch((error) => logger.error('connect', error));\n            }\n            yield this.startOpenChannelListener();\n            return _super.connect.call(this);\n        });\n    }\n    disconnect() {\n        const _super = Object.create(null, {\n            disconnect: { get: () => super.disconnect }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.client.stop();\n            return _super.disconnect.call(this);\n        });\n    }\n    startOpenChannelListener() {\n        return __awaiter(this, void 0, void 0, function* () {\n            //\n        });\n    }\n    getPairingRequestInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.client.getPairingRequestInfo();\n        });\n    }\n    listen(publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.client\n                .listenForEncryptedMessage(publicKey, (message) => {\n                const connectionContext = {\n                    origin: Origin.P2P,\n                    id: publicKey\n                };\n                this.notifyListeners(message, connectionContext).catch((error) => {\n                    throw error;\n                });\n            })\n                .catch((error) => {\n                throw error;\n            });\n        });\n    }\n}\n//# sourceMappingURL=P2PTransport.js.map"]},"metadata":{},"sourceType":"module"}