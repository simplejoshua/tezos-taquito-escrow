{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '../utils/Logger';\nimport { TransportType, TransportStatus } from '@airgap/beacon-types';\nconst logger = new Logger('Transport');\n/**\n * @internalapi\n *\n *\n */\n\nexport class Transport {\n  constructor(name, client, peerManager) {\n    /**\n     * The type of the transport\n     */\n    this.type = TransportType.POST_MESSAGE;\n    /**\n     * The status of the transport\n     */\n\n    this._isConnected = TransportStatus.NOT_CONNECTED;\n    /**\n     * The listeners that will be notified when new messages are coming in\n     */\n\n    this.listeners = [];\n    this.name = name;\n    this.client = client;\n    this.peerManager = peerManager;\n  }\n  /**\n   * Return the status of the connection\n   */\n\n\n  get connectionStatus() {\n    return this._isConnected;\n  }\n  /**\n   * Returns a promise that resolves to true if the transport is available, false if it is not\n   */\n\n\n  static isAvailable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.resolve(false);\n    });\n  }\n  /**\n   * Connect the transport\n   */\n\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('connect');\n      this._isConnected = TransportStatus.CONNECTED;\n      return;\n    });\n  }\n  /**\n   * Disconnect the transport\n   */\n\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('disconnect');\n      this._isConnected = TransportStatus.NOT_CONNECTED;\n      return;\n    });\n  }\n  /**\n   * Send a message through the transport\n   *\n   * @param message The message to send\n   * @param recipient The recipient of the message\n   */\n\n\n  send(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (peer) {\n        return this.client.sendMessage(message, peer);\n      } else {\n        const knownPeers = yield this.getPeers(); // A broadcast request has to be sent everywhere.\n\n        const promises = knownPeers.map(peerEl => this.client.sendMessage(message, peerEl));\n        return (yield Promise.all(promises))[0];\n      }\n    });\n  }\n  /**\n   * Add a listener to be called when a new message is received\n   *\n   * @param listener The listener that will be registered\n   */\n\n\n  addListener(listener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('addListener', listener);\n      this.listeners.push(listener);\n      return;\n    });\n  }\n  /**\n   * Remove a listener\n   *\n   * @param listener\n   */\n\n\n  removeListener(listener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removeListener');\n      this.listeners = this.listeners.filter(element => element !== listener);\n      return;\n    });\n  }\n\n  getPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.peerManager.getPeers(); // TODO: Fix type\n    });\n  }\n\n  addPeer(newPeer) {\n    let _sendPairingResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('addPeer', 'adding peer', newPeer);\n      yield this.peerManager.addPeer(newPeer); // TODO: Fix type\n\n      yield this.listen(newPeer.publicKey);\n    });\n  }\n\n  removePeer(peerToBeRemoved) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removePeer', 'removing peer', peerToBeRemoved);\n      yield this.peerManager.removePeer(peerToBeRemoved.publicKey);\n\n      if (this.client) {\n        yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n      }\n    });\n  }\n\n  removeAllPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removeAllPeers');\n      yield this.peerManager.removeAllPeers();\n\n      if (this.client) {\n        yield this.client.unsubscribeFromEncryptedMessages();\n      }\n    });\n  }\n  /**\n   * Notify the listeners when a new message comes in\n   *\n   * @param message Message\n   * @param connectionInfo Context info about the connection\n   */\n\n\n  notifyListeners(message, connectionInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.listeners.length === 0) {\n        logger.warn('notifyListeners', '0 listeners notified!', this);\n      } else {\n        logger.log('notifyListeners', `Notifying ${this.listeners.length} listeners`, this);\n      }\n\n      this.listeners.forEach(listener => {\n        listener(message, connectionInfo);\n      });\n      return;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/transports/Transport.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from '../utils/Logger';\nimport { TransportType, TransportStatus } from '@airgap/beacon-types';\nconst logger = new Logger('Transport');\n/**\n * @internalapi\n *\n *\n */\nexport class Transport {\n    constructor(name, client, peerManager) {\n        /**\n         * The type of the transport\n         */\n        this.type = TransportType.POST_MESSAGE;\n        /**\n         * The status of the transport\n         */\n        this._isConnected = TransportStatus.NOT_CONNECTED;\n        /**\n         * The listeners that will be notified when new messages are coming in\n         */\n        this.listeners = [];\n        this.name = name;\n        this.client = client;\n        this.peerManager = peerManager;\n    }\n    /**\n     * Return the status of the connection\n     */\n    get connectionStatus() {\n        return this._isConnected;\n    }\n    /**\n     * Returns a promise that resolves to true if the transport is available, false if it is not\n     */\n    static isAvailable() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve(false);\n        });\n    }\n    /**\n     * Connect the transport\n     */\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('connect');\n            this._isConnected = TransportStatus.CONNECTED;\n            return;\n        });\n    }\n    /**\n     * Disconnect the transport\n     */\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('disconnect');\n            this._isConnected = TransportStatus.NOT_CONNECTED;\n            return;\n        });\n    }\n    /**\n     * Send a message through the transport\n     *\n     * @param message The message to send\n     * @param recipient The recipient of the message\n     */\n    send(message, peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (peer) {\n                return this.client.sendMessage(message, peer);\n            }\n            else {\n                const knownPeers = yield this.getPeers();\n                // A broadcast request has to be sent everywhere.\n                const promises = knownPeers.map((peerEl) => this.client.sendMessage(message, peerEl));\n                return (yield Promise.all(promises))[0];\n            }\n        });\n    }\n    /**\n     * Add a listener to be called when a new message is received\n     *\n     * @param listener The listener that will be registered\n     */\n    addListener(listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.debug('addListener', listener);\n            this.listeners.push(listener);\n            return;\n        });\n    }\n    /**\n     * Remove a listener\n     *\n     * @param listener\n     */\n    removeListener(listener) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removeListener');\n            this.listeners = this.listeners.filter((element) => element !== listener);\n            return;\n        });\n    }\n    getPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.peerManager.getPeers(); // TODO: Fix type\n        });\n    }\n    addPeer(newPeer, _sendPairingResponse = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('addPeer', 'adding peer', newPeer);\n            yield this.peerManager.addPeer(newPeer); // TODO: Fix type\n            yield this.listen(newPeer.publicKey);\n        });\n    }\n    removePeer(peerToBeRemoved) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removePeer', 'removing peer', peerToBeRemoved);\n            yield this.peerManager.removePeer(peerToBeRemoved.publicKey);\n            if (this.client) {\n                yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n            }\n        });\n    }\n    removeAllPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removeAllPeers');\n            yield this.peerManager.removeAllPeers();\n            if (this.client) {\n                yield this.client.unsubscribeFromEncryptedMessages();\n            }\n        });\n    }\n    /**\n     * Notify the listeners when a new message comes in\n     *\n     * @param message Message\n     * @param connectionInfo Context info about the connection\n     */\n    notifyListeners(message, connectionInfo) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.listeners.length === 0) {\n                logger.warn('notifyListeners', '0 listeners notified!', this);\n            }\n            else {\n                logger.log('notifyListeners', `Notifying ${this.listeners.length} listeners`, this);\n            }\n            this.listeners.forEach((listener) => {\n                listener(message, connectionInfo);\n            });\n            return;\n        });\n    }\n}\n//# sourceMappingURL=Transport.js.map"]},"metadata":{},"sourceType":"module"}