{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { BeaconEvent } from '../events';\nimport { TransportType, StorageKey, BeaconMessageType, PermissionScope, NetworkType, Origin, BeaconErrorType, SigningType, ColorMode } from '@airgap/beacon-types';\nimport { Client, BeaconError, AppMetadataManager, Serializer, LocalStorage, getAccountIdentifier, getSenderId, Logger } from '@airgap/beacon-core';\nimport { getAddressFromPublicKey, ExposedPromise, generateGUID } from '@airgap/beacon-utils';\nimport { messageEvents } from '../beacon-message-events';\nimport { TezblockBlockExplorer } from '../utils/tezblock-blockexplorer';\nimport { closeToast } from '@airgap/beacon-ui';\nimport { BeaconEventHandler } from '@airgap/beacon-dapp';\nimport { DappPostMessageTransport } from '../transports/DappPostMessageTransport';\nimport { DappP2PTransport } from '../transports/DappP2PTransport';\nimport { PostMessageTransport } from '@airgap/beacon-transport-postmessage';\nimport { getColorMode, setColorMode, setDesktopList, setExtensionList, setWebList, setiOSList, getDesktopList, getExtensionList, getWebList, getiOSList } from '@airgap/beacon-ui';\nconst logger = new Logger('DAppClient');\n/**\n * @publicapi\n *\n * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n * wallets and sending requests.\n *\n * @category DApp\n */\n\nexport class DAppClient extends Client {\n  constructor(config) {\n    var _a, _b, _c, _d;\n\n    super(Object.assign({\n      storage: config && config.storage ? config.storage : new LocalStorage()\n    }, config));\n    this.events = new BeaconEventHandler();\n    /**\n     * A map of requests that are currently \"open\", meaning we have sent them to a wallet and are still awaiting a response.\n     */\n\n    this.openRequests = new Map();\n    /**\n     * The currently active account. For all requests that are associated to a specific request (operation request, signing request),\n     * the active account is used to determine the network and destination wallet\n     */\n\n    this._activeAccount = new ExposedPromise();\n    /**\n     * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)\n     */\n\n    this._activePeer = new ExposedPromise();\n    this.blockchains = new Map();\n    this.events = new BeaconEventHandler(config.eventHandlers, (_a = config.disableDefaultEvents) !== null && _a !== void 0 ? _a : false);\n    this.blockExplorer = (_b = config.blockExplorer) !== null && _b !== void 0 ? _b : new TezblockBlockExplorer();\n    this.preferredNetwork = (_c = config.preferredNetwork) !== null && _c !== void 0 ? _c : NetworkType.MAINNET;\n    setColorMode((_d = config.colorMode) !== null && _d !== void 0 ? _d : ColorMode.LIGHT);\n    this.disclaimerText = config.disclaimerText;\n    this.appMetadataManager = new AppMetadataManager(this.storage);\n    this.activeAccountLoaded = this.storage.get(StorageKey.ACTIVE_ACCOUNT).then(activeAccountIdentifier => __awaiter(this, void 0, void 0, function* () {\n      if (activeAccountIdentifier) {\n        yield this.setActiveAccount(yield this.accountManager.getAccount(activeAccountIdentifier));\n      } else {\n        yield this.setActiveAccount(undefined);\n      }\n    })).catch(storageError => __awaiter(this, void 0, void 0, function* () {\n      yield this.setActiveAccount(undefined);\n      console.error(storageError);\n    }));\n\n    this.handleResponse = (message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n      var _e, _f;\n\n      const openRequest = this.openRequests.get(message.id);\n      logger.log('handleResponse', 'Received message', message, connectionInfo);\n\n      if (message.version === '3') {\n        const typedMessage = message;\n\n        if (openRequest && typedMessage.message.type === BeaconMessageType.Acknowledge) {\n          logger.log(`acknowledge message received for ${message.id}`);\n          console.timeLog(message.id, 'acknowledge');\n          this.events.emit(BeaconEvent.ACKNOWLEDGE_RECEIVED, {\n            message: typedMessage.message,\n            extraInfo: {},\n            walletInfo: yield this.getWalletInfo()\n          }).catch(console.error);\n        } else if (openRequest) {\n          const appMetadata = typedMessage.message\n          /* Why is this unkown cast needed? */\n          .blockchainData.appMetadata;\n\n          if (typedMessage.message.type === BeaconMessageType.PermissionResponse && appMetadata) {\n            yield this.appMetadataManager.addAppMetadata(appMetadata);\n          }\n\n          console.timeLog(typedMessage.id, 'response');\n          console.timeEnd(typedMessage.id);\n\n          if (typedMessage.message.type === BeaconMessageType.Error) {\n            openRequest.reject(typedMessage.message);\n          } else {\n            openRequest.resolve({\n              message,\n              connectionInfo\n            });\n          }\n\n          this.openRequests.delete(typedMessage.id);\n        } else {\n          if (typedMessage.message.type === BeaconMessageType.Disconnect) {\n            const relevantTransport = connectionInfo.origin === Origin.P2P ? this.p2pTransport : (_e = this.postMessageTransport) !== null && _e !== void 0 ? _e : yield this.transport;\n\n            if (relevantTransport) {\n              // TODO: Handle removing it from the right transport (if it was received from the non-active transport)\n              const peers = yield relevantTransport.getPeers();\n              const peer = peers.find(peerEl => peerEl.senderId === message.senderId);\n\n              if (peer) {\n                yield relevantTransport.removePeer(peer);\n                yield this.removeAccountsForPeers([peer]);\n                yield this.events.emit(BeaconEvent.CHANNEL_CLOSED);\n              } else {\n                logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);\n              }\n            }\n          } else {\n            logger.error('handleResponse', 'no request found for id ', message.id);\n          }\n        }\n      } else {\n        const typedMessage = message;\n\n        if (openRequest && typedMessage.type === BeaconMessageType.Acknowledge) {\n          logger.log(`acknowledge message received for ${message.id}`);\n          console.timeLog(message.id, 'acknowledge');\n          this.events.emit(BeaconEvent.ACKNOWLEDGE_RECEIVED, {\n            message: typedMessage,\n            extraInfo: {},\n            walletInfo: yield this.getWalletInfo()\n          }).catch(console.error);\n        } else if (openRequest) {\n          if (typedMessage.type === BeaconMessageType.PermissionResponse && typedMessage.appMetadata) {\n            yield this.appMetadataManager.addAppMetadata(typedMessage.appMetadata);\n          }\n\n          console.timeLog(typedMessage.id, 'response');\n          console.timeEnd(typedMessage.id);\n\n          if (typedMessage.type === BeaconMessageType.Error || message.errorType) {\n            // TODO: Remove \"any\" once we remove support for v1 wallets\n            openRequest.reject(typedMessage);\n          } else {\n            openRequest.resolve({\n              message,\n              connectionInfo\n            });\n          }\n\n          this.openRequests.delete(typedMessage.id);\n        } else {\n          if (typedMessage.type === BeaconMessageType.Disconnect || message.typedMessage.type === BeaconMessageType.Disconnect // TODO: TYPE\n          ) {\n            const relevantTransport = connectionInfo.origin === Origin.P2P ? this.p2pTransport : (_f = this.postMessageTransport) !== null && _f !== void 0 ? _f : yield this.transport;\n\n            if (relevantTransport) {\n              // TODO: Handle removing it from the right transport (if it was received from the non-active transport)\n              const peers = yield relevantTransport.getPeers();\n              const peer = peers.find(peerEl => peerEl.senderId === message.senderId);\n\n              if (peer) {\n                yield relevantTransport.removePeer(peer);\n                yield this.removeAccountsForPeers([peer]);\n                yield this.events.emit(BeaconEvent.CHANNEL_CLOSED);\n              } else {\n                logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);\n              }\n            }\n          } else {\n            logger.error('handleResponse', 'no request found for id ', message.id);\n          }\n        }\n      }\n    });\n  }\n\n  initInternalTransports() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyPair = yield this.keyPair;\n\n      if (this.postMessageTransport || this.p2pTransport) {\n        return;\n      }\n\n      this.postMessageTransport = new DappPostMessageTransport(this.name, keyPair, this.storage);\n      yield this.addListener(this.postMessageTransport);\n      this.p2pTransport = new DappP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);\n      yield this.addListener(this.p2pTransport);\n    });\n  }\n\n  init(transport) {\n    const _super = Object.create(null, {\n      init: {\n        get: () => super.init\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._initPromise) {\n        return this._initPromise;\n      }\n\n      try {\n        yield this.activeAccountLoaded;\n      } catch (_a) {//\n      }\n\n      this._initPromise = new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n        if (transport) {\n          yield this.addListener(transport);\n          resolve(yield _super.init.call(this, transport));\n        } else if (this._transport.isSettled()) {\n          yield (yield this.transport).connect();\n          resolve(yield _super.init.call(this, yield this.transport));\n        } else {\n          const activeAccount = yield this.getActiveAccount();\n\n          const stopListening = () => {\n            if (this.postMessageTransport) {\n              this.postMessageTransport.stopListeningForNewPeers().catch(console.error);\n            }\n\n            if (this.p2pTransport) {\n              this.p2pTransport.stopListeningForNewPeers().catch(console.error);\n            }\n          };\n\n          yield this.initInternalTransports();\n\n          if (!this.postMessageTransport || !this.p2pTransport) {\n            return;\n          }\n\n          this.postMessageTransport.connect().then().catch(console.error);\n\n          if (activeAccount && activeAccount.origin) {\n            const origin = activeAccount.origin.type; // Select the transport that matches the active account\n\n            if (origin === Origin.EXTENSION) {\n              resolve(yield _super.init.call(this, this.postMessageTransport));\n            } else if (origin === Origin.P2P) {\n              resolve(yield _super.init.call(this, this.p2pTransport));\n            }\n          } else {\n            const p2pTransport = this.p2pTransport;\n            const postMessageTransport = this.postMessageTransport;\n            postMessageTransport.listenForNewPeer(peer => {\n              logger.log('init', 'postmessage transport peer connected', peer);\n              this.events.emit(BeaconEvent.PAIR_SUCCESS, peer).catch(emitError => console.warn(emitError));\n              this.setActivePeer(peer).catch(console.error);\n              this.setTransport(this.postMessageTransport).catch(console.error);\n              stopListening();\n              resolve(TransportType.POST_MESSAGE);\n            }).catch(console.error);\n            p2pTransport.listenForNewPeer(peer => {\n              logger.log('init', 'p2p transport peer connected', peer);\n              this.events.emit(BeaconEvent.PAIR_SUCCESS, peer).catch(emitError => console.warn(emitError));\n              this.setActivePeer(peer).catch(console.error);\n              this.setTransport(this.p2pTransport).catch(console.error);\n              stopListening();\n              resolve(TransportType.P2P);\n            }).catch(console.error);\n            PostMessageTransport.getAvailableExtensions().then(() => __awaiter(this, void 0, void 0, function* () {\n              this.events.emit(BeaconEvent.PAIR_INIT, {\n                p2pPeerInfo: () => {\n                  p2pTransport.connect().then().catch(console.error);\n                  return p2pTransport.getPairingRequestInfo();\n                },\n                postmessagePeerInfo: () => postMessageTransport.getPairingRequestInfo(),\n                preferredNetwork: this.preferredNetwork,\n                abortedHandler: () => {\n                  this._initPromise = undefined;\n                },\n                disclaimerText: this.disclaimerText\n              }).catch(emitError => console.warn(emitError));\n            })).catch(error => {\n              this._initPromise = undefined;\n              console.error(error);\n            });\n          }\n        }\n      }));\n      return this._initPromise;\n    });\n  }\n  /**\n   * Returns the active account\n   */\n\n\n  getActiveAccount() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._activeAccount.promise;\n    });\n  }\n  /**\n   * Sets the active account\n   *\n   * @param account The account that will be set as the active account\n   */\n\n\n  setActiveAccount(account) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._activeAccount.isSettled()) {\n        // If the promise has already been resolved we need to create a new one.\n        this._activeAccount = ExposedPromise.resolve(account);\n      } else {\n        this._activeAccount.resolve(account);\n      }\n\n      if (account) {\n        const origin = account.origin.type;\n        yield this.initInternalTransports(); // Select the transport that matches the active account\n\n        if (origin === Origin.EXTENSION) {\n          yield this.setTransport(this.postMessageTransport);\n        } else if (origin === Origin.P2P) {\n          yield this.setTransport(this.p2pTransport);\n        }\n\n        const peer = yield this.getPeer(account);\n        yield this.setActivePeer(peer);\n      } else {\n        yield this.setActivePeer(undefined);\n        yield this.setTransport(undefined);\n      }\n\n      yield this.storage.set(StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined);\n      yield this.events.emit(BeaconEvent.ACTIVE_ACCOUNT_SET, account);\n      return;\n    });\n  }\n  /**\n   * Clear the active account\n   */\n\n\n  clearActiveAccount() {\n    return this.setActiveAccount();\n  }\n\n  setColorMode(colorMode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return setColorMode(colorMode);\n    });\n  }\n\n  getColorMode() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return getColorMode();\n    });\n  }\n  /**\n   * @deprecated\n   *\n   * Use getOwnAppMetadata instead\n   */\n\n\n  getAppMetadata() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.getOwnAppMetadata();\n    });\n  }\n\n  showPrepare() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const walletInfo = yield (() => __awaiter(this, void 0, void 0, function* () {\n        try {\n          return yield this.getWalletInfo();\n        } catch (_a) {\n          return undefined;\n        }\n      }))();\n      yield this.events.emit(BeaconEvent.SHOW_PREPARE, {\n        walletInfo\n      });\n    });\n  }\n\n  hideUI(elements) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.events.emit(BeaconEvent.HIDE_UI, elements);\n    });\n  }\n  /**\n   * Will remove the account from the local storage and set a new active account if necessary.\n   *\n   * @param accountIdentifier ID of the account\n   */\n\n\n  removeAccount(accountIdentifier) {\n    const _super = Object.create(null, {\n      removeAccount: {\n        get: () => super.removeAccount\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const removeAccountResult = _super.removeAccount.call(this, accountIdentifier);\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (activeAccount && activeAccount.accountIdentifier === accountIdentifier) {\n        yield this.setActiveAccount(undefined);\n      }\n\n      return removeAccountResult;\n    });\n  }\n  /**\n   * Remove all accounts and set active account to undefined\n   */\n\n\n  removeAllAccounts() {\n    const _super = Object.create(null, {\n      removeAllAccounts: {\n        get: () => super.removeAllAccounts\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.removeAllAccounts.call(this);\n      yield this.setActiveAccount(undefined);\n    });\n  }\n  /**\n   * Removes a peer and all the accounts that have been connected through that peer\n   *\n   * @param peer Peer to be removed\n   */\n\n\n  removePeer(peer) {\n    let sendDisconnectToPeer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const transport = yield this.transport;\n      const removePeerResult = transport.removePeer(peer);\n      yield this.removeAccountsForPeers([peer]);\n\n      if (sendDisconnectToPeer) {\n        yield this.sendDisconnectToPeer(peer, transport);\n      }\n\n      return removePeerResult;\n    });\n  }\n  /**\n   * Remove all peers and all accounts that have been connected through those peers\n   */\n\n\n  removeAllPeers() {\n    let sendDisconnectToPeers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const transport = yield this.transport;\n      const peers = yield transport.getPeers();\n      const removePeerResult = transport.removeAllPeers();\n      yield this.removeAccountsForPeers(peers);\n\n      if (sendDisconnectToPeers) {\n        const disconnectPromises = peers.map(peer => this.sendDisconnectToPeer(peer, transport));\n        yield Promise.all(disconnectPromises);\n      }\n\n      return removePeerResult;\n    });\n  }\n  /**\n   * Allows the user to subscribe to specific events that are fired in the SDK\n   *\n   * @param internalEvent The event to subscribe to\n   * @param eventCallback The callback that will be called when the event occurs\n   */\n\n\n  subscribeToEvent(internalEvent, eventCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.events.on(internalEvent, eventCallback);\n    });\n  }\n  /**\n   * Check if we have permissions to send the specific message type to the active account.\n   * If no active account is set, only permission requests are allowed.\n   *\n   * @param type The type of the message\n   */\n\n\n  checkPermissions(type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (type === BeaconMessageType.PermissionRequest) {\n        return true;\n      }\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (!activeAccount) {\n        throw yield this.sendInternalError('No active account set!');\n      }\n\n      const permissions = activeAccount.scopes;\n\n      switch (type) {\n        case BeaconMessageType.OperationRequest:\n          return permissions.includes(PermissionScope.OPERATION_REQUEST);\n\n        case BeaconMessageType.SignPayloadRequest:\n          return permissions.includes(PermissionScope.SIGN);\n        // TODO: ENCRYPTION\n        // case BeaconMessageType.EncryptPayloadRequest:\n        //   return permissions.includes(PermissionScope.ENCRYPT)\n\n        case BeaconMessageType.BroadcastRequest:\n          return true;\n\n        default:\n          return false;\n      }\n    });\n  }\n\n  addBlockchain(chain) {\n    this.blockchains.set(chain.identifier, chain);\n    chain.getWalletLists().then(walletLists => {\n      setDesktopList(walletLists.desktopList);\n      setExtensionList(walletLists.extensionList);\n      setWebList(walletLists.webList);\n      setiOSList(walletLists.iOSList);\n    });\n  }\n\n  removeBlockchain(chainIdentifier) {\n    this.blockchains.delete(chainIdentifier);\n  }\n  /** Generic messages */\n\n\n  permissionRequest(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      console.log('PERMISSION REQUEST');\n      const blockchain = this.blockchains.get(input.blockchainIdentifier);\n\n      if (!blockchain) {\n        throw new Error(`Blockchain \"${input.blockchainIdentifier}\" not supported by dAppClient`);\n      }\n\n      const request = Object.assign(Object.assign({}, input), {\n        type: BeaconMessageType.PermissionRequest,\n        blockchainData: Object.assign(Object.assign({}, input.blockchainData), {\n          appMetadata: yield this.getOwnAppMetadata()\n        })\n      });\n      console.log('REQUESTION PERMIMISSION V3', 'xxx', request);\n      const {\n        message: response,\n        connectionInfo\n      } = yield this.makeRequestV3(request).catch(_requestError => __awaiter(this, void 0, void 0, function* () {\n        throw new Error('TODO'); // throw await this.handleRequestError(request, requestError)\n      }));\n      console.log('RESPONSE V3', response, connectionInfo);\n      const partialAccountInfos = yield blockchain.getAccountInfosFromPermissionResponse(response.message); // const accountInfo: AccountInfo = {\n\n      const accountInfo = {\n        accountIdentifier: partialAccountInfos[0].accountId,\n        senderId: response.senderId,\n        origin: {\n          type: connectionInfo.origin,\n          id: connectionInfo.id\n        },\n        address: partialAccountInfos[0].address,\n        publicKey: partialAccountInfos[0].publicKey,\n        scopes: response.message.blockchainData.scopes,\n        connectedAt: new Date().getTime(),\n        chainData: response.message.blockchainData\n      };\n      yield this.accountManager.addAccount(accountInfo);\n      yield this.setActiveAccount(accountInfo);\n      yield blockchain.handleResponse({\n        request,\n        account: accountInfo,\n        output: response,\n        blockExplorer: this.blockExplorer,\n        connectionContext: connectionInfo,\n        walletInfo: yield this.getWalletInfo()\n      });\n      yield this.notifySuccess(request, {\n        account: accountInfo,\n        output: {\n          address: partialAccountInfos[0].address,\n          network: {\n            type: NetworkType.MAINNET\n          },\n          scopes: [PermissionScope.OPERATION_REQUEST]\n        },\n        blockExplorer: this.blockExplorer,\n        connectionContext: connectionInfo,\n        walletInfo: yield this.getWalletInfo()\n      }); // return output\n\n      return response.message;\n    });\n  }\n\n  request(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      console.log('REQUEST', input);\n      const blockchain = this.blockchains.get(input.blockchainIdentifier);\n\n      if (!blockchain) {\n        throw new Error(`Blockchain \"${blockchain}\" not supported by dAppClient`);\n      }\n\n      yield blockchain.validateRequest(input);\n      const activeAccount = yield this.getActiveAccount();\n\n      if (!activeAccount) {\n        throw yield this.sendInternalError('No active account!');\n      }\n\n      const request = Object.assign(Object.assign({}, input), {\n        type: BeaconMessageType.BlockchainRequest,\n        accountId: activeAccount.accountIdentifier\n      });\n      const {\n        message: response,\n        connectionInfo\n      } = yield this.makeRequestV3(request).catch(requestError => __awaiter(this, void 0, void 0, function* () {\n        console.error(requestError);\n        throw new Error('TODO'); // throw await this.handleRequestError(request, requestError)\n      }));\n      yield blockchain.handleResponse({\n        request,\n        account: activeAccount,\n        output: response,\n        blockExplorer: this.blockExplorer,\n        connectionContext: connectionInfo,\n        walletInfo: yield this.getWalletInfo()\n      });\n      return response.message;\n    });\n  }\n  /**\n   * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n   * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n   * and will be used for the following requests.\n   *\n   * @param input The message details we need to prepare the PermissionRequest message.\n   */\n\n\n  requestPermissions(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const request = {\n        appMetadata: yield this.getOwnAppMetadata(),\n        type: BeaconMessageType.PermissionRequest,\n        network: input && input.network ? input.network : {\n          type: NetworkType.MAINNET\n        },\n        scopes: input && input.scopes ? input.scopes : [PermissionScope.OPERATION_REQUEST, PermissionScope.SIGN]\n      };\n      const {\n        message,\n        connectionInfo\n      } = yield this.makeRequest(request).catch(requestError => __awaiter(this, void 0, void 0, function* () {\n        throw yield this.handleRequestError(request, requestError);\n      })); // TODO: Migration code. Remove sometime after 1.0.0 release.\n\n      const publicKey = message.publicKey || message.pubkey || message.pubKey;\n      const address = yield getAddressFromPublicKey(publicKey);\n      const accountInfo = {\n        accountIdentifier: yield getAccountIdentifier(address, message.network),\n        senderId: message.senderId,\n        origin: {\n          type: connectionInfo.origin,\n          id: connectionInfo.id\n        },\n        address,\n        publicKey,\n        network: message.network,\n        scopes: message.scopes,\n        threshold: message.threshold,\n        connectedAt: new Date().getTime()\n      };\n      yield this.accountManager.addAccount(accountInfo);\n      yield this.setActiveAccount(accountInfo);\n      const output = Object.assign(Object.assign({}, message), {\n        address,\n        accountInfo\n      });\n      yield this.notifySuccess(request, {\n        account: accountInfo,\n        output,\n        blockExplorer: this.blockExplorer,\n        connectionContext: connectionInfo,\n        walletInfo: yield this.getWalletInfo()\n      });\n      return output;\n    });\n  }\n  /**\n   * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n   * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n   *\n   * @param input The message details we need to prepare the SignPayloadRequest message.\n   */\n\n\n  requestSignPayload(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!input.payload) {\n        throw yield this.sendInternalError('Payload must be provided');\n      }\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (!activeAccount) {\n        throw yield this.sendInternalError('No active account!');\n      }\n\n      const payload = input.payload;\n\n      if (typeof payload !== 'string') {\n        throw new Error('Payload must be a string');\n      }\n\n      const signingType = (() => {\n        switch (input.signingType) {\n          case SigningType.OPERATION:\n            if (!payload.startsWith('03')) {\n              throw new Error('When using signing type \"OPERATION\", the payload must start with prefix \"03\"');\n            }\n\n            return SigningType.OPERATION;\n\n          case SigningType.MICHELINE:\n            if (!payload.startsWith('05')) {\n              throw new Error('When using signing type \"MICHELINE\", the payload must start with prefix \"05\"');\n            }\n\n            return SigningType.MICHELINE;\n\n          case SigningType.RAW:\n          default:\n            return SigningType.RAW;\n        }\n      })();\n\n      const request = {\n        type: BeaconMessageType.SignPayloadRequest,\n        signingType,\n        payload,\n        sourceAddress: input.sourceAddress || activeAccount.address\n      };\n      const {\n        message,\n        connectionInfo\n      } = yield this.makeRequest(request).catch(requestError => __awaiter(this, void 0, void 0, function* () {\n        throw yield this.handleRequestError(request, requestError);\n      }));\n      yield this.notifySuccess(request, {\n        account: activeAccount,\n        output: message,\n        connectionContext: connectionInfo,\n        walletInfo: yield this.getWalletInfo()\n      });\n      return message;\n    });\n  }\n  /**\n   * This method will send an \"EncryptPayloadRequest\" to the wallet. This method is meant to be used to encrypt or decrypt\n   * arbitrary data (eg. a string). It will return the encrypted or decrypted payload\n   *\n   * @param input The message details we need to prepare the EncryptPayloadRequest message.\n   */\n  // TODO: ENCRYPTION\n  // public async requestEncryptPayload(\n  //   input: RequestEncryptPayloadInput\n  // ): Promise<EncryptPayloadResponseOutput> {\n  //   if (!input.payload) {\n  //     throw await this.sendInternalError('Payload must be provided')\n  //   }\n  //   const activeAccount: AccountInfo | undefined = await this.getActiveAccount()\n  //   if (!activeAccount) {\n  //     throw await this.sendInternalError('No active account!')\n  //   }\n  //   const payload = input.payload\n  //   if (typeof payload !== 'string') {\n  //     throw new Error('Payload must be a string')\n  //   }\n  //   if (typeof input.encryptionCryptoOperation === 'undefined') {\n  //     throw new Error('encryptionCryptoOperation must be defined')\n  //   }\n  //   if (typeof input.encryptionType === 'undefined') {\n  //     throw new Error('encryptionType must be defined')\n  //   }\n  //   const request: EncryptPayloadRequestInput = {\n  //     type: BeaconMessageType.EncryptPayloadRequest,\n  //     cryptoOperation: input.encryptionCryptoOperation,\n  //     encryptionType: input.encryptionType,\n  //     payload,\n  //     sourceAddress: input.sourceAddress || activeAccount.address\n  //   }\n  //   const { message, connectionInfo } = await this.makeRequest<\n  //     EncryptPayloadRequest,\n  //     EncryptPayloadResponse\n  //   >(request).catch(async (requestError: ErrorResponse) => {\n  //     throw await this.handleRequestError(request, requestError)\n  //   })\n  //   await this.notifySuccess(request, {\n  //     account: activeAccount,\n  //     output: message,\n  //     connectionContext: connectionInfo,\n  //     walletInfo: await this.getWalletInfo()\n  //   })\n  //   return message\n  // }\n\n  /**\n   * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n   * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n   * fetched and calculated by the wallet (but they can still be provided if required).\n   *\n   * @param input The message details we need to prepare the OperationRequest message.\n   */\n\n\n  requestOperation(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!input.operationDetails) {\n        throw yield this.sendInternalError('Operation details must be provided');\n      }\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (!activeAccount) {\n        throw yield this.sendInternalError('No active account!');\n      }\n\n      const request = {\n        type: BeaconMessageType.OperationRequest,\n        network: activeAccount.network || {\n          type: NetworkType.MAINNET\n        },\n        operationDetails: input.operationDetails,\n        sourceAddress: activeAccount.address || ''\n      };\n      const {\n        message,\n        connectionInfo\n      } = yield this.makeRequest(request).catch(requestError => __awaiter(this, void 0, void 0, function* () {\n        throw yield this.handleRequestError(request, requestError);\n      }));\n      yield this.notifySuccess(request, {\n        account: activeAccount,\n        output: message,\n        blockExplorer: this.blockExplorer,\n        connectionContext: connectionInfo,\n        walletInfo: yield this.getWalletInfo()\n      });\n      return message;\n    });\n  }\n  /**\n   * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n   * to the network.\n   *\n   * @param input The message details we need to prepare the BroadcastRequest message.\n   */\n\n\n  requestBroadcast(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!input.signedTransaction) {\n        throw yield this.sendInternalError('Signed transaction must be provided');\n      }\n\n      const network = input.network || {\n        type: NetworkType.MAINNET\n      };\n      const request = {\n        type: BeaconMessageType.BroadcastRequest,\n        network,\n        signedTransaction: input.signedTransaction\n      };\n      const {\n        message,\n        connectionInfo\n      } = yield this.makeRequest(request).catch(requestError => __awaiter(this, void 0, void 0, function* () {\n        throw yield this.handleRequestError(request, requestError);\n      }));\n      yield this.notifySuccess(request, {\n        network,\n        output: message,\n        blockExplorer: this.blockExplorer,\n        connectionContext: connectionInfo,\n        walletInfo: yield this.getWalletInfo()\n      });\n      return message;\n    });\n  }\n\n  setActivePeer(peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._activePeer.isSettled()) {\n        // If the promise has already been resolved we need to create a new one.\n        this._activePeer = ExposedPromise.resolve(peer);\n      } else {\n        this._activePeer.resolve(peer);\n      }\n\n      if (peer) {\n        yield this.initInternalTransports();\n\n        if (peer.type === 'postmessage-pairing-response') {\n          yield this.setTransport(this.postMessageTransport);\n        } else if (peer.type === 'p2p-pairing-response') {\n          yield this.setTransport(this.p2pTransport);\n        }\n      }\n\n      return;\n    });\n  }\n  /**\n   * A \"setter\" for when the transport needs to be changed.\n   */\n\n\n  setTransport(transport) {\n    const _super = Object.create(null, {\n      setTransport: {\n        get: () => super.setTransport\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!transport) {\n        this._initPromise = undefined;\n      }\n\n      const result = _super.setTransport.call(this, transport);\n\n      yield this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);\n      return result;\n    });\n  }\n  /**\n   * This method will emit an internal error message.\n   *\n   * @param errorMessage The error message to send.\n   */\n\n\n  sendInternalError(errorMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.events.emit(BeaconEvent.INTERNAL_ERROR, {\n        text: errorMessage\n      });\n      throw new Error(errorMessage);\n    });\n  }\n  /**\n   * This method will remove all accounts associated with a specific peer.\n   *\n   * @param peersToRemove An array of peers for which accounts should be removed\n   */\n\n\n  removeAccountsForPeers(peersToRemove) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const accounts = yield this.accountManager.getAccounts();\n      const peerIdsToRemove = peersToRemove.map(peer => peer.senderId); // Remove all accounts with origin of the specified peer\n\n      const accountsToRemove = accounts.filter(account => peerIdsToRemove.includes(account.senderId));\n      const accountIdentifiersToRemove = accountsToRemove.map(accountInfo => accountInfo.accountIdentifier);\n      yield this.accountManager.removeAccounts(accountIdentifiersToRemove); // Check if one of the accounts that was removed was the active account and if yes, set it to undefined\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (activeAccount) {\n        if (accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {\n          yield this.setActiveAccount(undefined);\n        }\n      }\n    });\n  }\n  /**\n   * This message handles errors that we receive from the wallet.\n   *\n   * @param request The request we sent\n   * @param beaconError The error we received\n   */\n\n\n  handleRequestError(request, beaconError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.error('handleRequestError', 'error response', beaconError);\n\n      if (beaconError.errorType) {\n        const buttons = [];\n\n        if (beaconError.errorType === BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR) {\n          const actionCallback = () => __awaiter(this, void 0, void 0, function* () {\n            const operationRequest = request; // if the account we requested is not available, we remove it locally\n\n            let accountInfo;\n\n            if (operationRequest.sourceAddress && operationRequest.network) {\n              const accountIdentifier = yield getAccountIdentifier(operationRequest.sourceAddress, operationRequest.network);\n              accountInfo = yield this.getAccount(accountIdentifier);\n\n              if (accountInfo) {\n                yield this.removeAccount(accountInfo.accountIdentifier);\n              }\n            }\n          });\n\n          buttons.push({\n            text: 'Remove account',\n            actionCallback\n          });\n        }\n\n        const peer = yield this.getPeer();\n        const activeAccount = yield this.getActiveAccount(); // If we sent a permission request, received an error and there is no active account, we need to reset the DAppClient.\n        // This most likely means that the user rejected the first permission request after pairing a wallet, so we \"forget\" the paired wallet to allow the user to pair again.\n\n        if (request.type === BeaconMessageType.PermissionRequest && (yield this.getActiveAccount()) === undefined) {\n          this._initPromise = undefined;\n          this.postMessageTransport = undefined;\n          this.p2pTransport = undefined;\n          yield this.setTransport();\n          yield this.setActivePeer();\n        }\n\n        this.events.emit(messageEvents[request.type].error, {\n          errorResponse: beaconError,\n          walletInfo: yield this.getWalletInfo(peer, activeAccount)\n        }, buttons).catch(emitError => logger.error('handleRequestError', emitError));\n        throw BeaconError.getError(beaconError.errorType, beaconError.errorData);\n      }\n\n      throw beaconError;\n    });\n  }\n  /**\n   * This message will send an event when we receive a successful response to one of the requests we sent.\n   *\n   * @param request The request we sent\n   * @param response The response we received\n   */\n\n\n  notifySuccess(request, response) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.events.emit(messageEvents[request.type].success, response).catch(emitError => console.warn(emitError));\n    });\n  }\n\n  getWalletInfo(peer, account) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const selectedAccount = account ? account : yield this.getActiveAccount();\n      const selectedPeer = peer ? peer : yield this.getPeer(selectedAccount);\n      let walletInfo;\n\n      if (selectedAccount) {\n        walletInfo = yield this.appMetadataManager.getAppMetadata(selectedAccount.senderId);\n      }\n\n      const typedPeer = selectedPeer;\n\n      if (!walletInfo) {\n        walletInfo = {\n          name: typedPeer.name,\n          icon: typedPeer.icon\n        };\n      }\n\n      const lowerCaseCompare = (str1, str2) => {\n        if (str1 && str2) {\n          return str1.toLowerCase() === str2.toLowerCase();\n        }\n\n        return false;\n      };\n\n      let selectedApp;\n      let type; // TODO: Remove once all wallets send the icon?\n\n      if (getiOSList().find(app => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {\n        selectedApp = getiOSList().find(app => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));\n        type = 'mobile';\n      } else if (getWebList().find(app => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {\n        selectedApp = getWebList().find(app => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));\n        type = 'web';\n      } else if (getDesktopList().find(app => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {\n        selectedApp = getDesktopList().find(app => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));\n        type = 'desktop';\n      } else if (getExtensionList().find(app => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {\n        selectedApp = getExtensionList().find(app => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));\n        type = 'extension';\n      }\n\n      if (selectedApp) {\n        let deeplink;\n\n        if (selectedApp.hasOwnProperty('links')) {\n          deeplink = selectedApp.links[(_a = selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.network.type) !== null && _a !== void 0 ? _a : this.preferredNetwork];\n        } else if (selectedApp.hasOwnProperty('deepLink')) {\n          deeplink = selectedApp.deepLink;\n        }\n\n        return {\n          name: walletInfo.name,\n          icon: (_b = walletInfo.icon) !== null && _b !== void 0 ? _b : selectedApp.logo,\n          deeplink,\n          type\n        };\n      }\n\n      return walletInfo;\n    });\n  }\n\n  getPeer(account) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      let peer;\n\n      if (account) {\n        logger.log('getPeer', 'We have an account', account);\n        const postMessagePeers = (_b = yield (_a = this.postMessageTransport) === null || _a === void 0 ? void 0 : _a.getPeers()) !== null && _b !== void 0 ? _b : [];\n        const p2pPeers = (_d = yield (_c = this.p2pTransport) === null || _c === void 0 ? void 0 : _c.getPeers()) !== null && _d !== void 0 ? _d : [];\n        const peers = [...postMessagePeers, ...p2pPeers];\n        logger.log('getPeer', 'Found peers', peers, account);\n        peer = peers.find(peerEl => peerEl.senderId === account.senderId);\n\n        if (!peer) {\n          // We could not find an exact match for a sender, so we most likely received it over a relay\n          peer = peers.find(peerEl => peerEl.extensionId === account.origin.id);\n        }\n      } else {\n        peer = yield this._activePeer.promise;\n        logger.log('getPeer', 'Active peer', peer);\n      }\n\n      if (!peer) {\n        throw new Error('No matching peer found.');\n      }\n\n      return peer;\n    });\n  }\n  /**\n   * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n   * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n   * to the DApp over the transport.\n   *\n   * @param requestInput The BeaconMessage to be sent to the wallet\n   * @param account The account that the message will be sent to\n   */\n\n\n  makeRequest(requestInput) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const messageId = yield generateGUID();\n      console.time(messageId);\n      logger.log('makeRequest', 'starting');\n      yield this.init();\n      console.timeLog(messageId, 'init done');\n      logger.log('makeRequest', 'after init');\n\n      if (yield this.addRequestAndCheckIfRateLimited()) {\n        this.events.emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED).catch(emitError => console.warn(emitError));\n        throw new Error('rate limit reached');\n      }\n\n      if (!(yield this.checkPermissions(requestInput.type))) {\n        this.events.emit(BeaconEvent.NO_PERMISSIONS).catch(emitError => console.warn(emitError));\n        throw new Error('No permissions to send this request to wallet!');\n      }\n\n      if (!this.beaconId) {\n        throw yield this.sendInternalError('BeaconID not defined');\n      }\n\n      const request = Object.assign({\n        id: messageId,\n        version: '2',\n        senderId: yield getSenderId(yield this.beaconId)\n      }, requestInput);\n      const exposed = new ExposedPromise();\n      this.addOpenRequest(request.id, exposed);\n      const payload = yield new Serializer().serialize(request);\n      const account = yield this.getActiveAccount();\n      const peer = yield this.getPeer(account);\n      const walletInfo = yield this.getWalletInfo(peer, account);\n      logger.log('makeRequest', 'sending message', request);\n      console.timeLog(messageId, 'sending');\n\n      try {\n        yield (yield this.transport).send(payload, peer);\n      } catch (sendError) {\n        this.events.emit(BeaconEvent.INTERNAL_ERROR, {\n          text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',\n          buttons: [{\n            text: 'Reset Connection',\n            actionCallback: () => __awaiter(this, void 0, void 0, function* () {\n              yield closeToast();\n              this.disconnect();\n            })\n          }]\n        });\n        console.timeLog(messageId, 'send error');\n        throw sendError;\n      }\n\n      console.timeLog(messageId, 'sent');\n      this.events.emit(messageEvents[requestInput.type].sent, {\n        walletInfo: Object.assign(Object.assign({}, walletInfo), {\n          name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet'\n        }),\n        extraInfo: {\n          resetCallback: () => __awaiter(this, void 0, void 0, function* () {\n            this.disconnect();\n          })\n        }\n      }).catch(emitError => console.warn(emitError)); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      return exposed.promise; // TODO: fix type\n    });\n  }\n  /**\n   * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n   * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n   * to the DApp over the transport.\n   *\n   * @param requestInput The BeaconMessage to be sent to the wallet\n   * @param account The account that the message will be sent to\n   */\n\n\n  makeRequestV3(requestInput) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const messageId = yield generateGUID();\n      console.time(messageId);\n      logger.log('makeRequest', 'starting');\n      yield this.init();\n      console.timeLog(messageId, 'init done');\n      logger.log('makeRequest', 'after init');\n\n      if (yield this.addRequestAndCheckIfRateLimited()) {\n        this.events.emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED).catch(emitError => console.warn(emitError));\n        throw new Error('rate limit reached');\n      } // if (!(await this.checkPermissions(requestInput.type as BeaconMessageType))) {\n      //   this.events.emit(BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError))\n      //   throw new Error('No permissions to send this request to wallet!')\n      // }\n\n\n      if (!this.beaconId) {\n        throw yield this.sendInternalError('BeaconID not defined');\n      }\n\n      const request = {\n        id: messageId,\n        version: '3',\n        senderId: yield getSenderId(yield this.beaconId),\n        message: requestInput\n      };\n      const exposed = new ExposedPromise();\n      this.addOpenRequest(request.id, exposed);\n      const payload = yield new Serializer().serialize(request);\n      const account = yield this.getActiveAccount();\n      const peer = yield this.getPeer(account);\n      const walletInfo = yield this.getWalletInfo(peer, account);\n      logger.log('makeRequest', 'sending message', request);\n      console.timeLog(messageId, 'sending');\n\n      try {\n        yield (yield this.transport).send(payload, peer);\n      } catch (sendError) {\n        this.events.emit(BeaconEvent.INTERNAL_ERROR, {\n          text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',\n          buttons: [{\n            text: 'Reset Connection',\n            actionCallback: () => __awaiter(this, void 0, void 0, function* () {\n              yield closeToast();\n              this.disconnect();\n            })\n          }]\n        });\n        console.timeLog(messageId, 'send error');\n        throw sendError;\n      }\n\n      console.timeLog(messageId, 'sent');\n      const index = requestInput.type;\n      this.events.emit(messageEvents[index].sent, {\n        walletInfo: Object.assign(Object.assign({}, walletInfo), {\n          name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet'\n        }),\n        extraInfo: {\n          resetCallback: () => __awaiter(this, void 0, void 0, function* () {\n            this.disconnect();\n          })\n        }\n      }).catch(emitError => console.warn(emitError)); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      return exposed.promise; // TODO: fix type\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.postMessageTransport = undefined;\n      this.p2pTransport = undefined;\n      yield Promise.all([this.clearActiveAccount(), (yield this.transport).disconnect()]);\n    });\n  }\n  /**\n   * Adds a requests to the \"openRequests\" set so we know what messages have already been answered/handled.\n   *\n   * @param id The ID of the message\n   * @param promise A promise that resolves once the response for that specific message is received\n   */\n\n\n  addOpenRequest(id, promise) {\n    logger.log('addOpenRequest', this.name, `adding request ${id} and waiting for answer`);\n    this.openRequests.set(id, promise);\n  }\n\n}","map":{"version":3,"sources":["../../../src/dapp-client/DAppClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BeaconEvent } from '../events';\nimport { TransportType, StorageKey, BeaconMessageType, PermissionScope, NetworkType, Origin, BeaconErrorType, SigningType, ColorMode } from '@airgap/beacon-types';\nimport { Client, BeaconError, AppMetadataManager, Serializer, LocalStorage, getAccountIdentifier, getSenderId, Logger } from '@airgap/beacon-core';\nimport { getAddressFromPublicKey, ExposedPromise, generateGUID } from '@airgap/beacon-utils';\nimport { messageEvents } from '../beacon-message-events';\nimport { TezblockBlockExplorer } from '../utils/tezblock-blockexplorer';\nimport { closeToast } from '@airgap/beacon-ui';\nimport { BeaconEventHandler } from '@airgap/beacon-dapp';\nimport { DappPostMessageTransport } from '../transports/DappPostMessageTransport';\nimport { DappP2PTransport } from '../transports/DappP2PTransport';\nimport { PostMessageTransport } from '@airgap/beacon-transport-postmessage';\nimport { getColorMode, setColorMode, setDesktopList, setExtensionList, setWebList, setiOSList, getDesktopList, getExtensionList, getWebList, getiOSList } from '@airgap/beacon-ui';\nconst logger = new Logger('DAppClient');\n/**\n * @publicapi\n *\n * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n * wallets and sending requests.\n *\n * @category DApp\n */\nexport class DAppClient extends Client {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        super(Object.assign({ storage: config && config.storage ? config.storage : new LocalStorage() }, config));\n        this.events = new BeaconEventHandler();\n        /**\n         * A map of requests that are currently \"open\", meaning we have sent them to a wallet and are still awaiting a response.\n         */\n        this.openRequests = new Map();\n        /**\n         * The currently active account. For all requests that are associated to a specific request (operation request, signing request),\n         * the active account is used to determine the network and destination wallet\n         */\n        this._activeAccount = new ExposedPromise();\n        /**\n         * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)\n         */\n        this._activePeer = new ExposedPromise();\n        this.blockchains = new Map();\n        this.events = new BeaconEventHandler(config.eventHandlers, (_a = config.disableDefaultEvents) !== null && _a !== void 0 ? _a : false);\n        this.blockExplorer = (_b = config.blockExplorer) !== null && _b !== void 0 ? _b : new TezblockBlockExplorer();\n        this.preferredNetwork = (_c = config.preferredNetwork) !== null && _c !== void 0 ? _c : NetworkType.MAINNET;\n        setColorMode((_d = config.colorMode) !== null && _d !== void 0 ? _d : ColorMode.LIGHT);\n        this.disclaimerText = config.disclaimerText;\n        this.appMetadataManager = new AppMetadataManager(this.storage);\n        this.activeAccountLoaded = this.storage\n            .get(StorageKey.ACTIVE_ACCOUNT)\n            .then((activeAccountIdentifier) => __awaiter(this, void 0, void 0, function* () {\n            if (activeAccountIdentifier) {\n                yield this.setActiveAccount(yield this.accountManager.getAccount(activeAccountIdentifier));\n            }\n            else {\n                yield this.setActiveAccount(undefined);\n            }\n        }))\n            .catch((storageError) => __awaiter(this, void 0, void 0, function* () {\n            yield this.setActiveAccount(undefined);\n            console.error(storageError);\n        }));\n        this.handleResponse = (message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n            var _e, _f;\n            const openRequest = this.openRequests.get(message.id);\n            logger.log('handleResponse', 'Received message', message, connectionInfo);\n            if (message.version === '3') {\n                const typedMessage = message;\n                if (openRequest && typedMessage.message.type === BeaconMessageType.Acknowledge) {\n                    logger.log(`acknowledge message received for ${message.id}`);\n                    console.timeLog(message.id, 'acknowledge');\n                    this.events\n                        .emit(BeaconEvent.ACKNOWLEDGE_RECEIVED, {\n                        message: typedMessage.message,\n                        extraInfo: {},\n                        walletInfo: yield this.getWalletInfo()\n                    })\n                        .catch(console.error);\n                }\n                else if (openRequest) {\n                    const appMetadata = typedMessage.message /* Why is this unkown cast needed? */.blockchainData.appMetadata;\n                    if (typedMessage.message.type === BeaconMessageType.PermissionResponse && appMetadata) {\n                        yield this.appMetadataManager.addAppMetadata(appMetadata);\n                    }\n                    console.timeLog(typedMessage.id, 'response');\n                    console.timeEnd(typedMessage.id);\n                    if (typedMessage.message.type === BeaconMessageType.Error) {\n                        openRequest.reject(typedMessage.message);\n                    }\n                    else {\n                        openRequest.resolve({ message, connectionInfo });\n                    }\n                    this.openRequests.delete(typedMessage.id);\n                }\n                else {\n                    if (typedMessage.message.type === BeaconMessageType.Disconnect) {\n                        const relevantTransport = connectionInfo.origin === Origin.P2P\n                            ? this.p2pTransport\n                            : (_e = this.postMessageTransport) !== null && _e !== void 0 ? _e : (yield this.transport);\n                        if (relevantTransport) {\n                            // TODO: Handle removing it from the right transport (if it was received from the non-active transport)\n                            const peers = yield relevantTransport.getPeers();\n                            const peer = peers.find((peerEl) => peerEl.senderId === message.senderId);\n                            if (peer) {\n                                yield relevantTransport.removePeer(peer);\n                                yield this.removeAccountsForPeers([peer]);\n                                yield this.events.emit(BeaconEvent.CHANNEL_CLOSED);\n                            }\n                            else {\n                                logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);\n                            }\n                        }\n                    }\n                    else {\n                        logger.error('handleResponse', 'no request found for id ', message.id);\n                    }\n                }\n            }\n            else {\n                const typedMessage = message;\n                if (openRequest && typedMessage.type === BeaconMessageType.Acknowledge) {\n                    logger.log(`acknowledge message received for ${message.id}`);\n                    console.timeLog(message.id, 'acknowledge');\n                    this.events\n                        .emit(BeaconEvent.ACKNOWLEDGE_RECEIVED, {\n                        message: typedMessage,\n                        extraInfo: {},\n                        walletInfo: yield this.getWalletInfo()\n                    })\n                        .catch(console.error);\n                }\n                else if (openRequest) {\n                    if (typedMessage.type === BeaconMessageType.PermissionResponse &&\n                        typedMessage.appMetadata) {\n                        yield this.appMetadataManager.addAppMetadata(typedMessage.appMetadata);\n                    }\n                    console.timeLog(typedMessage.id, 'response');\n                    console.timeEnd(typedMessage.id);\n                    if (typedMessage.type === BeaconMessageType.Error || message.errorType) {\n                        // TODO: Remove \"any\" once we remove support for v1 wallets\n                        openRequest.reject(typedMessage);\n                    }\n                    else {\n                        openRequest.resolve({ message, connectionInfo });\n                    }\n                    this.openRequests.delete(typedMessage.id);\n                }\n                else {\n                    if (typedMessage.type === BeaconMessageType.Disconnect ||\n                        message.typedMessage.type === BeaconMessageType.Disconnect // TODO: TYPE\n                    ) {\n                        const relevantTransport = connectionInfo.origin === Origin.P2P\n                            ? this.p2pTransport\n                            : (_f = this.postMessageTransport) !== null && _f !== void 0 ? _f : (yield this.transport);\n                        if (relevantTransport) {\n                            // TODO: Handle removing it from the right transport (if it was received from the non-active transport)\n                            const peers = yield relevantTransport.getPeers();\n                            const peer = peers.find((peerEl) => peerEl.senderId === message.senderId);\n                            if (peer) {\n                                yield relevantTransport.removePeer(peer);\n                                yield this.removeAccountsForPeers([peer]);\n                                yield this.events.emit(BeaconEvent.CHANNEL_CLOSED);\n                            }\n                            else {\n                                logger.error('handleDisconnect', 'cannot find peer for sender ID', message.senderId);\n                            }\n                        }\n                    }\n                    else {\n                        logger.error('handleResponse', 'no request found for id ', message.id);\n                    }\n                }\n            }\n        });\n    }\n    initInternalTransports() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyPair = yield this.keyPair;\n            if (this.postMessageTransport || this.p2pTransport) {\n                return;\n            }\n            this.postMessageTransport = new DappPostMessageTransport(this.name, keyPair, this.storage);\n            yield this.addListener(this.postMessageTransport);\n            this.p2pTransport = new DappP2PTransport(this.name, keyPair, this.storage, this.matrixNodes, this.iconUrl, this.appUrl);\n            yield this.addListener(this.p2pTransport);\n        });\n    }\n    init(transport) {\n        const _super = Object.create(null, {\n            init: { get: () => super.init }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._initPromise) {\n                return this._initPromise;\n            }\n            try {\n                yield this.activeAccountLoaded;\n            }\n            catch (_a) {\n                //\n            }\n            this._initPromise = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                if (transport) {\n                    yield this.addListener(transport);\n                    resolve(yield _super.init.call(this, transport));\n                }\n                else if (this._transport.isSettled()) {\n                    yield (yield this.transport).connect();\n                    resolve(yield _super.init.call(this, yield this.transport));\n                }\n                else {\n                    const activeAccount = yield this.getActiveAccount();\n                    const stopListening = () => {\n                        if (this.postMessageTransport) {\n                            this.postMessageTransport.stopListeningForNewPeers().catch(console.error);\n                        }\n                        if (this.p2pTransport) {\n                            this.p2pTransport.stopListeningForNewPeers().catch(console.error);\n                        }\n                    };\n                    yield this.initInternalTransports();\n                    if (!this.postMessageTransport || !this.p2pTransport) {\n                        return;\n                    }\n                    this.postMessageTransport.connect().then().catch(console.error);\n                    if (activeAccount && activeAccount.origin) {\n                        const origin = activeAccount.origin.type;\n                        // Select the transport that matches the active account\n                        if (origin === Origin.EXTENSION) {\n                            resolve(yield _super.init.call(this, this.postMessageTransport));\n                        }\n                        else if (origin === Origin.P2P) {\n                            resolve(yield _super.init.call(this, this.p2pTransport));\n                        }\n                    }\n                    else {\n                        const p2pTransport = this.p2pTransport;\n                        const postMessageTransport = this.postMessageTransport;\n                        postMessageTransport\n                            .listenForNewPeer((peer) => {\n                            logger.log('init', 'postmessage transport peer connected', peer);\n                            this.events\n                                .emit(BeaconEvent.PAIR_SUCCESS, peer)\n                                .catch((emitError) => console.warn(emitError));\n                            this.setActivePeer(peer).catch(console.error);\n                            this.setTransport(this.postMessageTransport).catch(console.error);\n                            stopListening();\n                            resolve(TransportType.POST_MESSAGE);\n                        })\n                            .catch(console.error);\n                        p2pTransport\n                            .listenForNewPeer((peer) => {\n                            logger.log('init', 'p2p transport peer connected', peer);\n                            this.events\n                                .emit(BeaconEvent.PAIR_SUCCESS, peer)\n                                .catch((emitError) => console.warn(emitError));\n                            this.setActivePeer(peer).catch(console.error);\n                            this.setTransport(this.p2pTransport).catch(console.error);\n                            stopListening();\n                            resolve(TransportType.P2P);\n                        })\n                            .catch(console.error);\n                        PostMessageTransport.getAvailableExtensions()\n                            .then(() => __awaiter(this, void 0, void 0, function* () {\n                            this.events\n                                .emit(BeaconEvent.PAIR_INIT, {\n                                p2pPeerInfo: () => {\n                                    p2pTransport.connect().then().catch(console.error);\n                                    return p2pTransport.getPairingRequestInfo();\n                                },\n                                postmessagePeerInfo: () => postMessageTransport.getPairingRequestInfo(),\n                                preferredNetwork: this.preferredNetwork,\n                                abortedHandler: () => {\n                                    this._initPromise = undefined;\n                                },\n                                disclaimerText: this.disclaimerText\n                            })\n                                .catch((emitError) => console.warn(emitError));\n                        }))\n                            .catch((error) => {\n                            this._initPromise = undefined;\n                            console.error(error);\n                        });\n                    }\n                }\n            }));\n            return this._initPromise;\n        });\n    }\n    /**\n     * Returns the active account\n     */\n    getActiveAccount() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._activeAccount.promise;\n        });\n    }\n    /**\n     * Sets the active account\n     *\n     * @param account The account that will be set as the active account\n     */\n    setActiveAccount(account) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._activeAccount.isSettled()) {\n                // If the promise has already been resolved we need to create a new one.\n                this._activeAccount = ExposedPromise.resolve(account);\n            }\n            else {\n                this._activeAccount.resolve(account);\n            }\n            if (account) {\n                const origin = account.origin.type;\n                yield this.initInternalTransports();\n                // Select the transport that matches the active account\n                if (origin === Origin.EXTENSION) {\n                    yield this.setTransport(this.postMessageTransport);\n                }\n                else if (origin === Origin.P2P) {\n                    yield this.setTransport(this.p2pTransport);\n                }\n                const peer = yield this.getPeer(account);\n                yield this.setActivePeer(peer);\n            }\n            else {\n                yield this.setActivePeer(undefined);\n                yield this.setTransport(undefined);\n            }\n            yield this.storage.set(StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined);\n            yield this.events.emit(BeaconEvent.ACTIVE_ACCOUNT_SET, account);\n            return;\n        });\n    }\n    /**\n     * Clear the active account\n     */\n    clearActiveAccount() {\n        return this.setActiveAccount();\n    }\n    setColorMode(colorMode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return setColorMode(colorMode);\n        });\n    }\n    getColorMode() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return getColorMode();\n        });\n    }\n    /**\n     * @deprecated\n     *\n     * Use getOwnAppMetadata instead\n     */\n    getAppMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getOwnAppMetadata();\n        });\n    }\n    showPrepare() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletInfo = yield (() => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    return yield this.getWalletInfo();\n                }\n                catch (_a) {\n                    return undefined;\n                }\n            }))();\n            yield this.events.emit(BeaconEvent.SHOW_PREPARE, { walletInfo });\n        });\n    }\n    hideUI(elements) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.events.emit(BeaconEvent.HIDE_UI, elements);\n        });\n    }\n    /**\n     * Will remove the account from the local storage and set a new active account if necessary.\n     *\n     * @param accountIdentifier ID of the account\n     */\n    removeAccount(accountIdentifier) {\n        const _super = Object.create(null, {\n            removeAccount: { get: () => super.removeAccount }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const removeAccountResult = _super.removeAccount.call(this, accountIdentifier);\n            const activeAccount = yield this.getActiveAccount();\n            if (activeAccount && activeAccount.accountIdentifier === accountIdentifier) {\n                yield this.setActiveAccount(undefined);\n            }\n            return removeAccountResult;\n        });\n    }\n    /**\n     * Remove all accounts and set active account to undefined\n     */\n    removeAllAccounts() {\n        const _super = Object.create(null, {\n            removeAllAccounts: { get: () => super.removeAllAccounts }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.removeAllAccounts.call(this);\n            yield this.setActiveAccount(undefined);\n        });\n    }\n    /**\n     * Removes a peer and all the accounts that have been connected through that peer\n     *\n     * @param peer Peer to be removed\n     */\n    removePeer(peer, sendDisconnectToPeer = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transport = yield this.transport;\n            const removePeerResult = transport.removePeer(peer);\n            yield this.removeAccountsForPeers([peer]);\n            if (sendDisconnectToPeer) {\n                yield this.sendDisconnectToPeer(peer, transport);\n            }\n            return removePeerResult;\n        });\n    }\n    /**\n     * Remove all peers and all accounts that have been connected through those peers\n     */\n    removeAllPeers(sendDisconnectToPeers = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transport = yield this.transport;\n            const peers = yield transport.getPeers();\n            const removePeerResult = transport.removeAllPeers();\n            yield this.removeAccountsForPeers(peers);\n            if (sendDisconnectToPeers) {\n                const disconnectPromises = peers.map((peer) => this.sendDisconnectToPeer(peer, transport));\n                yield Promise.all(disconnectPromises);\n            }\n            return removePeerResult;\n        });\n    }\n    /**\n     * Allows the user to subscribe to specific events that are fired in the SDK\n     *\n     * @param internalEvent The event to subscribe to\n     * @param eventCallback The callback that will be called when the event occurs\n     */\n    subscribeToEvent(internalEvent, eventCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.events.on(internalEvent, eventCallback);\n        });\n    }\n    /**\n     * Check if we have permissions to send the specific message type to the active account.\n     * If no active account is set, only permission requests are allowed.\n     *\n     * @param type The type of the message\n     */\n    checkPermissions(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (type === BeaconMessageType.PermissionRequest) {\n                return true;\n            }\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw yield this.sendInternalError('No active account set!');\n            }\n            const permissions = activeAccount.scopes;\n            switch (type) {\n                case BeaconMessageType.OperationRequest:\n                    return permissions.includes(PermissionScope.OPERATION_REQUEST);\n                case BeaconMessageType.SignPayloadRequest:\n                    return permissions.includes(PermissionScope.SIGN);\n                // TODO: ENCRYPTION\n                // case BeaconMessageType.EncryptPayloadRequest:\n                //   return permissions.includes(PermissionScope.ENCRYPT)\n                case BeaconMessageType.BroadcastRequest:\n                    return true;\n                default:\n                    return false;\n            }\n        });\n    }\n    addBlockchain(chain) {\n        this.blockchains.set(chain.identifier, chain);\n        chain.getWalletLists().then((walletLists) => {\n            setDesktopList(walletLists.desktopList);\n            setExtensionList(walletLists.extensionList);\n            setWebList(walletLists.webList);\n            setiOSList(walletLists.iOSList);\n        });\n    }\n    removeBlockchain(chainIdentifier) {\n        this.blockchains.delete(chainIdentifier);\n    }\n    /** Generic messages */\n    permissionRequest(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('PERMISSION REQUEST');\n            const blockchain = this.blockchains.get(input.blockchainIdentifier);\n            if (!blockchain) {\n                throw new Error(`Blockchain \"${input.blockchainIdentifier}\" not supported by dAppClient`);\n            }\n            const request = Object.assign(Object.assign({}, input), { type: BeaconMessageType.PermissionRequest, blockchainData: Object.assign(Object.assign({}, input.blockchainData), { appMetadata: yield this.getOwnAppMetadata() }) });\n            console.log('REQUESTION PERMIMISSION V3', 'xxx', request);\n            const { message: response, connectionInfo } = yield this.makeRequestV3(request).catch((_requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw new Error('TODO');\n                // throw await this.handleRequestError(request, requestError)\n            }));\n            console.log('RESPONSE V3', response, connectionInfo);\n            const partialAccountInfos = yield blockchain.getAccountInfosFromPermissionResponse(response.message);\n            // const accountInfo: AccountInfo = {\n            const accountInfo = {\n                accountIdentifier: partialAccountInfos[0].accountId,\n                senderId: response.senderId,\n                origin: {\n                    type: connectionInfo.origin,\n                    id: connectionInfo.id\n                },\n                address: partialAccountInfos[0].address,\n                publicKey: partialAccountInfos[0].publicKey,\n                scopes: response.message.blockchainData.scopes,\n                connectedAt: new Date().getTime(),\n                chainData: response.message.blockchainData\n            };\n            yield this.accountManager.addAccount(accountInfo);\n            yield this.setActiveAccount(accountInfo);\n            yield blockchain.handleResponse({\n                request,\n                account: accountInfo,\n                output: response,\n                blockExplorer: this.blockExplorer,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            yield this.notifySuccess(request, {\n                account: accountInfo,\n                output: {\n                    address: partialAccountInfos[0].address,\n                    network: { type: NetworkType.MAINNET },\n                    scopes: [PermissionScope.OPERATION_REQUEST]\n                },\n                blockExplorer: this.blockExplorer,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            // return output\n            return response.message;\n        });\n    }\n    request(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('REQUEST', input);\n            const blockchain = this.blockchains.get(input.blockchainIdentifier);\n            if (!blockchain) {\n                throw new Error(`Blockchain \"${blockchain}\" not supported by dAppClient`);\n            }\n            yield blockchain.validateRequest(input);\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw yield this.sendInternalError('No active account!');\n            }\n            const request = Object.assign(Object.assign({}, input), { type: BeaconMessageType.BlockchainRequest, accountId: activeAccount.accountIdentifier });\n            const { message: response, connectionInfo } = yield this.makeRequestV3(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                console.error(requestError);\n                throw new Error('TODO');\n                // throw await this.handleRequestError(request, requestError)\n            }));\n            yield blockchain.handleResponse({\n                request,\n                account: activeAccount,\n                output: response,\n                blockExplorer: this.blockExplorer,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            return response.message;\n        });\n    }\n    /**\n     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n     * and will be used for the following requests.\n     *\n     * @param input The message details we need to prepare the PermissionRequest message.\n     */\n    requestPermissions(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request = {\n                appMetadata: yield this.getOwnAppMetadata(),\n                type: BeaconMessageType.PermissionRequest,\n                network: input && input.network ? input.network : { type: NetworkType.MAINNET },\n                scopes: input && input.scopes\n                    ? input.scopes\n                    : [PermissionScope.OPERATION_REQUEST, PermissionScope.SIGN]\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.handleRequestError(request, requestError);\n            }));\n            // TODO: Migration code. Remove sometime after 1.0.0 release.\n            const publicKey = message.publicKey || message.pubkey || message.pubKey;\n            const address = yield getAddressFromPublicKey(publicKey);\n            const accountInfo = {\n                accountIdentifier: yield getAccountIdentifier(address, message.network),\n                senderId: message.senderId,\n                origin: {\n                    type: connectionInfo.origin,\n                    id: connectionInfo.id\n                },\n                address,\n                publicKey,\n                network: message.network,\n                scopes: message.scopes,\n                threshold: message.threshold,\n                connectedAt: new Date().getTime()\n            };\n            yield this.accountManager.addAccount(accountInfo);\n            yield this.setActiveAccount(accountInfo);\n            const output = Object.assign(Object.assign({}, message), { address,\n                accountInfo });\n            yield this.notifySuccess(request, {\n                account: accountInfo,\n                output,\n                blockExplorer: this.blockExplorer,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            return output;\n        });\n    }\n    /**\n     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n     *\n     * @param input The message details we need to prepare the SignPayloadRequest message.\n     */\n    requestSignPayload(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!input.payload) {\n                throw yield this.sendInternalError('Payload must be provided');\n            }\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw yield this.sendInternalError('No active account!');\n            }\n            const payload = input.payload;\n            if (typeof payload !== 'string') {\n                throw new Error('Payload must be a string');\n            }\n            const signingType = (() => {\n                switch (input.signingType) {\n                    case SigningType.OPERATION:\n                        if (!payload.startsWith('03')) {\n                            throw new Error('When using signing type \"OPERATION\", the payload must start with prefix \"03\"');\n                        }\n                        return SigningType.OPERATION;\n                    case SigningType.MICHELINE:\n                        if (!payload.startsWith('05')) {\n                            throw new Error('When using signing type \"MICHELINE\", the payload must start with prefix \"05\"');\n                        }\n                        return SigningType.MICHELINE;\n                    case SigningType.RAW:\n                    default:\n                        return SigningType.RAW;\n                }\n            })();\n            const request = {\n                type: BeaconMessageType.SignPayloadRequest,\n                signingType,\n                payload,\n                sourceAddress: input.sourceAddress || activeAccount.address\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.handleRequestError(request, requestError);\n            }));\n            yield this.notifySuccess(request, {\n                account: activeAccount,\n                output: message,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            return message;\n        });\n    }\n    /**\n     * This method will send an \"EncryptPayloadRequest\" to the wallet. This method is meant to be used to encrypt or decrypt\n     * arbitrary data (eg. a string). It will return the encrypted or decrypted payload\n     *\n     * @param input The message details we need to prepare the EncryptPayloadRequest message.\n     */\n    // TODO: ENCRYPTION\n    // public async requestEncryptPayload(\n    //   input: RequestEncryptPayloadInput\n    // ): Promise<EncryptPayloadResponseOutput> {\n    //   if (!input.payload) {\n    //     throw await this.sendInternalError('Payload must be provided')\n    //   }\n    //   const activeAccount: AccountInfo | undefined = await this.getActiveAccount()\n    //   if (!activeAccount) {\n    //     throw await this.sendInternalError('No active account!')\n    //   }\n    //   const payload = input.payload\n    //   if (typeof payload !== 'string') {\n    //     throw new Error('Payload must be a string')\n    //   }\n    //   if (typeof input.encryptionCryptoOperation === 'undefined') {\n    //     throw new Error('encryptionCryptoOperation must be defined')\n    //   }\n    //   if (typeof input.encryptionType === 'undefined') {\n    //     throw new Error('encryptionType must be defined')\n    //   }\n    //   const request: EncryptPayloadRequestInput = {\n    //     type: BeaconMessageType.EncryptPayloadRequest,\n    //     cryptoOperation: input.encryptionCryptoOperation,\n    //     encryptionType: input.encryptionType,\n    //     payload,\n    //     sourceAddress: input.sourceAddress || activeAccount.address\n    //   }\n    //   const { message, connectionInfo } = await this.makeRequest<\n    //     EncryptPayloadRequest,\n    //     EncryptPayloadResponse\n    //   >(request).catch(async (requestError: ErrorResponse) => {\n    //     throw await this.handleRequestError(request, requestError)\n    //   })\n    //   await this.notifySuccess(request, {\n    //     account: activeAccount,\n    //     output: message,\n    //     connectionContext: connectionInfo,\n    //     walletInfo: await this.getWalletInfo()\n    //   })\n    //   return message\n    // }\n    /**\n     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n     * fetched and calculated by the wallet (but they can still be provided if required).\n     *\n     * @param input The message details we need to prepare the OperationRequest message.\n     */\n    requestOperation(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!input.operationDetails) {\n                throw yield this.sendInternalError('Operation details must be provided');\n            }\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw yield this.sendInternalError('No active account!');\n            }\n            const request = {\n                type: BeaconMessageType.OperationRequest,\n                network: activeAccount.network || { type: NetworkType.MAINNET },\n                operationDetails: input.operationDetails,\n                sourceAddress: activeAccount.address || ''\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.handleRequestError(request, requestError);\n            }));\n            yield this.notifySuccess(request, {\n                account: activeAccount,\n                output: message,\n                blockExplorer: this.blockExplorer,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            return message;\n        });\n    }\n    /**\n     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n     * to the network.\n     *\n     * @param input The message details we need to prepare the BroadcastRequest message.\n     */\n    requestBroadcast(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!input.signedTransaction) {\n                throw yield this.sendInternalError('Signed transaction must be provided');\n            }\n            const network = input.network || { type: NetworkType.MAINNET };\n            const request = {\n                type: BeaconMessageType.BroadcastRequest,\n                network,\n                signedTransaction: input.signedTransaction\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw yield this.handleRequestError(request, requestError);\n            }));\n            yield this.notifySuccess(request, {\n                network,\n                output: message,\n                blockExplorer: this.blockExplorer,\n                connectionContext: connectionInfo,\n                walletInfo: yield this.getWalletInfo()\n            });\n            return message;\n        });\n    }\n    setActivePeer(peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._activePeer.isSettled()) {\n                // If the promise has already been resolved we need to create a new one.\n                this._activePeer = ExposedPromise.resolve(peer);\n            }\n            else {\n                this._activePeer.resolve(peer);\n            }\n            if (peer) {\n                yield this.initInternalTransports();\n                if (peer.type === 'postmessage-pairing-response') {\n                    yield this.setTransport(this.postMessageTransport);\n                }\n                else if (peer.type === 'p2p-pairing-response') {\n                    yield this.setTransport(this.p2pTransport);\n                }\n            }\n            return;\n        });\n    }\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    setTransport(transport) {\n        const _super = Object.create(null, {\n            setTransport: { get: () => super.setTransport }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!transport) {\n                this._initPromise = undefined;\n            }\n            const result = _super.setTransport.call(this, transport);\n            yield this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);\n            return result;\n        });\n    }\n    /**\n     * This method will emit an internal error message.\n     *\n     * @param errorMessage The error message to send.\n     */\n    sendInternalError(errorMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.events.emit(BeaconEvent.INTERNAL_ERROR, { text: errorMessage });\n            throw new Error(errorMessage);\n        });\n    }\n    /**\n     * This method will remove all accounts associated with a specific peer.\n     *\n     * @param peersToRemove An array of peers for which accounts should be removed\n     */\n    removeAccountsForPeers(peersToRemove) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accounts = yield this.accountManager.getAccounts();\n            const peerIdsToRemove = peersToRemove.map((peer) => peer.senderId);\n            // Remove all accounts with origin of the specified peer\n            const accountsToRemove = accounts.filter((account) => peerIdsToRemove.includes(account.senderId));\n            const accountIdentifiersToRemove = accountsToRemove.map((accountInfo) => accountInfo.accountIdentifier);\n            yield this.accountManager.removeAccounts(accountIdentifiersToRemove);\n            // Check if one of the accounts that was removed was the active account and if yes, set it to undefined\n            const activeAccount = yield this.getActiveAccount();\n            if (activeAccount) {\n                if (accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {\n                    yield this.setActiveAccount(undefined);\n                }\n            }\n        });\n    }\n    /**\n     * This message handles errors that we receive from the wallet.\n     *\n     * @param request The request we sent\n     * @param beaconError The error we received\n     */\n    handleRequestError(request, beaconError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.error('handleRequestError', 'error response', beaconError);\n            if (beaconError.errorType) {\n                const buttons = [];\n                if (beaconError.errorType === BeaconErrorType.NO_PRIVATE_KEY_FOUND_ERROR) {\n                    const actionCallback = () => __awaiter(this, void 0, void 0, function* () {\n                        const operationRequest = request;\n                        // if the account we requested is not available, we remove it locally\n                        let accountInfo;\n                        if (operationRequest.sourceAddress && operationRequest.network) {\n                            const accountIdentifier = yield getAccountIdentifier(operationRequest.sourceAddress, operationRequest.network);\n                            accountInfo = yield this.getAccount(accountIdentifier);\n                            if (accountInfo) {\n                                yield this.removeAccount(accountInfo.accountIdentifier);\n                            }\n                        }\n                    });\n                    buttons.push({ text: 'Remove account', actionCallback });\n                }\n                const peer = yield this.getPeer();\n                const activeAccount = yield this.getActiveAccount();\n                // If we sent a permission request, received an error and there is no active account, we need to reset the DAppClient.\n                // This most likely means that the user rejected the first permission request after pairing a wallet, so we \"forget\" the paired wallet to allow the user to pair again.\n                if (request.type === BeaconMessageType.PermissionRequest &&\n                    (yield this.getActiveAccount()) === undefined) {\n                    this._initPromise = undefined;\n                    this.postMessageTransport = undefined;\n                    this.p2pTransport = undefined;\n                    yield this.setTransport();\n                    yield this.setActivePeer();\n                }\n                this.events\n                    .emit(messageEvents[request.type].error, { errorResponse: beaconError, walletInfo: yield this.getWalletInfo(peer, activeAccount) }, buttons)\n                    .catch((emitError) => logger.error('handleRequestError', emitError));\n                throw BeaconError.getError(beaconError.errorType, beaconError.errorData);\n            }\n            throw beaconError;\n        });\n    }\n    /**\n     * This message will send an event when we receive a successful response to one of the requests we sent.\n     *\n     * @param request The request we sent\n     * @param response The response we received\n     */\n    notifySuccess(request, response) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.events\n                .emit(messageEvents[request.type].success, response)\n                .catch((emitError) => console.warn(emitError));\n        });\n    }\n    getWalletInfo(peer, account) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const selectedAccount = account ? account : yield this.getActiveAccount();\n            const selectedPeer = peer ? peer : yield this.getPeer(selectedAccount);\n            let walletInfo;\n            if (selectedAccount) {\n                walletInfo = yield this.appMetadataManager.getAppMetadata(selectedAccount.senderId);\n            }\n            const typedPeer = selectedPeer;\n            if (!walletInfo) {\n                walletInfo = {\n                    name: typedPeer.name,\n                    icon: typedPeer.icon\n                };\n            }\n            const lowerCaseCompare = (str1, str2) => {\n                if (str1 && str2) {\n                    return str1.toLowerCase() === str2.toLowerCase();\n                }\n                return false;\n            };\n            let selectedApp;\n            let type;\n            // TODO: Remove once all wallets send the icon?\n            if (getiOSList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {\n                selectedApp = getiOSList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));\n                type = 'mobile';\n            }\n            else if (getWebList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {\n                selectedApp = getWebList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));\n                type = 'web';\n            }\n            else if (getDesktopList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {\n                selectedApp = getDesktopList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));\n                type = 'desktop';\n            }\n            else if (getExtensionList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name))) {\n                selectedApp = getExtensionList().find((app) => lowerCaseCompare(app.name, walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name));\n                type = 'extension';\n            }\n            if (selectedApp) {\n                let deeplink;\n                if (selectedApp.hasOwnProperty('links')) {\n                    deeplink = selectedApp.links[(_a = selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.network.type) !== null && _a !== void 0 ? _a : this.preferredNetwork];\n                }\n                else if (selectedApp.hasOwnProperty('deepLink')) {\n                    deeplink = selectedApp.deepLink;\n                }\n                return {\n                    name: walletInfo.name,\n                    icon: (_b = walletInfo.icon) !== null && _b !== void 0 ? _b : selectedApp.logo,\n                    deeplink,\n                    type\n                };\n            }\n            return walletInfo;\n        });\n    }\n    getPeer(account) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            let peer;\n            if (account) {\n                logger.log('getPeer', 'We have an account', account);\n                const postMessagePeers = (_b = (yield ((_a = this.postMessageTransport) === null || _a === void 0 ? void 0 : _a.getPeers()))) !== null && _b !== void 0 ? _b : [];\n                const p2pPeers = (_d = (yield ((_c = this.p2pTransport) === null || _c === void 0 ? void 0 : _c.getPeers()))) !== null && _d !== void 0 ? _d : [];\n                const peers = [...postMessagePeers, ...p2pPeers];\n                logger.log('getPeer', 'Found peers', peers, account);\n                peer = peers.find((peerEl) => peerEl.senderId === account.senderId);\n                if (!peer) {\n                    // We could not find an exact match for a sender, so we most likely received it over a relay\n                    peer = peers.find((peerEl) => peerEl.extensionId === account.origin.id);\n                }\n            }\n            else {\n                peer = yield this._activePeer.promise;\n                logger.log('getPeer', 'Active peer', peer);\n            }\n            if (!peer) {\n                throw new Error('No matching peer found.');\n            }\n            return peer;\n        });\n    }\n    /**\n     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n     * to the DApp over the transport.\n     *\n     * @param requestInput The BeaconMessage to be sent to the wallet\n     * @param account The account that the message will be sent to\n     */\n    makeRequest(requestInput) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const messageId = yield generateGUID();\n            console.time(messageId);\n            logger.log('makeRequest', 'starting');\n            yield this.init();\n            console.timeLog(messageId, 'init done');\n            logger.log('makeRequest', 'after init');\n            if (yield this.addRequestAndCheckIfRateLimited()) {\n                this.events\n                    .emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED)\n                    .catch((emitError) => console.warn(emitError));\n                throw new Error('rate limit reached');\n            }\n            if (!(yield this.checkPermissions(requestInput.type))) {\n                this.events.emit(BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError));\n                throw new Error('No permissions to send this request to wallet!');\n            }\n            if (!this.beaconId) {\n                throw yield this.sendInternalError('BeaconID not defined');\n            }\n            const request = Object.assign({ id: messageId, version: '2', senderId: yield getSenderId(yield this.beaconId) }, requestInput);\n            const exposed = new ExposedPromise();\n            this.addOpenRequest(request.id, exposed);\n            const payload = yield new Serializer().serialize(request);\n            const account = yield this.getActiveAccount();\n            const peer = yield this.getPeer(account);\n            const walletInfo = yield this.getWalletInfo(peer, account);\n            logger.log('makeRequest', 'sending message', request);\n            console.timeLog(messageId, 'sending');\n            try {\n                yield (yield this.transport).send(payload, peer);\n            }\n            catch (sendError) {\n                this.events.emit(BeaconEvent.INTERNAL_ERROR, {\n                    text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',\n                    buttons: [\n                        {\n                            text: 'Reset Connection',\n                            actionCallback: () => __awaiter(this, void 0, void 0, function* () {\n                                yield closeToast();\n                                this.disconnect();\n                            })\n                        }\n                    ]\n                });\n                console.timeLog(messageId, 'send error');\n                throw sendError;\n            }\n            console.timeLog(messageId, 'sent');\n            this.events\n                .emit(messageEvents[requestInput.type].sent, {\n                walletInfo: Object.assign(Object.assign({}, walletInfo), { name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet' }),\n                extraInfo: {\n                    resetCallback: () => __awaiter(this, void 0, void 0, function* () {\n                        this.disconnect();\n                    })\n                }\n            })\n                .catch((emitError) => console.warn(emitError));\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return exposed.promise; // TODO: fix type\n        });\n    }\n    /**\n     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n     * to the DApp over the transport.\n     *\n     * @param requestInput The BeaconMessage to be sent to the wallet\n     * @param account The account that the message will be sent to\n     */\n    makeRequestV3(requestInput) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const messageId = yield generateGUID();\n            console.time(messageId);\n            logger.log('makeRequest', 'starting');\n            yield this.init();\n            console.timeLog(messageId, 'init done');\n            logger.log('makeRequest', 'after init');\n            if (yield this.addRequestAndCheckIfRateLimited()) {\n                this.events\n                    .emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED)\n                    .catch((emitError) => console.warn(emitError));\n                throw new Error('rate limit reached');\n            }\n            // if (!(await this.checkPermissions(requestInput.type as BeaconMessageType))) {\n            //   this.events.emit(BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError))\n            //   throw new Error('No permissions to send this request to wallet!')\n            // }\n            if (!this.beaconId) {\n                throw yield this.sendInternalError('BeaconID not defined');\n            }\n            const request = {\n                id: messageId,\n                version: '3',\n                senderId: yield getSenderId(yield this.beaconId),\n                message: requestInput\n            };\n            const exposed = new ExposedPromise();\n            this.addOpenRequest(request.id, exposed);\n            const payload = yield new Serializer().serialize(request);\n            const account = yield this.getActiveAccount();\n            const peer = yield this.getPeer(account);\n            const walletInfo = yield this.getWalletInfo(peer, account);\n            logger.log('makeRequest', 'sending message', request);\n            console.timeLog(messageId, 'sending');\n            try {\n                yield (yield this.transport).send(payload, peer);\n            }\n            catch (sendError) {\n                this.events.emit(BeaconEvent.INTERNAL_ERROR, {\n                    text: 'Unable to send message. If this problem persists, please reset the connection and pair your wallet again.',\n                    buttons: [\n                        {\n                            text: 'Reset Connection',\n                            actionCallback: () => __awaiter(this, void 0, void 0, function* () {\n                                yield closeToast();\n                                this.disconnect();\n                            })\n                        }\n                    ]\n                });\n                console.timeLog(messageId, 'send error');\n                throw sendError;\n            }\n            console.timeLog(messageId, 'sent');\n            const index = requestInput.type;\n            this.events\n                .emit(messageEvents[index].sent, {\n                walletInfo: Object.assign(Object.assign({}, walletInfo), { name: (_a = walletInfo.name) !== null && _a !== void 0 ? _a : 'Wallet' }),\n                extraInfo: {\n                    resetCallback: () => __awaiter(this, void 0, void 0, function* () {\n                        this.disconnect();\n                    })\n                }\n            })\n                .catch((emitError) => console.warn(emitError));\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return exposed.promise; // TODO: fix type\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.postMessageTransport = undefined;\n            this.p2pTransport = undefined;\n            yield Promise.all([this.clearActiveAccount(), (yield this.transport).disconnect()]);\n        });\n    }\n    /**\n     * Adds a requests to the \"openRequests\" set so we know what messages have already been answered/handled.\n     *\n     * @param id The ID of the message\n     * @param promise A promise that resolves once the response for that specific message is received\n     */\n    addOpenRequest(id, promise) {\n        logger.log('addOpenRequest', this.name, `adding request ${id} and waiting for answer`);\n        this.openRequests.set(id, promise);\n    }\n}\n//# sourceMappingURL=DAppClient.js.map"]},"metadata":{},"sourceType":"module"}