{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ready, crypto_generichash, from_string, crypto_sign_detached, crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '@airgap/beacon-utils';\nimport { MatrixClient } from '../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../matrix-client/models/MatrixMessage';\nimport { StorageKey } from '@airgap/beacon-types';\nimport { PeerManager, BEACON_VERSION, getSenderId, Logger, CommunicationClient } from '@airgap/beacon-core';\nimport { ExposedPromise, generateGUID } from '@airgap/beacon-utils';\nconst logger = new Logger('P2PCommunicationClient');\nexport const KNOWN_RELAY_SERVERS = ['beacon-node-1.diamond.papers.tech', 'beacon-node-1.sky.papers.tech', 'beacon-node-2.sky.papers.tech', 'beacon-node-1.hope.papers.tech', 'beacon-node-1.hope-2.papers.tech', 'beacon-node-1.hope-3.papers.tech', 'beacon-node-1.hope-4.papers.tech', 'beacon-node-1.hope-5.papers.tech'];\n/**\n * @internalapi\n */\n\nexport class P2PCommunicationClient extends CommunicationClient {\n  constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n    super(keyPair);\n    this.name = name;\n    this.replicationCount = replicationCount;\n    this.storage = storage;\n    this.iconUrl = iconUrl;\n    this.appUrl = appUrl;\n    this.client = new ExposedPromise();\n    this.activeListeners = new Map();\n    this.ignoredRooms = [];\n    this.loginCounter = 0;\n    logger.log('constructor', 'P2PCommunicationClient created');\n    const nodes = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;\n    this.ENABLED_RELAY_SERVERS = nodes;\n  }\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: yield generateGUID(),\n        type: 'p2p-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n\n      return info;\n    });\n  }\n\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: request.id,\n        type: 'p2p-pairing-response',\n        name: this.name,\n        version: request.version,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n\n      return info;\n    });\n  }\n\n  getRelayServer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.relayServer) {\n        return this.relayServer.promise;\n      } else {\n        this.relayServer = new ExposedPromise();\n      }\n\n      const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n\n      if (node && node.length > 0) {\n        this.relayServer.resolve(node);\n        return node;\n      }\n\n      const nodes = [...this.ENABLED_RELAY_SERVERS];\n\n      while (nodes.length > 0) {\n        const index = Math.floor(Math.random() * nodes.length);\n        const server = nodes[index];\n\n        try {\n          yield axios.get(`https://${server}/_matrix/client/versions`);\n          this.storage.set(StorageKey.MATRIX_SELECTED_NODE, server).catch(error => logger.log(error));\n          this.relayServer.resolve(server);\n          return server;\n        } catch (relayError) {\n          logger.log(`Ignoring server \"${server}\", trying another one...`);\n          nodes.splice(index, 1);\n        }\n      }\n\n      this.relayServer.reject(`No matrix server reachable!`);\n      throw new Error(`No matrix server reachable!`);\n    });\n  }\n\n  tryJoinRooms(roomId) {\n    let retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield (yield this.client.promise).joinRooms(roomId);\n      } catch (error) {\n        if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {\n          // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n          logger.log(`Retrying to join...`, error);\n          setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            yield this.tryJoinRooms(roomId, retry + 1);\n          }), 200);\n        } else {\n          logger.log(`Failed to join after ${retry} tries.`, error);\n        }\n      }\n    });\n  }\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('start', 'starting client');\n      yield ready;\n      const loginRawDigest = crypto_generichash(32, from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));\n      const rawSignature = crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n      logger.log('start', `connecting to server`);\n      const relayServer = yield this.getRelayServer();\n      const client = MatrixClient.create({\n        baseUrl: `https://${relayServer}`,\n        storage: this.storage\n      });\n\n      this.initialListener = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n          if (this.initialEvent.timestamp < event.timestamp) {\n            this.initialEvent = event;\n          }\n        } else {\n          this.initialEvent = event;\n        }\n      });\n\n      client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n      client.subscribe(MatrixClientEventType.INVITE, event => __awaiter(this, void 0, void 0, function* () {\n        let member;\n\n        if (event.content.members.length === 1) {\n          // If there is only one member we know it's a new room\n          // TODO: Use the \"sender\" of the event instead\n          member = event.content.members[0];\n        }\n\n        yield this.tryJoinRooms(event.content.roomId);\n\n        if (member) {\n          yield this.updateRelayServer(member);\n          yield this.updatePeerRoom(member, event.content.roomId);\n        }\n      }));\n      logger.log('start', 'login', yield this.getPublicKeyHash(), 'on', relayServer);\n\n      try {\n        yield client.start({\n          id: yield this.getPublicKeyHash(),\n          password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n          deviceId: toHex(this.keyPair.publicKey)\n        });\n      } catch (error) {\n        console.log('ERROR, RETRYING');\n        yield this.reset(); // If we can't log in, let's reset\n\n        console.log('TRYING AGAIN');\n\n        if (this.loginCounter <= this.ENABLED_RELAY_SERVERS.length) {\n          this.loginCounter++;\n          this.start();\n          return;\n        } else {\n          throw new Error('Too many login attempts. Try again later.');\n        }\n      }\n\n      console.log('client is ready');\n      this.client.resolve(client);\n    });\n  }\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.client.isResolved()) {\n        yield (yield this.client.promise).stop().catch(error => logger.error(error));\n      }\n\n      yield this.reset();\n    });\n  }\n\n  reset() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch(error => logger.log(error)); // Instead of resetting everything, maybe we should make sure a new instance is created?\n\n      this.relayServer = undefined;\n      this.client = new ExposedPromise();\n      this.initialEvent = undefined;\n      this.initialListener = undefined;\n    });\n  }\n\n  listenForEncryptedMessage(senderPublicKey, messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.activeListeners.has(senderPublicKey)) {\n        return;\n      }\n\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n\n      const callbackFunction = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n          let payload;\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n\n          try {\n            payload = Buffer.from(event.content.message.content, 'hex'); // content can be non-hex if it's a connection open request\n          } catch (_a) {\n            /* */\n          }\n\n          if (payload && payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n            try {\n              const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx); // logger.log(\n              //   'listenForEncryptedMessage',\n              //   'encrypted message received',\n              //   decryptedMessage,\n              //   await new Serializer().deserialize(decryptedMessage)\n              // )\n              // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n              // TODO: Add check for correct decryption key / sender ID\n\n              messageCallback(decryptedMessage);\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      });\n\n      this.activeListeners.set(senderPublicKey, callbackFunction);\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n      const lastEvent = this.initialEvent;\n\n      if (lastEvent && lastEvent.timestamp && new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {\n        logger.log('listenForEncryptedMessage', 'Handling previous event');\n        yield callbackFunction(lastEvent);\n      } else {\n        logger.log('listenForEncryptedMessage', 'No previous event found');\n      }\n\n      const initialListener = this.initialListener;\n\n      if (initialListener) {\n        ;\n        (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n      }\n\n      this.initialListener = undefined;\n      this.initialEvent = undefined;\n    });\n  }\n\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n\n      if (!listener) {\n        return;\n      }\n\n      ;\n      (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);\n      this.activeListeners.clear();\n    });\n  }\n\n  sendMessage(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);\n      const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, peer.relayServer);\n      const roomId = yield this.getRelevantRoom(recipient); // Before we send the message, we have to wait for the join to be accepted.\n\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n\n      const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);\n      (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          (yield this.client.promise).sendTextMessage(newRoomId, encryptedMessage).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `not forbidden`, error);\n        }\n      }));\n    });\n  }\n\n  updatePeerRoom(sender, roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const room = roomIds[sender];\n\n      if (room && room[1]) {\n        // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n        this.ignoredRooms.push(room[1]);\n      }\n\n      roomIds[sender] = roomId;\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds); // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n    });\n  }\n\n  deleteRoomIdFromRooms(roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const newRoomIds = Object.entries(roomIds).filter(entry => entry[1] !== roomId).reduce((pv, cv) => Object.assign(Object.assign({}, pv), {\n        [cv[0]]: cv[1]\n      }), {});\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds); // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n\n      this.ignoredRooms.push(roomId);\n    });\n  }\n\n  listenForChannelOpening(messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n          logger.log(`listenForChannelOpening`, `channel opening`, JSON.stringify(event));\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n          const splits = event.content.message.content.split(':');\n          const payload = Buffer.from(splits[splits.length - 1], 'hex');\n\n          if (payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n            try {\n              const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n              messageCallback(Object.assign(Object.assign({}, pairingResponse), {\n                senderId: yield getSenderId(pairingResponse.publicKey)\n              }));\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      }));\n    });\n  }\n\n  waitForJoin(roomId) {\n    let retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return __awaiter(this, void 0, void 0, function* () {\n      // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.\n      // TODO: Improve to listen to \"JOIN\" event\n      const room = yield (yield this.client.promise).getRoomById(roomId);\n      logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);\n\n      if (room.members.length >= 2 || room.members.length === 0) {\n        // 0 means it's an unknown room, we don't need to wait\n        return;\n      } else {\n        if (retry <= 200) {\n          // On mobile, due to app switching, we potentially have to wait for a long time\n          logger.log(`Waiting for join... Try: ${retry}`);\n          return new Promise(resolve => {\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n              resolve(this.waitForJoin(roomId, retry + 1));\n            }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n          });\n        } else {\n          throw new Error(`No one joined after ${retry} tries.`);\n        }\n      }\n    });\n  }\n\n  sendPairingResponse(pairingRequest) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`sendPairingResponse`);\n      const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, pairingRequest.relayServer); // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n\n      const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n      yield this.updatePeerRoom(recipient, roomId); // Before we send the message, we have to wait for the join to be accepted.\n\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n      // TODO: remove v1 backwards-compatibility\n\n      const message = typeof pairingRequest.version === 'undefined' ? yield this.getPublicKey() // v1\n      : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2\n\n      const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n      const msg = ['@channel-open', recipient, encryptedMessage].join(':');\n      (yield this.client.promise).sendTextMessage(roomId, msg).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          (yield this.client.promise).sendTextMessage(newRoomId, msg).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `not forbidden`, error);\n        }\n      }));\n    });\n  }\n\n  isTextMessage(content) {\n    return content.message.type === MatrixMessageType.TEXT;\n  }\n\n  updateRelayServer(sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n\n      const senderHash = split.shift();\n      const relayServer = split.join(':');\n      const manager = localStorage.getItem('beacon:communication-peers-dapp') ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP) : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n      const peers = yield manager.getPeers();\n      const promiseArray = peers.map(peer => __awaiter(this, void 0, void 0, function* () {\n        const hash = `@${yield getHexHash(Buffer.from(peer.publicKey, 'hex'))}`;\n\n        if (hash === senderHash) {\n          if (peer.relayServer !== relayServer) {\n            peer.relayServer = relayServer;\n            yield manager.addPeer(peer);\n          }\n        }\n      }));\n      yield Promise.all(promiseArray);\n    });\n  }\n\n  isChannelOpenMessage(content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n    });\n  }\n\n  isSender(event, senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n    });\n  }\n\n  getRelevantRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      let roomId = roomIds[recipient];\n\n      if (!roomId) {\n        logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);\n        const room = yield this.getRelevantJoinedRoom(recipient);\n        roomId = room.id;\n        roomIds[recipient] = room.id;\n        yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n      }\n\n      logger.log(`getRelevantRoom`, `Using room ${roomId}`);\n      return roomId;\n    });\n  }\n\n  getRelevantJoinedRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const joinedRooms = yield (yield this.client.promise).joinedRooms;\n      logger.log('checking joined rooms', joinedRooms, recipient);\n      const relevantRooms = joinedRooms.filter(roomElement => !this.ignoredRooms.some(id => roomElement.id === id)).filter(roomElement => roomElement.members.some(member => member === recipient));\n      let room; // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.\n      // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.\n\n      if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {\n        logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);\n        const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n        room = yield (yield this.client.promise).getRoomById(roomId);\n        logger.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);\n        yield this.waitForJoin(roomId);\n        logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);\n      } else {\n        room = relevantRooms[0];\n        logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);\n      }\n\n      return room;\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/communication-client/P2PCommunicationClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ready, crypto_generichash, from_string, crypto_sign_detached, crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '@airgap/beacon-utils';\nimport { MatrixClient } from '../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../matrix-client/models/MatrixMessage';\nimport { StorageKey } from '@airgap/beacon-types';\nimport { PeerManager, BEACON_VERSION, getSenderId, Logger, CommunicationClient } from '@airgap/beacon-core';\nimport { ExposedPromise, generateGUID } from '@airgap/beacon-utils';\nconst logger = new Logger('P2PCommunicationClient');\nexport const KNOWN_RELAY_SERVERS = [\n    'beacon-node-1.diamond.papers.tech',\n    'beacon-node-1.sky.papers.tech',\n    'beacon-node-2.sky.papers.tech',\n    'beacon-node-1.hope.papers.tech',\n    'beacon-node-1.hope-2.papers.tech',\n    'beacon-node-1.hope-3.papers.tech',\n    'beacon-node-1.hope-4.papers.tech',\n    'beacon-node-1.hope-5.papers.tech'\n];\n/**\n * @internalapi\n */\nexport class P2PCommunicationClient extends CommunicationClient {\n    constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n        super(keyPair);\n        this.name = name;\n        this.replicationCount = replicationCount;\n        this.storage = storage;\n        this.iconUrl = iconUrl;\n        this.appUrl = appUrl;\n        this.client = new ExposedPromise();\n        this.activeListeners = new Map();\n        this.ignoredRooms = [];\n        this.loginCounter = 0;\n        logger.log('constructor', 'P2PCommunicationClient created');\n        const nodes = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;\n        this.ENABLED_RELAY_SERVERS = nodes;\n    }\n    getPairingRequestInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = {\n                id: yield generateGUID(),\n                type: 'p2p-pairing-request',\n                name: this.name,\n                version: BEACON_VERSION,\n                publicKey: yield this.getPublicKey(),\n                relayServer: yield this.getRelayServer()\n            };\n            if (this.iconUrl) {\n                info.icon = this.iconUrl;\n            }\n            if (this.appUrl) {\n                info.appUrl = this.appUrl;\n            }\n            return info;\n        });\n    }\n    getPairingResponseInfo(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = {\n                id: request.id,\n                type: 'p2p-pairing-response',\n                name: this.name,\n                version: request.version,\n                publicKey: yield this.getPublicKey(),\n                relayServer: yield this.getRelayServer()\n            };\n            if (this.iconUrl) {\n                info.icon = this.iconUrl;\n            }\n            if (this.appUrl) {\n                info.appUrl = this.appUrl;\n            }\n            return info;\n        });\n    }\n    getRelayServer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.relayServer) {\n                return this.relayServer.promise;\n            }\n            else {\n                this.relayServer = new ExposedPromise();\n            }\n            const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n            if (node && node.length > 0) {\n                this.relayServer.resolve(node);\n                return node;\n            }\n            const nodes = [...this.ENABLED_RELAY_SERVERS];\n            while (nodes.length > 0) {\n                const index = Math.floor(Math.random() * nodes.length);\n                const server = nodes[index];\n                try {\n                    yield axios.get(`https://${server}/_matrix/client/versions`);\n                    this.storage\n                        .set(StorageKey.MATRIX_SELECTED_NODE, server)\n                        .catch((error) => logger.log(error));\n                    this.relayServer.resolve(server);\n                    return server;\n                }\n                catch (relayError) {\n                    logger.log(`Ignoring server \"${server}\", trying another one...`);\n                    nodes.splice(index, 1);\n                }\n            }\n            this.relayServer.reject(`No matrix server reachable!`);\n            throw new Error(`No matrix server reachable!`);\n        });\n    }\n    tryJoinRooms(roomId, retry = 1) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield (yield this.client.promise).joinRooms(roomId);\n            }\n            catch (error) {\n                if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {\n                    // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n                    logger.log(`Retrying to join...`, error);\n                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                        yield this.tryJoinRooms(roomId, retry + 1);\n                    }), 200);\n                }\n                else {\n                    logger.log(`Failed to join after ${retry} tries.`, error);\n                }\n            }\n        });\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('start', 'starting client');\n            yield ready;\n            const loginRawDigest = crypto_generichash(32, from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));\n            const rawSignature = crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n            logger.log('start', `connecting to server`);\n            const relayServer = yield this.getRelayServer();\n            const client = MatrixClient.create({\n                baseUrl: `https://${relayServer}`,\n                storage: this.storage\n            });\n            this.initialListener = (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n                    if (this.initialEvent.timestamp < event.timestamp) {\n                        this.initialEvent = event;\n                    }\n                }\n                else {\n                    this.initialEvent = event;\n                }\n            });\n            client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n            client.subscribe(MatrixClientEventType.INVITE, (event) => __awaiter(this, void 0, void 0, function* () {\n                let member;\n                if (event.content.members.length === 1) {\n                    // If there is only one member we know it's a new room\n                    // TODO: Use the \"sender\" of the event instead\n                    member = event.content.members[0];\n                }\n                yield this.tryJoinRooms(event.content.roomId);\n                if (member) {\n                    yield this.updateRelayServer(member);\n                    yield this.updatePeerRoom(member, event.content.roomId);\n                }\n            }));\n            logger.log('start', 'login', yield this.getPublicKeyHash(), 'on', relayServer);\n            try {\n                yield client.start({\n                    id: yield this.getPublicKeyHash(),\n                    password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n                    deviceId: toHex(this.keyPair.publicKey)\n                });\n            }\n            catch (error) {\n                console.log('ERROR, RETRYING');\n                yield this.reset(); // If we can't log in, let's reset\n                console.log('TRYING AGAIN');\n                if (this.loginCounter <= this.ENABLED_RELAY_SERVERS.length) {\n                    this.loginCounter++;\n                    this.start();\n                    return;\n                }\n                else {\n                    throw new Error('Too many login attempts. Try again later.');\n                }\n            }\n            console.log('client is ready');\n            this.client.resolve(client);\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.client.isResolved()) {\n                yield (yield this.client.promise).stop().catch((error) => logger.error(error));\n            }\n            yield this.reset();\n        });\n    }\n    reset() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch((error) => logger.log(error));\n            yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch((error) => logger.log(error));\n            yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch((error) => logger.log(error));\n            // Instead of resetting everything, maybe we should make sure a new instance is created?\n            this.relayServer = undefined;\n            this.client = new ExposedPromise();\n            this.initialEvent = undefined;\n            this.initialListener = undefined;\n        });\n    }\n    listenForEncryptedMessage(senderPublicKey, messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.activeListeners.has(senderPublicKey)) {\n                return;\n            }\n            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n            const callbackFunction = (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n                    let payload;\n                    yield this.updateRelayServer(event.content.message.sender);\n                    yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n                    try {\n                        payload = Buffer.from(event.content.message.content, 'hex');\n                        // content can be non-hex if it's a connection open request\n                    }\n                    catch (_a) {\n                        /* */\n                    }\n                    if (payload && payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n                        try {\n                            const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx);\n                            // logger.log(\n                            //   'listenForEncryptedMessage',\n                            //   'encrypted message received',\n                            //   decryptedMessage,\n                            //   await new Serializer().deserialize(decryptedMessage)\n                            // )\n                            // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n                            // TODO: Add check for correct decryption key / sender ID\n                            messageCallback(decryptedMessage);\n                        }\n                        catch (decryptionError) {\n                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                        }\n                    }\n                }\n            });\n            this.activeListeners.set(senderPublicKey, callbackFunction);\n            (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n            const lastEvent = this.initialEvent;\n            if (lastEvent &&\n                lastEvent.timestamp &&\n                new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {\n                logger.log('listenForEncryptedMessage', 'Handling previous event');\n                yield callbackFunction(lastEvent);\n            }\n            else {\n                logger.log('listenForEncryptedMessage', 'No previous event found');\n            }\n            const initialListener = this.initialListener;\n            if (initialListener) {\n                ;\n                (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n            }\n            this.initialListener = undefined;\n            this.initialEvent = undefined;\n        });\n    }\n    unsubscribeFromEncryptedMessage(senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listener = this.activeListeners.get(senderPublicKey);\n            if (!listener) {\n                return;\n            }\n            ;\n            (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);\n            this.activeListeners.delete(senderPublicKey);\n        });\n    }\n    unsubscribeFromEncryptedMessages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            ;\n            (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);\n            this.activeListeners.clear();\n        });\n    }\n    sendMessage(message, peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { sharedTx } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);\n            const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));\n            const recipient = recipientString(recipientHash, peer.relayServer);\n            const roomId = yield this.getRelevantRoom(recipient);\n            // Before we send the message, we have to wait for the join to be accepted.\n            yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n            const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);\n            (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch((error) => __awaiter(this, void 0, void 0, function* () {\n                if (error.errcode === 'M_FORBIDDEN') {\n                    // Room doesn't exist\n                    logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n                    yield this.deleteRoomIdFromRooms(roomId);\n                    const newRoomId = yield this.getRelevantRoom(recipient);\n                    (yield this.client.promise)\n                        .sendTextMessage(newRoomId, encryptedMessage)\n                        .catch((error2) => __awaiter(this, void 0, void 0, function* () {\n                        logger.log(`sendMessage`, `inner error`, error2);\n                    }));\n                }\n                else {\n                    logger.log(`sendMessage`, `not forbidden`, error);\n                }\n            }));\n        });\n    }\n    updatePeerRoom(sender, roomId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n            const split = sender.split(':');\n            if (split.length < 2 || !split[0].startsWith('@')) {\n                throw new Error('Invalid sender');\n            }\n            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n            const room = roomIds[sender];\n            if (room && room[1]) {\n                // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n                this.ignoredRooms.push(room[1]);\n            }\n            roomIds[sender] = roomId;\n            yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n            // TODO: We also need to delete the room from the sync state\n            // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n        });\n    }\n    deleteRoomIdFromRooms(roomId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n            const newRoomIds = Object.entries(roomIds)\n                .filter((entry) => entry[1] !== roomId)\n                .reduce((pv, cv) => (Object.assign(Object.assign({}, pv), { [cv[0]]: cv[1] })), {});\n            yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds);\n            // TODO: We also need to delete the room from the sync state\n            // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n            this.ignoredRooms.push(roomId);\n        });\n    }\n    listenForChannelOpening(messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            ;\n            (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n                    logger.log(`listenForChannelOpening`, `channel opening`, JSON.stringify(event));\n                    yield this.updateRelayServer(event.content.message.sender);\n                    yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n                    const splits = event.content.message.content.split(':');\n                    const payload = Buffer.from(splits[splits.length - 1], 'hex');\n                    if (payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n                        try {\n                            const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n                            messageCallback(Object.assign(Object.assign({}, pairingResponse), { senderId: yield getSenderId(pairingResponse.publicKey) }));\n                        }\n                        catch (decryptionError) {\n                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                        }\n                    }\n                }\n            }));\n        });\n    }\n    waitForJoin(roomId, retry = 0) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.\n            // TODO: Improve to listen to \"JOIN\" event\n            const room = yield (yield this.client.promise).getRoomById(roomId);\n            logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);\n            if (room.members.length >= 2 || room.members.length === 0) {\n                // 0 means it's an unknown room, we don't need to wait\n                return;\n            }\n            else {\n                if (retry <= 200) {\n                    // On mobile, due to app switching, we potentially have to wait for a long time\n                    logger.log(`Waiting for join... Try: ${retry}`);\n                    return new Promise((resolve) => {\n                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                            resolve(this.waitForJoin(roomId, retry + 1));\n                        }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n                    });\n                }\n                else {\n                    throw new Error(`No one joined after ${retry} tries.`);\n                }\n            }\n        });\n    }\n    sendPairingResponse(pairingRequest) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendPairingResponse`);\n            const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n            const recipient = recipientString(recipientHash, pairingRequest.relayServer);\n            // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n            const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n            yield this.updatePeerRoom(recipient, roomId);\n            // Before we send the message, we have to wait for the join to be accepted.\n            yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n            // TODO: remove v1 backwards-compatibility\n            const message = typeof pairingRequest.version === 'undefined'\n                ? yield this.getPublicKey() // v1\n                : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2\n            const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n            const msg = ['@channel-open', recipient, encryptedMessage].join(':');\n            (yield this.client.promise).sendTextMessage(roomId, msg).catch((error) => __awaiter(this, void 0, void 0, function* () {\n                if (error.errcode === 'M_FORBIDDEN') {\n                    // Room doesn't exist\n                    logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n                    yield this.deleteRoomIdFromRooms(roomId);\n                    const newRoomId = yield this.getRelevantRoom(recipient);\n                    (yield this.client.promise).sendTextMessage(newRoomId, msg).catch((error2) => __awaiter(this, void 0, void 0, function* () {\n                        logger.log(`sendMessage`, `inner error`, error2);\n                    }));\n                }\n                else {\n                    logger.log(`sendMessage`, `not forbidden`, error);\n                }\n            }));\n        });\n    }\n    isTextMessage(content) {\n        return content.message.type === MatrixMessageType.TEXT;\n    }\n    updateRelayServer(sender) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n            const split = sender.split(':');\n            if (split.length < 2 || !split[0].startsWith('@')) {\n                throw new Error('Invalid sender');\n            }\n            const senderHash = split.shift();\n            const relayServer = split.join(':');\n            const manager = localStorage.getItem('beacon:communication-peers-dapp')\n                ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP)\n                : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n            const peers = yield manager.getPeers();\n            const promiseArray = peers.map((peer) => __awaiter(this, void 0, void 0, function* () {\n                const hash = `@${yield getHexHash(Buffer.from(peer.publicKey, 'hex'))}`;\n                if (hash === senderHash) {\n                    if (peer.relayServer !== relayServer) {\n                        peer.relayServer = relayServer;\n                        yield manager.addPeer(peer);\n                    }\n                }\n            }));\n            yield Promise.all(promiseArray);\n        });\n    }\n    isChannelOpenMessage(content) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n        });\n    }\n    isSender(event, senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n        });\n    }\n    getRelevantRoom(recipient) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n            let roomId = roomIds[recipient];\n            if (!roomId) {\n                logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);\n                const room = yield this.getRelevantJoinedRoom(recipient);\n                roomId = room.id;\n                roomIds[recipient] = room.id;\n                yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n            }\n            logger.log(`getRelevantRoom`, `Using room ${roomId}`);\n            return roomId;\n        });\n    }\n    getRelevantJoinedRoom(recipient) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const joinedRooms = yield (yield this.client.promise).joinedRooms;\n            logger.log('checking joined rooms', joinedRooms, recipient);\n            const relevantRooms = joinedRooms\n                .filter((roomElement) => !this.ignoredRooms.some((id) => roomElement.id === id))\n                .filter((roomElement) => roomElement.members.some((member) => member === recipient));\n            let room;\n            // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.\n            // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.\n            if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {\n                logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);\n                const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n                room = yield (yield this.client.promise).getRoomById(roomId);\n                logger.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);\n                yield this.waitForJoin(roomId);\n                logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);\n            }\n            else {\n                room = relevantRooms[0];\n                logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);\n            }\n            return room;\n        });\n    }\n}\n//# sourceMappingURL=P2PCommunicationClient.js.map"]},"metadata":{},"sourceType":"module"}