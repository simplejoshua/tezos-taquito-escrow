{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport axios from 'axios';\nimport { keys } from '@airgap/beacon-utils';\nconst CLIENT_API_R0 = '/_matrix/client/r0';\n/**\n * Handling the HTTP connection to the matrix synapse node\n */\n\nexport class MatrixHttpClient {\n  constructor(baseUrl) {\n    this.baseUrl = baseUrl;\n    this.cancelTokenSource = axios.CancelToken.source();\n  }\n  /**\n   * Get data from the synapse node\n   *\n   * @param endpoint\n   * @param options\n   */\n\n\n  get(endpoint, params, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.send('GET', endpoint, options, params);\n    });\n  }\n  /**\n   * Post data to the synapse node\n   *\n   * @param endpoint\n   * @param body\n   * @param options\n   * @param params\n   */\n\n\n  post(endpoint, body, options, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.send('POST', endpoint, options, params, body);\n    });\n  }\n  /**\n   * Put data to the synapse node\n   *\n   * @param endpoint\n   * @param body\n   * @param options\n   * @param params\n   */\n\n\n  put(endpoint, body, options, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.send('PUT', endpoint, options, params, body);\n    });\n  }\n\n  cancelAllRequests() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.cancelTokenSource.cancel('Manually cancelled');\n    });\n  }\n  /**\n   * Send a request to the synapse node\n   *\n   * @param method\n   * @param endpoint\n   * @param config\n   * @param requestParams\n   * @param data\n   */\n\n\n  send(method, endpoint, config, requestParams, data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const headers = config ? this.getHeaders(config) : undefined;\n      const params = requestParams ? this.getParams(requestParams) : undefined;\n      let response;\n\n      try {\n        response = yield axios.request({\n          method,\n          url: endpoint,\n          baseURL: this.apiUrl(CLIENT_API_R0),\n          headers,\n          data,\n          params,\n          cancelToken: this.cancelTokenSource.token\n        });\n      } catch (axiosError) {\n        throw axiosError.response.data;\n      }\n\n      return response.data;\n    });\n  }\n  /**\n   * Get the headers based on the options object\n   *\n   * @param options\n   */\n\n\n  getHeaders(options) {\n    const headers = {};\n    const entries = [];\n\n    if (options.accessToken) {\n      entries.push(['Authorization', `Bearer ${options.accessToken}`]);\n    }\n\n    if (entries.length === 0) {\n      return undefined;\n    }\n\n    for (const [key, value] of entries) {\n      headers[key] = value;\n    }\n\n    return headers;\n  }\n  /**\n   * Get parameters\n   *\n   * @param _params\n   */\n\n\n  getParams(_params) {\n    if (!_params) {\n      return undefined;\n    }\n\n    const params = Object.assign(_params, {});\n    keys(params).forEach(key => params[key] === undefined && delete params[key]);\n    return params;\n  }\n  /**\n   * Construct API URL\n   */\n\n\n  apiUrl() {\n    const apiBase = this.baseUrl.endsWith('/') ? this.baseUrl.substr(0, this.baseUrl.length - 1) : this.baseUrl;\n\n    for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n      parts[_key] = arguments[_key];\n    }\n\n    const apiParts = parts.map(path => path.startsWith('/') ? path.substr(1) : path);\n    return [apiBase, ...apiParts].join('/');\n  }\n\n}","map":{"version":3,"sources":["../../../src/matrix-client/MatrixHttpClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport axios from 'axios';\nimport { keys } from '@airgap/beacon-utils';\nconst CLIENT_API_R0 = '/_matrix/client/r0';\n/**\n * Handling the HTTP connection to the matrix synapse node\n */\nexport class MatrixHttpClient {\n    constructor(baseUrl) {\n        this.baseUrl = baseUrl;\n        this.cancelTokenSource = axios.CancelToken.source();\n    }\n    /**\n     * Get data from the synapse node\n     *\n     * @param endpoint\n     * @param options\n     */\n    get(endpoint, params, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.send('GET', endpoint, options, params);\n        });\n    }\n    /**\n     * Post data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    post(endpoint, body, options, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.send('POST', endpoint, options, params, body);\n        });\n    }\n    /**\n     * Put data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    put(endpoint, body, options, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.send('PUT', endpoint, options, params, body);\n        });\n    }\n    cancelAllRequests() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.cancelTokenSource.cancel('Manually cancelled');\n        });\n    }\n    /**\n     * Send a request to the synapse node\n     *\n     * @param method\n     * @param endpoint\n     * @param config\n     * @param requestParams\n     * @param data\n     */\n    send(method, endpoint, config, requestParams, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const headers = config ? this.getHeaders(config) : undefined;\n            const params = requestParams ? this.getParams(requestParams) : undefined;\n            let response;\n            try {\n                response = yield axios.request({\n                    method,\n                    url: endpoint,\n                    baseURL: this.apiUrl(CLIENT_API_R0),\n                    headers,\n                    data,\n                    params,\n                    cancelToken: this.cancelTokenSource.token\n                });\n            }\n            catch (axiosError) {\n                throw axiosError.response.data;\n            }\n            return response.data;\n        });\n    }\n    /**\n     * Get the headers based on the options object\n     *\n     * @param options\n     */\n    getHeaders(options) {\n        const headers = {};\n        const entries = [];\n        if (options.accessToken) {\n            entries.push(['Authorization', `Bearer ${options.accessToken}`]);\n        }\n        if (entries.length === 0) {\n            return undefined;\n        }\n        for (const [key, value] of entries) {\n            headers[key] = value;\n        }\n        return headers;\n    }\n    /**\n     * Get parameters\n     *\n     * @param _params\n     */\n    getParams(_params) {\n        if (!_params) {\n            return undefined;\n        }\n        const params = Object.assign(_params, {});\n        keys(params).forEach((key) => params[key] === undefined && delete params[key]);\n        return params;\n    }\n    /**\n     * Construct API URL\n     */\n    apiUrl(...parts) {\n        const apiBase = this.baseUrl.endsWith('/')\n            ? this.baseUrl.substr(0, this.baseUrl.length - 1)\n            : this.baseUrl;\n        const apiParts = parts.map((path) => (path.startsWith('/') ? path.substr(1) : path));\n        return [apiBase, ...apiParts].join('/');\n    }\n}\n//# sourceMappingURL=MatrixHttpClient.js.map"]},"metadata":{},"sourceType":"module"}