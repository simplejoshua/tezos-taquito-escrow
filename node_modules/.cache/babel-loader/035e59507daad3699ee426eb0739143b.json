{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nvar _excluded = [\"name\"];\nimport warning from \"rc-util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from './FieldContext';\nimport { allPromiseFinish } from './utils/asyncUtil';\nimport cloneDeep from './utils/cloneDeep';\nimport { defaultValidateMessages } from './utils/messages';\nimport NameMap from './utils/NameMap';\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue, setValues } from './utils/valueUtil';\nexport var FormStore = /*#__PURE__*/_createClass(function FormStore(forceRootUpdate) {\n  var _this = this;\n\n  _classCallCheck(this, FormStore);\n\n  this.formHooked = false;\n  this.forceRootUpdate = void 0;\n  this.subscribable = true;\n  this.store = {};\n  this.fieldEntities = [];\n  this.initialValues = {};\n  this.callbacks = {};\n  this.validateMessages = null;\n  this.preserve = null;\n  this.lastValidatePromise = null;\n\n  this.getForm = function () {\n    return {\n      getFieldValue: _this.getFieldValue,\n      getFieldsValue: _this.getFieldsValue,\n      getFieldError: _this.getFieldError,\n      getFieldWarning: _this.getFieldWarning,\n      getFieldsError: _this.getFieldsError,\n      isFieldsTouched: _this.isFieldsTouched,\n      isFieldTouched: _this.isFieldTouched,\n      isFieldValidating: _this.isFieldValidating,\n      isFieldsValidating: _this.isFieldsValidating,\n      resetFields: _this.resetFields,\n      setFields: _this.setFields,\n      setFieldValue: _this.setFieldValue,\n      setFieldsValue: _this.setFieldsValue,\n      validateFields: _this.validateFields,\n      submit: _this.submit,\n      _init: true,\n      getInternalHooks: _this.getInternalHooks\n    };\n  }; // ======================== Internal Hooks ========================\n\n\n  this.getInternalHooks = function (key) {\n    if (key === HOOK_MARK) {\n      _this.formHooked = true;\n      return {\n        dispatch: _this.dispatch,\n        initEntityValue: _this.initEntityValue,\n        registerField: _this.registerField,\n        useSubscribe: _this.useSubscribe,\n        setInitialValues: _this.setInitialValues,\n        destroyForm: _this.destroyForm,\n        setCallbacks: _this.setCallbacks,\n        setValidateMessages: _this.setValidateMessages,\n        getFields: _this.getFields,\n        setPreserve: _this.setPreserve,\n        getInitialValue: _this.getInitialValue,\n        registerWatch: _this.registerWatch\n      };\n    }\n\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n\n  this.useSubscribe = function (subscribable) {\n    _this.subscribable = subscribable;\n  };\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n\n\n  this.prevWithoutPreserves = null;\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n\n  this.setInitialValues = function (initialValues, init) {\n    _this.initialValues = initialValues || {};\n\n    if (init) {\n      var _this$prevWithoutPres;\n\n      var nextStore = setValues({}, initialValues, _this.store); // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n\n      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function (_ref) {\n        var namePath = _ref.key;\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      _this.prevWithoutPreserves = null;\n\n      _this.updateStore(nextStore);\n    }\n  };\n\n  this.destroyForm = function () {\n    var prevWithoutPreserves = new NameMap();\n\n    _this.getFieldEntities(true).forEach(function (entity) {\n      if (!_this.isMergedPreserve(entity.isPreserve())) {\n        prevWithoutPreserves.set(entity.getNamePath(), true);\n      }\n    });\n\n    _this.prevWithoutPreserves = prevWithoutPreserves;\n  };\n\n  this.getInitialValue = function (namePath) {\n    var initValue = getValue(_this.initialValues, namePath); // Not cloneDeep when without `namePath`\n\n    return namePath.length ? cloneDeep(initValue) : initValue;\n  };\n\n  this.setCallbacks = function (callbacks) {\n    _this.callbacks = callbacks;\n  };\n\n  this.setValidateMessages = function (validateMessages) {\n    _this.validateMessages = validateMessages;\n  };\n\n  this.setPreserve = function (preserve) {\n    _this.preserve = preserve;\n  }; // ============================= Watch ============================\n\n\n  this.watchList = [];\n\n  this.registerWatch = function (callback) {\n    _this.watchList.push(callback);\n\n    return function () {\n      _this.watchList = _this.watchList.filter(function (fn) {\n        return fn !== callback;\n      });\n    };\n  };\n\n  this.notifyWatch = function () {\n    var namePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // No need to cost perf when nothing need to watch\n\n    if (_this.watchList.length) {\n      var values = _this.getFieldsValue();\n\n      var allValues = _this.getFieldsValue(true);\n\n      _this.watchList.forEach(function (callback) {\n        callback(values, allValues, namePath);\n      });\n    }\n  }; // ========================== Dev Warning =========================\n\n\n  this.timeoutId = null;\n\n  this.warningUnhooked = function () {\n    if (process.env.NODE_ENV !== 'production' && !_this.timeoutId && typeof window !== 'undefined') {\n      _this.timeoutId = setTimeout(function () {\n        _this.timeoutId = null;\n\n        if (!_this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  }; // ============================ Store =============================\n\n\n  this.updateStore = function (nextStore) {\n    _this.store = nextStore;\n  }; // ============================ Fields ============================\n\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n\n\n  this.getFieldEntities = function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (!pure) {\n      return _this.fieldEntities;\n    }\n\n    return _this.fieldEntities.filter(function (field) {\n      return field.getNamePath().length;\n    });\n  };\n\n  this.getFieldsMap = function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cache = new NameMap();\n\n    _this.getFieldEntities(pure).forEach(function (field) {\n      var namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n\n    return cache;\n  };\n\n  this.getFieldEntitiesForNamePathList = function (nameList) {\n    if (!nameList) {\n      return _this.getFieldEntities(true);\n    }\n\n    var cache = _this.getFieldsMap(true);\n\n    return nameList.map(function (name) {\n      var namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  };\n\n  this.getFieldsValue = function (nameList, filterFunc) {\n    _this.warningUnhooked();\n\n    if (nameList === true && !filterFunc) {\n      return _this.store;\n    }\n\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);\n\n    var filteredNameList = [];\n    fieldEntities.forEach(function (entity) {\n      var _entity$isListField;\n\n      var namePath = 'INVALIDATE_NAME_PATH' in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath(); // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n\n      if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {\n        return;\n      }\n\n      if (!filterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        var meta = 'getMeta' in entity ? entity.getMeta() : null;\n\n        if (filterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));\n  };\n\n  this.getFieldValue = function (name) {\n    _this.warningUnhooked();\n\n    var namePath = getNamePath(name);\n    return getValue(_this.store, namePath);\n  };\n\n  this.getFieldsError = function (nameList) {\n    _this.warningUnhooked();\n\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);\n\n    return fieldEntities.map(function (entity, index) {\n      if (entity && !('INVALIDATE_NAME_PATH' in entity)) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n\n  this.getFieldError = function (name) {\n    _this.warningUnhooked();\n\n    var namePath = getNamePath(name);\n\n    var fieldError = _this.getFieldsError([namePath])[0];\n\n    return fieldError.errors;\n  };\n\n  this.getFieldWarning = function (name) {\n    _this.warningUnhooked();\n\n    var namePath = getNamePath(name);\n\n    var fieldError = _this.getFieldsError([namePath])[0];\n\n    return fieldError.warnings;\n  };\n\n  this.isFieldsTouched = function () {\n    _this.warningUnhooked();\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var arg0 = args[0],\n        arg1 = args[1];\n    var namePathList;\n    var isAllFieldsTouched = false;\n\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n\n    var fieldEntities = _this.getFieldEntities(true);\n\n    var isFieldTouched = function isFieldTouched(field) {\n      return field.isFieldTouched();\n    }; // ===== Will get fully compare when not config namePathList =====\n\n\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);\n    } // Generate a nest tree for validate\n\n\n    var map = new NameMap();\n    namePathList.forEach(function (shortNamePath) {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(function (field) {\n      var fieldNamePath = field.getNamePath(); // Find matched entity and put into list\n\n      namePathList.forEach(function (shortNamePath) {\n        if (shortNamePath.every(function (nameUnit, i) {\n          return fieldNamePath[i] === nameUnit;\n        })) {\n          map.update(shortNamePath, function (list) {\n            return [].concat(_toConsumableArray(list), [field]);\n          });\n        }\n      });\n    }); // Check if NameMap value is touched\n\n    var isNamePathListTouched = function isNamePathListTouched(entities) {\n      return entities.some(isFieldTouched);\n    };\n\n    var namePathListEntities = map.map(function (_ref2) {\n      var value = _ref2.value;\n      return value;\n    });\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n\n  this.isFieldTouched = function (name) {\n    _this.warningUnhooked();\n\n    return _this.isFieldsTouched([name]);\n  };\n\n  this.isFieldsValidating = function (nameList) {\n    _this.warningUnhooked();\n\n    var fieldEntities = _this.getFieldEntities();\n\n    if (!nameList) {\n      return fieldEntities.some(function (testField) {\n        return testField.isFieldValidating();\n      });\n    }\n\n    var namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(function (testField) {\n      var fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n\n  this.isFieldValidating = function (name) {\n    _this.warningUnhooked();\n\n    return _this.isFieldsValidating([name]);\n  };\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n\n\n  this.resetWithFieldInitialValue = function () {\n    var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Create cache\n\n    var cache = new NameMap();\n\n    var fieldEntities = _this.getFieldEntities(true);\n\n    fieldEntities.forEach(function (field) {\n      var initialValue = field.props.initialValue;\n      var namePath = field.getNamePath(); // Record only if has `initialValue`\n\n      if (initialValue !== undefined) {\n        var records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    }); // Reset\n\n    var resetWithFields = function resetWithFields(entities) {\n      entities.forEach(function (field) {\n        var initialValue = field.props.initialValue;\n\n        if (initialValue !== undefined) {\n          var namePath = field.getNamePath();\n\n          var formInitialValue = _this.getInitialValue(namePath);\n\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, \"Form already set 'initialValues' with path '\".concat(namePath.join('.'), \"'. Field can not overwrite it.\"));\n          } else {\n            var records = cache.get(namePath);\n\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, \"Multiple Field with path '\".concat(namePath.join('.'), \"' set 'initialValue'. Can not decide which one to pick.\"));\n            } else if (records) {\n              var originValue = _this.getFieldValue(namePath); // Set `initialValue`\n\n\n              if (!info.skipExist || originValue === undefined) {\n                _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n\n    var requiredFieldEntities;\n\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(function (namePath) {\n        var records = cache.get(namePath);\n\n        if (records) {\n          var _requiredFieldEntitie;\n\n          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function (r) {\n            return r.entity;\n          })));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n\n    resetWithFields(requiredFieldEntities);\n  };\n\n  this.resetFields = function (nameList) {\n    _this.warningUnhooked();\n\n    var prevStore = _this.store;\n\n    if (!nameList) {\n      _this.updateStore(setValues({}, _this.initialValues));\n\n      _this.resetWithFieldInitialValue();\n\n      _this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n\n      _this.notifyWatch();\n\n      return;\n    } // Reset by `nameList`\n\n\n    var namePathList = nameList.map(getNamePath);\n    namePathList.forEach(function (namePath) {\n      var initialValue = _this.getInitialValue(namePath);\n\n      _this.updateStore(setValue(_this.store, namePath, initialValue));\n    });\n\n    _this.resetWithFieldInitialValue({\n      namePathList: namePathList\n    });\n\n    _this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n\n    _this.notifyWatch(namePathList);\n  };\n\n  this.setFields = function (fields) {\n    _this.warningUnhooked();\n\n    var prevStore = _this.store;\n    var namePathList = [];\n    fields.forEach(function (fieldData) {\n      var name = fieldData.name,\n          data = _objectWithoutProperties(fieldData, _excluded);\n\n      var namePath = getNamePath(name);\n      namePathList.push(namePath); // Value\n\n      if ('value' in data) {\n        _this.updateStore(setValue(_this.store, namePath, data.value));\n      }\n\n      _this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n\n    _this.notifyWatch(namePathList);\n  };\n\n  this.getFields = function () {\n    var entities = _this.getFieldEntities(true);\n\n    var fields = entities.map(function (field) {\n      var namePath = field.getNamePath();\n      var meta = field.getMeta();\n\n      var fieldData = _objectSpread(_objectSpread({}, meta), {}, {\n        name: namePath,\n        value: _this.getFieldValue(namePath)\n      });\n\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  }; // =========================== Observer ===========================\n\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n\n\n  this.initEntityValue = function (entity) {\n    var initialValue = entity.props.initialValue;\n\n    if (initialValue !== undefined) {\n      var namePath = entity.getNamePath();\n      var prevValue = getValue(_this.store, namePath);\n\n      if (prevValue === undefined) {\n        _this.updateStore(setValue(_this.store, namePath, initialValue));\n      }\n    }\n  };\n\n  this.isMergedPreserve = function (fieldPreserve) {\n    var mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : _this.preserve;\n    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;\n  };\n\n  this.registerField = function (entity) {\n    _this.fieldEntities.push(entity);\n\n    var namePath = entity.getNamePath();\n\n    _this.notifyWatch([namePath]); // Set initial values\n\n\n    if (entity.props.initialValue !== undefined) {\n      var prevStore = _this.store;\n\n      _this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n\n      _this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    } // un-register field callback\n\n\n    return function (isListField, preserve) {\n      var subNamePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      _this.fieldEntities = _this.fieldEntities.filter(function (item) {\n        return item !== entity;\n      }); // Clean up store value if not preserve\n\n      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        var defaultValue = isListField ? undefined : _this.getInitialValue(namePath);\n\n        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function (field) {\n          return (// Only reset when no namePath exist\n            !matchNamePath(field.getNamePath(), namePath)\n          );\n        })) {\n          var _prevStore = _this.store;\n\n          _this.updateStore(setValue(_prevStore, namePath, defaultValue, true)); // Notify that field is unmount\n\n\n          _this.notifyObservers(_prevStore, [namePath], {\n            type: 'remove'\n          }); // Dependencies update\n\n\n          _this.triggerDependenciesUpdate(_prevStore, namePath);\n        }\n      }\n\n      _this.notifyWatch([namePath]);\n    };\n  };\n\n  this.dispatch = function (action) {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          var namePath = action.namePath,\n              value = action.value;\n\n          _this.updateValue(namePath, value);\n\n          break;\n        }\n\n      case 'validateField':\n        {\n          var _namePath = action.namePath,\n              triggerName = action.triggerName;\n\n          _this.validateFields([_namePath], {\n            triggerName: triggerName\n          });\n\n          break;\n        }\n\n      default: // Currently we don't have other action. Do nothing.\n\n    }\n  };\n\n  this.notifyObservers = function (prevStore, namePathList, info) {\n    if (_this.subscribable) {\n      var mergedInfo = _objectSpread(_objectSpread({}, info), {}, {\n        store: _this.getFieldsValue(true)\n      });\n\n      _this.getFieldEntities().forEach(function (_ref3) {\n        var onStoreChange = _ref3.onStoreChange;\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      _this.forceRootUpdate();\n    }\n  };\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n\n\n  this.triggerDependenciesUpdate = function (prevStore, namePath) {\n    var childrenFields = _this.getDependencyChildrenFields(namePath);\n\n    if (childrenFields.length) {\n      _this.validateFields(childrenFields);\n    }\n\n    _this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))\n    });\n\n    return childrenFields;\n  };\n\n  this.updateValue = function (name, value) {\n    var namePath = getNamePath(name);\n    var prevStore = _this.store;\n\n    _this.updateStore(setValue(_this.store, namePath, value));\n\n    _this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n\n    _this.notifyWatch([namePath]); // Dependencies update\n\n\n    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath); // trigger callback function\n\n\n    var onValuesChange = _this.callbacks.onValuesChange;\n\n    if (onValuesChange) {\n      var changedValues = cloneByNamePathList(_this.store, [namePath]);\n      onValuesChange(changedValues, _this.getFieldsValue());\n    }\n\n    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));\n  }; // Let all child Field get update.\n\n\n  this.setFieldsValue = function (store) {\n    _this.warningUnhooked();\n\n    var prevStore = _this.store;\n\n    if (store) {\n      var nextStore = setValues(_this.store, store);\n\n      _this.updateStore(nextStore);\n    }\n\n    _this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n\n    _this.notifyWatch();\n  };\n\n  this.setFieldValue = function (name, value) {\n    _this.setFields([{\n      name: name,\n      value: value\n    }]);\n  };\n\n  this.getDependencyChildrenFields = function (rootNamePath) {\n    var children = new Set();\n    var childrenFields = [];\n    var dependencies2fields = new NameMap();\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n\n    _this.getFieldEntities().forEach(function (field) {\n      var dependencies = field.props.dependencies;\n      (dependencies || []).forEach(function (dependency) {\n        var dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, function () {\n          var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n\n    var fillChildren = function fillChildren(namePath) {\n      var fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(function (field) {\n        if (!children.has(field)) {\n          children.add(field);\n          var fieldNamePath = field.getNamePath();\n\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n\n  this.triggerOnFieldsChange = function (namePathList, filedErrors) {\n    var onFieldsChange = _this.callbacks.onFieldsChange;\n\n    if (onFieldsChange) {\n      var fields = _this.getFields();\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n\n\n      if (filedErrors) {\n        var cache = new NameMap();\n        filedErrors.forEach(function (_ref4) {\n          var name = _ref4.name,\n              errors = _ref4.errors;\n          cache.set(name, errors);\n        });\n        fields.forEach(function (field) {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n\n      var changedFields = fields.filter(function (_ref5) {\n        var fieldName = _ref5.name;\n        return containsNamePath(namePathList, fieldName);\n      });\n      onFieldsChange(changedFields, fields);\n    }\n  }; // =========================== Validate ===========================\n\n\n  this.validateFields = function (nameList, options) {\n    _this.warningUnhooked();\n\n    var provideNameList = !!nameList;\n    var namePathList = provideNameList ? nameList.map(getNamePath) : []; // Collect result in promise list\n\n    var promiseList = [];\n\n    _this.getFieldEntities(true).forEach(function (field) {\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        namePathList.push(field.getNamePath());\n      }\n      /**\n       * Recursive validate if configured.\n       * TODO: perf improvement @zombieJ\n       */\n\n\n      if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {\n        var namePath = field.getNamePath();\n\n        if ( // nameList[i] === undefined 说明是以 nameList 开头的\n        // ['name'] -> ['name','list']\n        namePath.every(function (nameUnit, i) {\n          return nameList[i] === nameUnit || nameList[i] === undefined;\n        })) {\n          namePathList.push(namePath);\n        }\n      } // Skip if without rule\n\n\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      var fieldNamePath = field.getNamePath(); // Add field validate rule in to promise list\n\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {\n        var promise = field.validateRules(_objectSpread({\n          validateMessages: _objectSpread(_objectSpread({}, defaultValidateMessages), _this.validateMessages)\n        }, options)); // Wrap promise with field\n\n        promiseList.push(promise.then(function () {\n          return {\n            name: fieldNamePath,\n            errors: [],\n            warnings: []\n          };\n        }).catch(function (ruleErrors) {\n          var _ruleErrors$forEach;\n\n          var mergedErrors = [];\n          var mergedWarnings = [];\n          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function (_ref6) {\n            var warningOnly = _ref6.rule.warningOnly,\n                errors = _ref6.errors;\n\n            if (warningOnly) {\n              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));\n            } else {\n              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));\n            }\n          });\n\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n\n    var summaryPromise = allPromiseFinish(promiseList);\n    _this.lastValidatePromise = summaryPromise; // Notify fields with rule that validate has finished and need update\n\n    summaryPromise.catch(function (results) {\n      return results;\n    }).then(function (results) {\n      var resultNamePathList = results.map(function (_ref7) {\n        var name = _ref7.name;\n        return name;\n      });\n\n      _this.notifyObservers(_this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n\n      _this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    var returnPromise = summaryPromise.then(function () {\n      if (_this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(_this.getFieldsValue(namePathList));\n      }\n\n      return Promise.reject([]);\n    }).catch(function (results) {\n      var errorList = results.filter(function (result) {\n        return result && result.errors.length;\n      });\n      return Promise.reject({\n        values: _this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: _this.lastValidatePromise !== summaryPromise\n      });\n    }); // Do not throw in console\n\n    returnPromise.catch(function (e) {\n      return e;\n    }); // `validating` changed. Trigger `onFieldsChange`\n\n    _this.triggerOnFieldsChange(namePathList);\n\n    return returnPromise;\n  }; // ============================ Submit ============================\n\n\n  this.submit = function () {\n    _this.warningUnhooked();\n\n    _this.validateFields().then(function (values) {\n      var onFinish = _this.callbacks.onFinish;\n\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(function (e) {\n      var onFinishFailed = _this.callbacks.onFinishFailed;\n\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n\n  this.forceRootUpdate = forceRootUpdate;\n});\n\nfunction useForm(form) {\n  var formRef = React.useRef();\n\n  var _React$useState = React.useState({}),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      forceUpdate = _React$useState2[1];\n\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      var forceReRender = function forceReRender() {\n        forceUpdate({});\n      };\n\n      var formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n\n  return [formRef.current];\n}\n\nexport default useForm;","map":{"version":3,"names":["_slicedToArray","_objectSpread","_objectWithoutProperties","_toConsumableArray","_createClass","_classCallCheck","_excluded","warning","React","HOOK_MARK","allPromiseFinish","cloneDeep","defaultValidateMessages","NameMap","cloneByNamePathList","containsNamePath","getNamePath","getValue","matchNamePath","setValue","setValues","FormStore","forceRootUpdate","_this","formHooked","subscribable","store","fieldEntities","initialValues","callbacks","validateMessages","preserve","lastValidatePromise","getForm","getFieldValue","getFieldsValue","getFieldError","getFieldWarning","getFieldsError","isFieldsTouched","isFieldTouched","isFieldValidating","isFieldsValidating","resetFields","setFields","setFieldValue","setFieldsValue","validateFields","submit","_init","getInternalHooks","key","dispatch","initEntityValue","registerField","useSubscribe","setInitialValues","destroyForm","setCallbacks","setValidateMessages","getFields","setPreserve","getInitialValue","registerWatch","prevWithoutPreserves","init","_this$prevWithoutPres","nextStore","map","_ref","namePath","updateStore","getFieldEntities","forEach","entity","isMergedPreserve","isPreserve","set","initValue","length","watchList","callback","push","filter","fn","notifyWatch","arguments","undefined","values","allValues","timeoutId","warningUnhooked","process","env","NODE_ENV","window","setTimeout","pure","field","getFieldsMap","cache","getFieldEntitiesForNamePathList","nameList","name","get","INVALIDATE_NAME_PATH","filterFunc","Array","isArray","filteredNameList","_entity$isListField","isListField","call","meta","getMeta","index","errors","getErrors","warnings","getWarnings","fieldError","_len","args","_key","arg0","arg1","namePathList","isAllFieldsTouched","every","some","shortNamePath","fieldNamePath","nameUnit","i","update","list","concat","isNamePathListTouched","entities","namePathListEntities","_ref2","value","testField","resetWithFieldInitialValue","info","initialValue","props","records","Set","add","resetWithFields","formInitialValue","join","size","originValue","skipExist","requiredFieldEntities","_requiredFieldEntitie","apply","r","prevStore","notifyObservers","type","fields","fieldData","data","Object","defineProperty","prevValue","fieldPreserve","mergedPreserve","source","subNamePath","item","defaultValue","_prevStore","triggerDependenciesUpdate","action","updateValue","_namePath","triggerName","mergedInfo","_ref3","onStoreChange","childrenFields","getDependencyChildrenFields","relatedFields","onValuesChange","changedValues","triggerOnFieldsChange","rootNamePath","children","dependencies2fields","dependencies","dependency","dependencyNamePath","fillChildren","has","isFieldDirty","filedErrors","onFieldsChange","_ref4","changedFields","_ref5","fieldName","options","provideNameList","promiseList","recursive","rules","promise","validateRules","then","catch","ruleErrors","_ruleErrors$forEach","mergedErrors","mergedWarnings","_ref6","warningOnly","rule","Promise","reject","summaryPromise","results","resultNamePathList","_ref7","returnPromise","resolve","errorList","result","errorFields","outOfDate","e","onFinish","err","console","error","onFinishFailed","useForm","form","formRef","useRef","_React$useState","useState","_React$useState2","forceUpdate","current","forceReRender","formStore"],"sources":["C:/Users/Joshua Doros/Desktop/Tezos/tezos-taquito-escrow/node_modules/rc-field-form/es/useForm.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nvar _excluded = [\"name\"];\nimport warning from \"rc-util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from './FieldContext';\nimport { allPromiseFinish } from './utils/asyncUtil';\nimport cloneDeep from './utils/cloneDeep';\nimport { defaultValidateMessages } from './utils/messages';\nimport NameMap from './utils/NameMap';\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue, setValues } from './utils/valueUtil';\nexport var FormStore = /*#__PURE__*/_createClass(function FormStore(forceRootUpdate) {\n  var _this = this;\n  _classCallCheck(this, FormStore);\n  this.formHooked = false;\n  this.forceRootUpdate = void 0;\n  this.subscribable = true;\n  this.store = {};\n  this.fieldEntities = [];\n  this.initialValues = {};\n  this.callbacks = {};\n  this.validateMessages = null;\n  this.preserve = null;\n  this.lastValidatePromise = null;\n  this.getForm = function () {\n    return {\n      getFieldValue: _this.getFieldValue,\n      getFieldsValue: _this.getFieldsValue,\n      getFieldError: _this.getFieldError,\n      getFieldWarning: _this.getFieldWarning,\n      getFieldsError: _this.getFieldsError,\n      isFieldsTouched: _this.isFieldsTouched,\n      isFieldTouched: _this.isFieldTouched,\n      isFieldValidating: _this.isFieldValidating,\n      isFieldsValidating: _this.isFieldsValidating,\n      resetFields: _this.resetFields,\n      setFields: _this.setFields,\n      setFieldValue: _this.setFieldValue,\n      setFieldsValue: _this.setFieldsValue,\n      validateFields: _this.validateFields,\n      submit: _this.submit,\n      _init: true,\n      getInternalHooks: _this.getInternalHooks\n    };\n  };\n  // ======================== Internal Hooks ========================\n  this.getInternalHooks = function (key) {\n    if (key === HOOK_MARK) {\n      _this.formHooked = true;\n      return {\n        dispatch: _this.dispatch,\n        initEntityValue: _this.initEntityValue,\n        registerField: _this.registerField,\n        useSubscribe: _this.useSubscribe,\n        setInitialValues: _this.setInitialValues,\n        destroyForm: _this.destroyForm,\n        setCallbacks: _this.setCallbacks,\n        setValidateMessages: _this.setValidateMessages,\n        getFields: _this.getFields,\n        setPreserve: _this.setPreserve,\n        getInitialValue: _this.getInitialValue,\n        registerWatch: _this.registerWatch\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  this.useSubscribe = function (subscribable) {\n    _this.subscribable = subscribable;\n  };\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  this.prevWithoutPreserves = null;\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  this.setInitialValues = function (initialValues, init) {\n    _this.initialValues = initialValues || {};\n    if (init) {\n      var _this$prevWithoutPres;\n      var nextStore = setValues({}, initialValues, _this.store);\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function (_ref) {\n        var namePath = _ref.key;\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      _this.prevWithoutPreserves = null;\n      _this.updateStore(nextStore);\n    }\n  };\n  this.destroyForm = function () {\n    var prevWithoutPreserves = new NameMap();\n    _this.getFieldEntities(true).forEach(function (entity) {\n      if (!_this.isMergedPreserve(entity.isPreserve())) {\n        prevWithoutPreserves.set(entity.getNamePath(), true);\n      }\n    });\n    _this.prevWithoutPreserves = prevWithoutPreserves;\n  };\n  this.getInitialValue = function (namePath) {\n    var initValue = getValue(_this.initialValues, namePath);\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? cloneDeep(initValue) : initValue;\n  };\n  this.setCallbacks = function (callbacks) {\n    _this.callbacks = callbacks;\n  };\n  this.setValidateMessages = function (validateMessages) {\n    _this.validateMessages = validateMessages;\n  };\n  this.setPreserve = function (preserve) {\n    _this.preserve = preserve;\n  };\n  // ============================= Watch ============================\n  this.watchList = [];\n  this.registerWatch = function (callback) {\n    _this.watchList.push(callback);\n    return function () {\n      _this.watchList = _this.watchList.filter(function (fn) {\n        return fn !== callback;\n      });\n    };\n  };\n  this.notifyWatch = function () {\n    var namePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    // No need to cost perf when nothing need to watch\n    if (_this.watchList.length) {\n      var values = _this.getFieldsValue();\n      var allValues = _this.getFieldsValue(true);\n      _this.watchList.forEach(function (callback) {\n        callback(values, allValues, namePath);\n      });\n    }\n  };\n  // ========================== Dev Warning =========================\n  this.timeoutId = null;\n  this.warningUnhooked = function () {\n    if (process.env.NODE_ENV !== 'production' && !_this.timeoutId && typeof window !== 'undefined') {\n      _this.timeoutId = setTimeout(function () {\n        _this.timeoutId = null;\n        if (!_this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n  // ============================ Store =============================\n  this.updateStore = function (nextStore) {\n    _this.store = nextStore;\n  };\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  this.getFieldEntities = function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!pure) {\n      return _this.fieldEntities;\n    }\n    return _this.fieldEntities.filter(function (field) {\n      return field.getNamePath().length;\n    });\n  };\n  this.getFieldsMap = function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cache = new NameMap();\n    _this.getFieldEntities(pure).forEach(function (field) {\n      var namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n  this.getFieldEntitiesForNamePathList = function (nameList) {\n    if (!nameList) {\n      return _this.getFieldEntities(true);\n    }\n    var cache = _this.getFieldsMap(true);\n    return nameList.map(function (name) {\n      var namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  };\n  this.getFieldsValue = function (nameList, filterFunc) {\n    _this.warningUnhooked();\n    if (nameList === true && !filterFunc) {\n      return _this.store;\n    }\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);\n    var filteredNameList = [];\n    fieldEntities.forEach(function (entity) {\n      var _entity$isListField;\n      var namePath = 'INVALIDATE_NAME_PATH' in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {\n        return;\n      }\n      if (!filterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        var meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (filterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));\n  };\n  this.getFieldValue = function (name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    return getValue(_this.store, namePath);\n  };\n  this.getFieldsError = function (nameList) {\n    _this.warningUnhooked();\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map(function (entity, index) {\n      if (entity && !('INVALIDATE_NAME_PATH' in entity)) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  this.getFieldError = function (name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    var fieldError = _this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  this.getFieldWarning = function (name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    var fieldError = _this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  this.isFieldsTouched = function () {\n    _this.warningUnhooked();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var arg0 = args[0],\n      arg1 = args[1];\n    var namePathList;\n    var isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    var fieldEntities = _this.getFieldEntities(true);\n    var isFieldTouched = function isFieldTouched(field) {\n      return field.isFieldTouched();\n    };\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);\n    }\n    // Generate a nest tree for validate\n    var map = new NameMap();\n    namePathList.forEach(function (shortNamePath) {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(function (field) {\n      var fieldNamePath = field.getNamePath();\n      // Find matched entity and put into list\n      namePathList.forEach(function (shortNamePath) {\n        if (shortNamePath.every(function (nameUnit, i) {\n          return fieldNamePath[i] === nameUnit;\n        })) {\n          map.update(shortNamePath, function (list) {\n            return [].concat(_toConsumableArray(list), [field]);\n          });\n        }\n      });\n    });\n    // Check if NameMap value is touched\n    var isNamePathListTouched = function isNamePathListTouched(entities) {\n      return entities.some(isFieldTouched);\n    };\n    var namePathListEntities = map.map(function (_ref2) {\n      var value = _ref2.value;\n      return value;\n    });\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  this.isFieldTouched = function (name) {\n    _this.warningUnhooked();\n    return _this.isFieldsTouched([name]);\n  };\n  this.isFieldsValidating = function (nameList) {\n    _this.warningUnhooked();\n    var fieldEntities = _this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(function (testField) {\n        return testField.isFieldValidating();\n      });\n    }\n    var namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(function (testField) {\n      var fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  this.isFieldValidating = function (name) {\n    _this.warningUnhooked();\n    return _this.isFieldsValidating([name]);\n  };\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  this.resetWithFieldInitialValue = function () {\n    var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Create cache\n    var cache = new NameMap();\n    var fieldEntities = _this.getFieldEntities(true);\n    fieldEntities.forEach(function (field) {\n      var initialValue = field.props.initialValue;\n      var namePath = field.getNamePath();\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        var records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n    // Reset\n    var resetWithFields = function resetWithFields(entities) {\n      entities.forEach(function (field) {\n        var initialValue = field.props.initialValue;\n        if (initialValue !== undefined) {\n          var namePath = field.getNamePath();\n          var formInitialValue = _this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, \"Form already set 'initialValues' with path '\".concat(namePath.join('.'), \"'. Field can not overwrite it.\"));\n          } else {\n            var records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, \"Multiple Field with path '\".concat(namePath.join('.'), \"' set 'initialValue'. Can not decide which one to pick.\"));\n            } else if (records) {\n              var originValue = _this.getFieldValue(namePath);\n              // Set `initialValue`\n              if (!info.skipExist || originValue === undefined) {\n                _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    var requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(function (namePath) {\n        var records = cache.get(namePath);\n        if (records) {\n          var _requiredFieldEntitie;\n          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function (r) {\n            return r.entity;\n          })));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  this.resetFields = function (nameList) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    if (!nameList) {\n      _this.updateStore(setValues({}, _this.initialValues));\n      _this.resetWithFieldInitialValue();\n      _this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      _this.notifyWatch();\n      return;\n    }\n    // Reset by `nameList`\n    var namePathList = nameList.map(getNamePath);\n    namePathList.forEach(function (namePath) {\n      var initialValue = _this.getInitialValue(namePath);\n      _this.updateStore(setValue(_this.store, namePath, initialValue));\n    });\n    _this.resetWithFieldInitialValue({\n      namePathList: namePathList\n    });\n    _this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    _this.notifyWatch(namePathList);\n  };\n  this.setFields = function (fields) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    var namePathList = [];\n    fields.forEach(function (fieldData) {\n      var name = fieldData.name,\n        data = _objectWithoutProperties(fieldData, _excluded);\n      var namePath = getNamePath(name);\n      namePathList.push(namePath);\n      // Value\n      if ('value' in data) {\n        _this.updateStore(setValue(_this.store, namePath, data.value));\n      }\n      _this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    _this.notifyWatch(namePathList);\n  };\n  this.getFields = function () {\n    var entities = _this.getFieldEntities(true);\n    var fields = entities.map(function (field) {\n      var namePath = field.getNamePath();\n      var meta = field.getMeta();\n      var fieldData = _objectSpread(_objectSpread({}, meta), {}, {\n        name: namePath,\n        value: _this.getFieldValue(namePath)\n      });\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  this.initEntityValue = function (entity) {\n    var initialValue = entity.props.initialValue;\n    if (initialValue !== undefined) {\n      var namePath = entity.getNamePath();\n      var prevValue = getValue(_this.store, namePath);\n      if (prevValue === undefined) {\n        _this.updateStore(setValue(_this.store, namePath, initialValue));\n      }\n    }\n  };\n  this.isMergedPreserve = function (fieldPreserve) {\n    var mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : _this.preserve;\n    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;\n  };\n  this.registerField = function (entity) {\n    _this.fieldEntities.push(entity);\n    var namePath = entity.getNamePath();\n    _this.notifyWatch([namePath]);\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      var prevStore = _this.store;\n      _this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      _this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n    // un-register field callback\n    return function (isListField, preserve) {\n      var subNamePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      _this.fieldEntities = _this.fieldEntities.filter(function (item) {\n        return item !== entity;\n      });\n      // Clean up store value if not preserve\n      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        var defaultValue = isListField ? undefined : _this.getInitialValue(namePath);\n        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function (field) {\n          return (\n            // Only reset when no namePath exist\n            !matchNamePath(field.getNamePath(), namePath)\n          );\n        })) {\n          var _prevStore = _this.store;\n          _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));\n          // Notify that field is unmount\n          _this.notifyObservers(_prevStore, [namePath], {\n            type: 'remove'\n          });\n          // Dependencies update\n          _this.triggerDependenciesUpdate(_prevStore, namePath);\n        }\n      }\n      _this.notifyWatch([namePath]);\n    };\n  };\n  this.dispatch = function (action) {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          var namePath = action.namePath,\n            value = action.value;\n          _this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          var _namePath = action.namePath,\n            triggerName = action.triggerName;\n          _this.validateFields([_namePath], {\n            triggerName: triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n  this.notifyObservers = function (prevStore, namePathList, info) {\n    if (_this.subscribable) {\n      var mergedInfo = _objectSpread(_objectSpread({}, info), {}, {\n        store: _this.getFieldsValue(true)\n      });\n      _this.getFieldEntities().forEach(function (_ref3) {\n        var onStoreChange = _ref3.onStoreChange;\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      _this.forceRootUpdate();\n    }\n  };\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  this.triggerDependenciesUpdate = function (prevStore, namePath) {\n    var childrenFields = _this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      _this.validateFields(childrenFields);\n    }\n    _this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))\n    });\n    return childrenFields;\n  };\n  this.updateValue = function (name, value) {\n    var namePath = getNamePath(name);\n    var prevStore = _this.store;\n    _this.updateStore(setValue(_this.store, namePath, value));\n    _this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    _this.notifyWatch([namePath]);\n    // Dependencies update\n    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);\n    // trigger callback function\n    var onValuesChange = _this.callbacks.onValuesChange;\n    if (onValuesChange) {\n      var changedValues = cloneByNamePathList(_this.store, [namePath]);\n      onValuesChange(changedValues, _this.getFieldsValue());\n    }\n    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));\n  };\n  // Let all child Field get update.\n  this.setFieldsValue = function (store) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    if (store) {\n      var nextStore = setValues(_this.store, store);\n      _this.updateStore(nextStore);\n    }\n    _this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    _this.notifyWatch();\n  };\n  this.setFieldValue = function (name, value) {\n    _this.setFields([{\n      name: name,\n      value: value\n    }]);\n  };\n  this.getDependencyChildrenFields = function (rootNamePath) {\n    var children = new Set();\n    var childrenFields = [];\n    var dependencies2fields = new NameMap();\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    _this.getFieldEntities().forEach(function (field) {\n      var dependencies = field.props.dependencies;\n      (dependencies || []).forEach(function (dependency) {\n        var dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, function () {\n          var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    var fillChildren = function fillChildren(namePath) {\n      var fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(function (field) {\n        if (!children.has(field)) {\n          children.add(field);\n          var fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  this.triggerOnFieldsChange = function (namePathList, filedErrors) {\n    var onFieldsChange = _this.callbacks.onFieldsChange;\n    if (onFieldsChange) {\n      var fields = _this.getFields();\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        var cache = new NameMap();\n        filedErrors.forEach(function (_ref4) {\n          var name = _ref4.name,\n            errors = _ref4.errors;\n          cache.set(name, errors);\n        });\n        fields.forEach(function (field) {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      var changedFields = fields.filter(function (_ref5) {\n        var fieldName = _ref5.name;\n        return containsNamePath(namePathList, fieldName);\n      });\n      onFieldsChange(changedFields, fields);\n    }\n  };\n  // =========================== Validate ===========================\n  this.validateFields = function (nameList, options) {\n    _this.warningUnhooked();\n    var provideNameList = !!nameList;\n    var namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Collect result in promise list\n    var promiseList = [];\n    _this.getFieldEntities(true).forEach(function (field) {\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        namePathList.push(field.getNamePath());\n      }\n      /**\n       * Recursive validate if configured.\n       * TODO: perf improvement @zombieJ\n       */\n      if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {\n        var namePath = field.getNamePath();\n        if (\n        // nameList[i] === undefined 说明是以 nameList 开头的\n        // ['name'] -> ['name','list']\n        namePath.every(function (nameUnit, i) {\n          return nameList[i] === nameUnit || nameList[i] === undefined;\n        })) {\n          namePathList.push(namePath);\n        }\n      }\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n      var fieldNamePath = field.getNamePath();\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {\n        var promise = field.validateRules(_objectSpread({\n          validateMessages: _objectSpread(_objectSpread({}, defaultValidateMessages), _this.validateMessages)\n        }, options));\n        // Wrap promise with field\n        promiseList.push(promise.then(function () {\n          return {\n            name: fieldNamePath,\n            errors: [],\n            warnings: []\n          };\n        }).catch(function (ruleErrors) {\n          var _ruleErrors$forEach;\n          var mergedErrors = [];\n          var mergedWarnings = [];\n          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function (_ref6) {\n            var warningOnly = _ref6.rule.warningOnly,\n              errors = _ref6.errors;\n            if (warningOnly) {\n              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));\n            } else {\n              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    var summaryPromise = allPromiseFinish(promiseList);\n    _this.lastValidatePromise = summaryPromise;\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(function (results) {\n      return results;\n    }).then(function (results) {\n      var resultNamePathList = results.map(function (_ref7) {\n        var name = _ref7.name;\n        return name;\n      });\n      _this.notifyObservers(_this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      _this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    var returnPromise = summaryPromise.then(function () {\n      if (_this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(_this.getFieldsValue(namePathList));\n      }\n      return Promise.reject([]);\n    }).catch(function (results) {\n      var errorList = results.filter(function (result) {\n        return result && result.errors.length;\n      });\n      return Promise.reject({\n        values: _this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: _this.lastValidatePromise !== summaryPromise\n      });\n    });\n    // Do not throw in console\n    returnPromise.catch(function (e) {\n      return e;\n    });\n    // `validating` changed. Trigger `onFieldsChange`\n    _this.triggerOnFieldsChange(namePathList);\n    return returnPromise;\n  };\n  // ============================ Submit ============================\n  this.submit = function () {\n    _this.warningUnhooked();\n    _this.validateFields().then(function (values) {\n      var onFinish = _this.callbacks.onFinish;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(function (e) {\n      var onFinishFailed = _this.callbacks.onFinishFailed;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n  this.forceRootUpdate = forceRootUpdate;\n});\nfunction useForm(form) {\n  var formRef = React.useRef();\n  var _React$useState = React.useState({}),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    forceUpdate = _React$useState2[1];\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      var forceReRender = function forceReRender() {\n        forceUpdate({});\n      };\n      var formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;"],"mappings":"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"},"metadata":{},"sourceType":"module"}