{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\n\nvar QueueAction = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(QueueAction, _super);\n\n  function QueueAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    return _this;\n  }\n\n  QueueAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay > 0) {\n      return _super.prototype.schedule.call(this, state, delay);\n    }\n\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  };\n\n  QueueAction.prototype.execute = function (state, delay) {\n    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);\n  };\n\n  QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {\n      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n    }\n\n    return scheduler.flush(this);\n  };\n\n  return QueueAction;\n}(AsyncAction);\n\nexport { QueueAction };","map":{"version":3,"sources":["../../../src/internal/scheduler/QueueAction.ts"],"names":[],"mappings":";AAAA,OAAO,KAAE,OAAT,MAAsB,OAAtB;AAUA,SAAA,WAAA,QAAA,eAAA;;IAAoC,WAAA,GAAA,aAAA,UAAc,MAAd,EAAc;EAEhD,OAAA,CAAA,SAAA,CAAA,WAAA,EAA+C,MAA/C;;EAAA,SAAA,WAAA,CAEE,SAFF,EAEE,IAFF,EAEQ;IAFc,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAyB,SAAzB,EAAyB,IAAzB,KAAyB,IAAzB;;IACA,KAAA,CAAA,SAAA,GAAmD,SAAnD;;IAErB,OAAA,KAAA;EAED;;EAA2B,WAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAiB,KAAjB,EAAiB,KAAjB,EAAiB;IAC1C,IAAI,KAAK,KAAI,KAAE,CAAf,EAAe;MACb,KAAA,GAAO,CAAP;IACD;;IACD,IAAI,KAAC,GAAK,CAAV,EAAa;MACT,OAAM,MAAG,CAAK,SAAR,CAAS,QAAT,CAAS,IAAT,CAAS,IAAT,EAAS,KAAT,EAAS,KAAT,CAAN;IACJ;;IACA,KAAA,KAAA,GAAY,KAAZ;IACD,KAAA,KAAA,GAAA,KAAA;IAEM,KAAA,SAAA,CAAA,KAAA,CAAP,IAAO;IACL,OAAO,IAAP;EACE,CAZuB;;EAavB,WAAA,CAAI,SAAJ,CAAc,OAAd,GAAqB,UAAQ,KAAR,EAAQ,KAAR,EAAQ;IAChC,OAAA,KAAA,GAAA,CAAA,IAAA,KAAA,MAAA,GAES,MAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAV,IAAU,EAAV,KAAU,EAAe,KAAf,CAFT,GAE6D,KAAA,QAAA,CAAA,KAAA,EAAA,KAAA,CAF7D;EAMC,CAPE;;EAQA,WAAA,CAAA,SAAA,CAAO,cAAP,GAAa,UAAc,SAAd,EAAe,EAAf,EAAe,KAAf,EAA4B;IAC1C,IAAA,KAAA,KAAA,KAAA,CAAA,EAAA;MAED,KAAO,GAAA,CAAP;IACD;;IACH,IAAA,KAAA,KAAC,IAAD,IAAC,KAAA,GAAA,CAAD,IAAC,KAAA,KAAA,IAAA,IAAA,KAAA,KAAA,GAAA,CAAD,EAAC;MAjCmC,OAiCnC,MAAA,CAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,IAAA,EAAA,SAAA,EAAA,EAAA,EAAA,KAAA,CAjCmC;;;;GA4B9B;;;CA5B8B,C,WAAA,C","sourcesContent":["/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nvar QueueAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction));\nexport { QueueAction };\n//# sourceMappingURL=QueueAction.js.map\n"]},"metadata":{},"sourceType":"module"}