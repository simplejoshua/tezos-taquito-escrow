{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise } from '@airgap/beacon-utils';\nimport { getKeypairFromSeed, toHex, generateGUID } from '@airgap/beacon-utils';\nimport { StorageKey } from '@airgap/beacon-types';\nimport { SDK_VERSION } from '../../constants';\nimport { windowRef } from '../../MockWindow';\n/**\n * @internalapi\n *\n * The beacon client is an abstract client that handles everything that is shared between all other clients.\n * Specifically, it handles managing the beaconId and and the local keypair.\n */\n\nexport class BeaconClient {\n  constructor(config) {\n    /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n     * This is used inside a message to specify the sender, for example.\n     */\n    this._beaconId = new ExposedPromise();\n    /**\n     * The local keypair that is used for the communication encryption\n     */\n\n    this._keyPair = new ExposedPromise();\n\n    if (!config.name) {\n      throw new Error('Name not set');\n    }\n\n    if (!config.storage) {\n      throw new Error('Storage not set');\n    }\n\n    this.name = config.name;\n    this.iconUrl = config.iconUrl;\n    this.appUrl = config.appUrl;\n    this.storage = config.storage; // TODO: This is a temporary \"fix\" to prevent users from creating multiple Client instances\n\n    if (windowRef.beaconCreatedClientInstance) {\n      console.warn('[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere.');\n    } else {\n      ;\n      windowRef.beaconCreatedClientInstance = true;\n    }\n\n    this.initSDK().catch(console.error);\n  }\n\n  get beaconId() {\n    return this._beaconId.promise;\n  }\n\n  get keyPair() {\n    return this._keyPair.promise;\n  }\n  /**\n   * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n   */\n\n\n  destroy() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.removeBeaconEntriesFromStorage();\n      windowRef.beaconCreatedClientInstance = false;\n    });\n  }\n  /**\n   * This method initializes the SDK by setting some values in the storage and generating a keypair.\n   */\n\n\n  initSDK() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.storage.set(StorageKey.BEACON_SDK_VERSION, SDK_VERSION).catch(console.error);\n      this.loadOrCreateBeaconSecret().catch(console.error);\n      return this.keyPair.then(keyPair => {\n        this._beaconId.resolve(toHex(keyPair.publicKey));\n      });\n    });\n  }\n  /**\n   * Removes all beacon values from the storage.\n   */\n\n\n  removeBeaconEntriesFromStorage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const allKeys = Object.values(StorageKey);\n      yield Promise.all(allKeys.map(key => this.storage.delete(key)));\n    });\n  }\n  /**\n   * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.\n   */\n\n\n  loadOrCreateBeaconSecret() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const storageValue = yield this.storage.get(StorageKey.BEACON_SDK_SECRET_SEED);\n\n      if (storageValue && typeof storageValue === 'string') {\n        this._keyPair.resolve(yield getKeypairFromSeed(storageValue));\n      } else {\n        const key = yield generateGUID();\n        yield this.storage.set(StorageKey.BEACON_SDK_SECRET_SEED, key);\n\n        this._keyPair.resolve(yield getKeypairFromSeed(key));\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/clients/beacon-client/BeaconClient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ExposedPromise } from '@airgap/beacon-utils';\nimport { getKeypairFromSeed, toHex, generateGUID } from '@airgap/beacon-utils';\nimport { StorageKey } from '@airgap/beacon-types';\nimport { SDK_VERSION } from '../../constants';\nimport { windowRef } from '../../MockWindow';\n/**\n * @internalapi\n *\n * The beacon client is an abstract client that handles everything that is shared between all other clients.\n * Specifically, it handles managing the beaconId and and the local keypair.\n */\nexport class BeaconClient {\n    constructor(config) {\n        /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n         * This is used inside a message to specify the sender, for example.\n         */\n        this._beaconId = new ExposedPromise();\n        /**\n         * The local keypair that is used for the communication encryption\n         */\n        this._keyPair = new ExposedPromise();\n        if (!config.name) {\n            throw new Error('Name not set');\n        }\n        if (!config.storage) {\n            throw new Error('Storage not set');\n        }\n        this.name = config.name;\n        this.iconUrl = config.iconUrl;\n        this.appUrl = config.appUrl;\n        this.storage = config.storage;\n        // TODO: This is a temporary \"fix\" to prevent users from creating multiple Client instances\n        if (windowRef.beaconCreatedClientInstance) {\n            console.warn('[BEACON] It looks like you created multiple Beacon SDK Client instances. This can lead to problems. Only create one instance and re-use it everywhere.');\n        }\n        else {\n            ;\n            windowRef.beaconCreatedClientInstance = true;\n        }\n        this.initSDK().catch(console.error);\n    }\n    get beaconId() {\n        return this._beaconId.promise;\n    }\n    get keyPair() {\n        return this._keyPair.promise;\n    }\n    /**\n     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n     */\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.removeBeaconEntriesFromStorage();\n            windowRef.beaconCreatedClientInstance = false;\n        });\n    }\n    /**\n     * This method initializes the SDK by setting some values in the storage and generating a keypair.\n     */\n    initSDK() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.storage.set(StorageKey.BEACON_SDK_VERSION, SDK_VERSION).catch(console.error);\n            this.loadOrCreateBeaconSecret().catch(console.error);\n            return this.keyPair.then((keyPair) => {\n                this._beaconId.resolve(toHex(keyPair.publicKey));\n            });\n        });\n    }\n    /**\n     * Removes all beacon values from the storage.\n     */\n    removeBeaconEntriesFromStorage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const allKeys = Object.values(StorageKey);\n            yield Promise.all(allKeys.map((key) => this.storage.delete(key)));\n        });\n    }\n    /**\n     * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.\n     */\n    loadOrCreateBeaconSecret() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const storageValue = yield this.storage.get(StorageKey.BEACON_SDK_SECRET_SEED);\n            if (storageValue && typeof storageValue === 'string') {\n                this._keyPair.resolve(yield getKeypairFromSeed(storageValue));\n            }\n            else {\n                const key = yield generateGUID();\n                yield this.storage.set(StorageKey.BEACON_SDK_SECRET_SEED, key);\n                this._keyPair.resolve(yield getKeypairFromSeed(key));\n            }\n        });\n    }\n}\n//# sourceMappingURL=BeaconClient.js.map"]},"metadata":{},"sourceType":"module"}