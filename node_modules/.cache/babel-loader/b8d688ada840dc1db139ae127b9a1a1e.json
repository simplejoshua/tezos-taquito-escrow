{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise, ExposedPromiseStatus, generateGUID } from '@airgap/beacon-utils';\nimport { TransportStatus, BeaconMessageType } from '@airgap/beacon-types';\nimport { Serializer } from '../..';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nconst logger = new Logger('Client');\n/**\n * @internalapi\n *\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\n\nexport class Client extends BeaconClient {\n  constructor(config) {\n    var _a;\n\n    super(config);\n    /**\n     * How many requests can be sent after another\n     */\n\n    this.rateLimit = 2;\n    /**\n     * The time window in seconds in which the \"rateLimit\" is checked\n     */\n\n    this.rateLimitWindowInSeconds = 5;\n    /**\n     * Stores the times when requests have been made to determine if the rate limit has been reached\n     */\n\n    this.requestCounter = [];\n    this._transport = new ExposedPromise();\n    this.accountManager = new AccountManager(config.storage);\n    this.matrixNodes = (_a = config.matrixNodes) !== null && _a !== void 0 ? _a : [];\n\n    this.handleResponse = (message, connectionInfo) => {\n      throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);\n    };\n  }\n\n  get transport() {\n    return this._transport.promise;\n  }\n  /**\n   * Returns the connection status of the Client\n   */\n\n\n  get connectionStatus() {\n    var _a, _b;\n\n    return (_b = (_a = this._transport.promiseResult) === null || _a === void 0 ? void 0 : _a.connectionStatus) !== null && _b !== void 0 ? _b : TransportStatus.NOT_CONNECTED;\n  }\n  /**\n   * Returns whether or not the transaport is ready\n   */\n\n\n  get ready() {\n    return this.transport.then(() => undefined);\n  }\n  /**\n   * Return all locally known accounts\n   */\n\n\n  getAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.getAccounts();\n    });\n  }\n  /**\n   * Return the account by ID\n   * @param accountIdentifier The ID of an account\n   */\n\n\n  getAccount(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.getAccount(accountIdentifier);\n    });\n  }\n  /**\n   * Remove the account by ID\n   * @param accountIdentifier The ID of an account\n   */\n\n\n  removeAccount(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.removeAccount(accountIdentifier);\n    });\n  }\n  /**\n   * Remove all locally stored accounts\n   */\n\n\n  removeAllAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.removeAllAccounts();\n    });\n  }\n  /**\n   * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n   */\n\n\n  addRequestAndCheckIfRateLimited() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = new Date().getTime();\n      this.requestCounter = this.requestCounter.filter(date => date + this.rateLimitWindowInSeconds * 1000 > now);\n      this.requestCounter.push(now);\n      return this.requestCounter.length > this.rateLimit;\n    });\n  }\n  /**\n   * This method initializes the client. It will check if the connection should be established to a\n   * browser extension or if the P2P transport should be used.\n   *\n   * @param transport A transport that can be provided by the user\n   */\n\n\n  init(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n        return (yield this.transport).type;\n      }\n\n      yield this.setTransport(transport); // Let users define their own transport\n\n      return transport.type;\n    });\n  }\n  /**\n   * Returns the metadata of this DApp\n   */\n\n\n  getOwnAppMetadata() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        senderId: yield getSenderId(yield this.beaconId),\n        name: this.name,\n        icon: this.iconUrl\n      };\n    });\n  }\n  /**\n   * Return all known peers\n   */\n\n\n  getPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.transport).getPeers();\n    });\n  }\n  /**\n   * Add a new peer to the known peers\n   * @param peer The new peer to add\n   */\n\n\n  addPeer(peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.transport).addPeer(peer);\n    });\n  }\n\n  destroy() {\n    const _super = Object.create(null, {\n      destroy: {\n        get: () => super.destroy\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n        yield (yield this.transport).disconnect();\n      }\n\n      yield _super.destroy.call(this);\n    });\n  }\n  /**\n   * A \"setter\" for when the transport needs to be changed.\n   */\n\n\n  setTransport(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (transport) {\n        if (this._transport.isSettled()) {\n          // If the promise has already been resolved we need to create a new one.\n          this._transport = ExposedPromise.resolve(transport);\n        } else {\n          this._transport.resolve(transport);\n        }\n      } else {\n        if (this._transport.isSettled()) {\n          // If the promise has already been resolved we need to create a new one.\n          this._transport = new ExposedPromise();\n        }\n      }\n    });\n  }\n\n  addListener(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      transport.addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n        if (typeof message === 'string') {\n          const deserializedMessage = yield new Serializer().deserialize(message);\n          this.handleResponse(deserializedMessage, connectionInfo);\n        }\n      })).catch(error => logger.error('addListener', error));\n    });\n  }\n\n  sendDisconnectToPeer(peer, transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const request = {\n        id: yield generateGUID(),\n        version: peer.version,\n        senderId: yield getSenderId(yield this.beaconId),\n        type: BeaconMessageType.Disconnect\n      };\n      const payload = yield new Serializer().serialize(request);\n      const selectedTransport = transport !== null && transport !== void 0 ? transport : yield this.transport;\n      yield selectedTransport.send(payload, peer);\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/clients/client/Client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ExposedPromise, ExposedPromiseStatus, generateGUID } from '@airgap/beacon-utils';\nimport { TransportStatus, BeaconMessageType } from '@airgap/beacon-types';\nimport { Serializer } from '../..';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nconst logger = new Logger('Client');\n/**\n * @internalapi\n *\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\nexport class Client extends BeaconClient {\n    constructor(config) {\n        var _a;\n        super(config);\n        /**\n         * How many requests can be sent after another\n         */\n        this.rateLimit = 2;\n        /**\n         * The time window in seconds in which the \"rateLimit\" is checked\n         */\n        this.rateLimitWindowInSeconds = 5;\n        /**\n         * Stores the times when requests have been made to determine if the rate limit has been reached\n         */\n        this.requestCounter = [];\n        this._transport = new ExposedPromise();\n        this.accountManager = new AccountManager(config.storage);\n        this.matrixNodes = (_a = config.matrixNodes) !== null && _a !== void 0 ? _a : [];\n        this.handleResponse = (message, connectionInfo) => {\n            throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);\n        };\n    }\n    get transport() {\n        return this._transport.promise;\n    }\n    /**\n     * Returns the connection status of the Client\n     */\n    get connectionStatus() {\n        var _a, _b;\n        return (_b = (_a = this._transport.promiseResult) === null || _a === void 0 ? void 0 : _a.connectionStatus) !== null && _b !== void 0 ? _b : TransportStatus.NOT_CONNECTED;\n    }\n    /**\n     * Returns whether or not the transaport is ready\n     */\n    get ready() {\n        return this.transport.then(() => undefined);\n    }\n    /**\n     * Return all locally known accounts\n     */\n    getAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.getAccounts();\n        });\n    }\n    /**\n     * Return the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    getAccount(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.getAccount(accountIdentifier);\n        });\n    }\n    /**\n     * Remove the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    removeAccount(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.removeAccount(accountIdentifier);\n        });\n    }\n    /**\n     * Remove all locally stored accounts\n     */\n    removeAllAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.removeAllAccounts();\n        });\n    }\n    /**\n     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n     */\n    addRequestAndCheckIfRateLimited() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const now = new Date().getTime();\n            this.requestCounter = this.requestCounter.filter((date) => date + this.rateLimitWindowInSeconds * 1000 > now);\n            this.requestCounter.push(now);\n            return this.requestCounter.length > this.rateLimit;\n        });\n    }\n    /**\n     * This method initializes the client. It will check if the connection should be established to a\n     * browser extension or if the P2P transport should be used.\n     *\n     * @param transport A transport that can be provided by the user\n     */\n    init(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n                return (yield this.transport).type;\n            }\n            yield this.setTransport(transport); // Let users define their own transport\n            return transport.type;\n        });\n    }\n    /**\n     * Returns the metadata of this DApp\n     */\n    getOwnAppMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                senderId: yield getSenderId(yield this.beaconId),\n                name: this.name,\n                icon: this.iconUrl\n            };\n        });\n    }\n    /**\n     * Return all known peers\n     */\n    getPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (yield this.transport).getPeers();\n        });\n    }\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (yield this.transport).addPeer(peer);\n        });\n    }\n    destroy() {\n        const _super = Object.create(null, {\n            destroy: { get: () => super.destroy }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n                yield (yield this.transport).disconnect();\n            }\n            yield _super.destroy.call(this);\n        });\n    }\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    setTransport(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (transport) {\n                if (this._transport.isSettled()) {\n                    // If the promise has already been resolved we need to create a new one.\n                    this._transport = ExposedPromise.resolve(transport);\n                }\n                else {\n                    this._transport.resolve(transport);\n                }\n            }\n            else {\n                if (this._transport.isSettled()) {\n                    // If the promise has already been resolved we need to create a new one.\n                    this._transport = new ExposedPromise();\n                }\n            }\n        });\n    }\n    addListener(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            transport\n                .addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n                if (typeof message === 'string') {\n                    const deserializedMessage = (yield new Serializer().deserialize(message));\n                    this.handleResponse(deserializedMessage, connectionInfo);\n                }\n            }))\n                .catch((error) => logger.error('addListener', error));\n        });\n    }\n    sendDisconnectToPeer(peer, transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request = {\n                id: yield generateGUID(),\n                version: peer.version,\n                senderId: yield getSenderId(yield this.beaconId),\n                type: BeaconMessageType.Disconnect\n            };\n            const payload = yield new Serializer().serialize(request);\n            const selectedTransport = transport !== null && transport !== void 0 ? transport : (yield this.transport);\n            yield selectedTransport.send(payload, peer);\n        });\n    }\n}\n//# sourceMappingURL=Client.js.map"]},"metadata":{},"sourceType":"module"}